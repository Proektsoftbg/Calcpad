<!DOCTYPE html>
<html lang="zh">
<head>
    <title>Calcpad自述文件</title>
    <meta charset="UTF-8">
    <style>
        .menu {
            position: fixed;
            left: 780px;
            top: 0;
            font-size: 11pt;
            list-style: none;
            margin: 0;
            line-height: 125%;
        }

            .menu li {
                margin-left: -14px;
            }

                .menu li ul {
                    font-size: 11pt;
                    list-style: none;
                    display: none;
                }

        .active {
            color: black !Important;
            font-weight: bold;
            font-size: 11pt;
        }

        body {
            font-size: 11pt;
            font-family: "Segoe UI";
        }

        .body {
            width: 700px;
            max-width: 85%;
            background: white;
            margin: 12px;
            padding: 12px 24px 12px 30px;
        }

        th {
            background-color: #F0F0F0;
            border: solid 1px #AAAAAA;
            padding: 6px;
        }

        td {
            border: solid 1px #cccccc;
            padding: 6px;
        }

        .small td {
            padding: 3px;
        }

        .nb td {
            border: none;
        }

        .tr td {
            text-align: right;
        }

        p {
            line-height: 150%;
        }

        ul {
            padding-left: 24px;
        }

        li ul {
            padding-left: 12px;
        }

        h1 {
            font-family: "Calibri Light";
            font-weight: normal;
            font-size: 32pt;
            margin: 0;
        }

            h1 img {
                margin-top: -6px;
            }

        li {
            margin: 6px;
        }

        .menu li ul {
            padding-left: 42px;
        }

        var {
            color: #06c;
            font-family: "Times New Roman";
            font-size: 12.5pt
        }

        code {
            background-color: #eef4fa
        }

            code var, code i {
                font-family: inherit;
                font-size: 12pt;
                font-style: normal
            }

        sub var, sup var {
            font-size: 9pt
        }

        .small td, .small th, .small var {
            font-size: 9pt;
        }

        i {
            color: #086;
            font-family: Times New Roman;
            font-style: normal;
            font-size: 11.5pt;
        }

        img {
            vertical-align: middle;
            max-width: 100%;
        }

        u {
            background-color: LightYellow;
        }

        .comment {
            color: green;
        }

        .root {
            font-family: Times New Roman;
            font-size: 14pt;
        }

        .ovr {
            border-top: solid 1px;
            padding-left: 1pt;
            padding-top: -2pt;
        }

        code .ovr {
            padding-top: 2pt;
            font-family: "Consolas";
            font-size: 10pt;
        }

        .dvc {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            line-height: 110%;
            white-space: nowrap;
        }

        .dvl {
            display: block;
            border-bottom: solid 1px black;
        }

        .dvc.down {
            position: relative;
            top: 0.5em;
        }

        .dvc.up {
            position: relative;
            bottom: 0.6em;
        }

        .cond {
            color: magenta;
        }

        .macro {
            color: darkMagenta;
        }

        .err {
            color: red;
        }

        .toc {
            color: #888888;
            text-decoration: none;
            font-size: 10.5pt;
        }

            .toc:hover {
                text-decoration: underline;
                color: black;
            }

        .fold {
            height: 2.4em;
            overflow: hidden;
        }

        .unfold {
            height: auto;
            overflow: auto;
        }

            .fold > :first-child, .unfold > :first-child {
                cursor: pointer;
            }

                .fold > :first-child:hover, .unfold > :first-child:hover {
                    color: #0066bb;
                    text-decoration: underline;
                }

                .fold > :first-child::after {
                    content: " … ▼";
                    font-size: 80%;
                }

                .unfold > :first-child::after {
                    content: " ▲";
                    font-size: 80%;
                }

        #Units {
            float: right;
            margin-top: 12px;
        }

        input[type="text"], select {
            font-size: 11pt;
            padding: 0.15em 0.3em;
            border: 0.5pt solid #CCC;
            border-radius: 0.35em;
            text-align: right;
            box-shadow: 0.06em 0.06em 0.5em #ddd;
            background-color: LightYellow;
        }

        input[type="checkbox"],
        input[type="radio"] {
            --screen-scale-factor: 1.1;
            zoom: var(--screen-scale-factor);
            -moz-transform: scale(var(--screen-scale-factor));
            -webkit-transform: scale(var(--screen-scale-factor));
            transform: scale(var(--screen-scale-factor));
            transform-origin: top;
            position: relative;
            bottom: -1pt;
            margin-right: 1pt;
        }

            input[type="checkbox"].post:disabled:not(:checked),
            input[type="checkbox"].post:disabled:not(:checked) + label,
            input[type="radio"].post:disabled:not(:checked),
            input[type="radio"].post:disabled:not(:checked) + label {
                display: none;
            }

        select.post:disabled {
            font-size: 12pt;
            border: none;
            box-shadow: none;
            color: red;
            background: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

            select.post:disabled::-ms-expand {
                display: none;
            }

        input[type="text"]:focus {
            box-shadow: 0.1em 0.1em 1em #ccc;
            color: black;
        }

        .exp {
            display: inline-block;
            height: 13pt;
            line-height: 80%;
            font-size: 12pt;
            font-weight: bold;
            border: solid 1px #cccccc;
            padding: 0 1.5pt 0 1.5pt;
            margin-right: 4pt;
            border-radius: 4pt;
        }

            .exp:hover {
                cursor: pointer;
                box-shadow: #cccccc 0 0 4px;
            }

        sub {
            font-family: Arial Nova;
            font-size: 70%;
            padding-left: 0.5pt;
            padding-right: 0.5pt;
        }

        @media screen and (max-width: 960px) {
            .menu {
                display: none;
            }
        }

        .vec {
            font-family: 'Cambria Math';
            color: black;
            font-style: normal;
            display: inline-block;
            vertical-align: 2pt;
            margin-left: 2pt;
            margin-right: -5pt;
        }

        .hang {
            display: inline-block;
            width: 350pt;
            vertical-align: top;
        }

        .dvs {
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            text-align: left;
            line-height: 110%;
        }

        .dvr {
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            text-align: center;
            line-height: 105%;
        }

        .nary {
            color: #D000D0;
            font-size: 200%;
            font-family: "Segoe UI Light";
            line-height: 80%;
            display: block;
            margin-top: -3pt;
            margin-bottom: 5pt;
        }

        .eq sub {
            font-family: Calibri, 'Gill Sans', 'Gill Sans MT', 'Trebuchet MS', sans-serif;
            font-size: 92%;
            vertical-align: -18%;
        }

        .eq sup {
            display: inline-block;
            margin-left: 1pt;
            margin-top: -2pt;
        }

        .eq small {
            font-family: Calibri, 'Gill Sans', 'Gill Sans MT', 'Trebuchet MS', sans-serif;
            font-size: 70%;
        }

            .eq small var {
                font-family: "Times New Roman", Times, serif;
                font-size: 9pt;
            }

            .eq small i {
                font-family: "Times New Roman", Times, serif;
                font-size: 8pt;
            }

        .nth {
            position: relative;
            bottom: 1pt;
        }

        .eq small.nth {
            font-size: 70%;
        }

        .r0, .r1, .r2, .r3,
        .o0, .o1, .o2, .o3,
        .b1, .b2, .b3,
        .c1, .c2, .c3, .c4,
        .c5, .c6, .c7, .c8 {
            display: inline-block;
        }

        .r0, .r1, .r2, .r3 {
            margin-top: -1.5pt;
            margin-right: 1.5pt;
            vertical-align: top;
            background-repeat: no-repeat;
            background-size: cover;
            background-position: right top;
        }

        .o0, .o1, .o2, .o3 {
            border-top: solid 0.75pt;
            line-height: 130%;
            vertical-align: middle;
            margin-top: 0.75pt;
            padding-top: 1.25pt;
            padding-left: 1pt;
            padding-right: 1pt;
        }

        .r {
            font-size: 130%;
            display: inline-block;
            vertical-align: top;
            margin-left: -9pt;
        }

        .r0 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwIDIwIiBoZWlnaHQ9IjE1cHQiIHdpZHRoPSIxMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMCwxMyAyLDEyIDUsMTkgOSwwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC42cHQ7IHN0cm9rZS1saW5lam9pbjpyb3VuZDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IGZpbGw6bm9uZSIgLz4NCiAgPGxpbmUgeDE9IjIuMiIgeTE9IjEyLjMiIHgyPSI0LjYiIHkyPSIxOC43IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC44cHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 8pt;
            height: 16pt;
            margin-left: -8pt;
        }

        .r1 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE1IDQwIiBoZWlnaHQ9IjMwcHQiIHdpZHRoPSIxNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMSwyNiAzLDI0IDgsMzggMTQsMCIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjAuNnB0OyBzdHJva2UtbGluZWpvaW46cm91bmQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyBmaWxsOm5vbmUiIC8+DQogIDxsaW5lIHgxPSIzLjIiIHkxPSIyNC40IiB4Mj0iNy42IiB5Mj0iMzcuNiIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjFwdDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IiAvPg0KPC9zdmc+");
            width: 12pt;
            height: 32pt;
            margin-left: -12pt;
        }

        .r2 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDIwIDYwIiBoZWlnaHQ9IjQ1cHQiIHdpZHRoPSIyMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMiwzNyA1LDM0IDExLDU1IDE5LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNS4xIiB5MT0iMzQuNiIgeDI9IjEwLjYiIHkyPSI1NC40IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 16pt;
            height: 48pt;
            margin-left: -16pt;
        }

        .r3 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI1IDgwIiBoZWlnaHQ9IjYwcHQiIHdpZHRoPSIyNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMyw1MCA3LDQ2IDE1LDc0IDI0LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNy4xIiB5MT0iNDYuOCIgeDI9IjE0LjUiIHkyPSI3My4yIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 19pt;
            height: 62pt;
            margin-left: -19pt;
        }

        sup.raised {
            vertical-align: top;
        }

        sup .r0, sup .r1, sup .r2, sup .r3 {
            zoom: 0.7;
            -moz-transform: scale(0.7);
            -webkit-transform: scale(0.7);
            transform: scale(0.7);
            transform-origin: top right;
            max-height: none;
        }

        sup .r0 {
            margin-left: -5pt;
        }

        sup .r1 {
            margin-left: -11pt;
        }

        sup .r2 {
            margin-left: -13pt;
        }

        sup .r3 {
            margin-left: -16pt;
        }

        .b1, .b2, .b3, .c1, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            vertical-align: middle;
            font-weight: 100;
            font-stretch: ultra-condensed;
        }

        .b2, .b3, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            font-family: "Jost* Hairline";
        }

        .b0, .b1, .c1 {
            font-family: "Jost* Thin";
        }

        .b0 {
            font-size: 120%;
        }

        .b1 {
            font-size: 240%;
            margin-top: -3pt;
        }

        .b2 {
            font-size: 370%;
            margin-top: -5pt;
            margin-left: -3pt;
            margin-right: -3pt;
        }

        .b3 {
            font-size: 520%;
            margin-top: -8pt;
            margin-left: -5pt;
            margin-right: -5pt;
        }

        .c1 {
            font-size: 240%;
            margin-top: -4pt;
        }

        .c2 {
            font-size: 360%;
            margin-top: -6pt;
            margin-left: -2.5pt;
            margin-right: -0.5pt;
        }

        .c3 {
            font-size: 480%;
            margin-top: -8pt;
            margin-left: -3pt;
            margin-right: -1pt;
        }

        .c4 {
            font-size: 600%;
            margin-top: -10pt;
            margin-left: -4pt;
            margin-right: -2pt;
            transform: scaleX(0.9);
        }

        .c5 {
            font-size: 710%;
            margin-top: -11.5pt;
            margin-left: -6pt;
            margin-right: -4pt;
            transform: scaleX(0.8);
        }

        .c6 {
            font-size: 820%;
            margin-top: -13pt;
            margin-left: -7pt;
            margin-right: -5pt;
            transform: scaleX(0.7);
        }

        .c7 {
            font-size: 930%;
            margin-top: -14.5pt;
            margin-left: -8pt;
            margin-right: -6pt;
            transform: scaleX(0.6);
        }

        .c8 {
            font-size: 1040%;
            margin-top: -16pt;
            margin-left: -9pt;
            margin-right: -7pt;
            transform: scaleX(0.5);
        }

        table {
            border-collapse: collapse;
        }

            table.bordered {
                margin-top: 1em;
            }

                table.bordered th {
                    background-color: #F0F0F0;
                    border: solid 1pt #AAAAAA;
                }

                table.bordered td {
                    border: solid 1pt #CCCCCC;
                }

            table.centered td, .matrix .td {
                text-align: center;
            }

            table.data td {
                text-align: right;
            }

                table.data td:first-child {
                    text-align: left;
                    padding-left: 0;
                }

        .matrix {
            display: inline-table;
        }

            .matrix .tr {
                display: table-row;
            }

            .matrix .td {
                padding: 0 2pt 0 2pt;
                min-width: 12pt;
                display: table-cell;
            }

                .matrix .td:first-child,
                .matrix .td:last-child {
                    width: 0.75pt;
                    min-width: 0.75pt;
                    max-width: 0.75pt;
                    padding: 0 1pt 0 1pt;
                }

                .matrix .td:first-child {
                    border-left: solid 1.25pt black;
                }

                .matrix .td:last-child {
                    border-right: solid 1.25pt black;
                }

            .matrix .tr:first-child .td:first-child,
            .matrix .tr:first-child .td:last-child {
                border-top: solid 1pt black;
            }

            .matrix .tr:last-child .td:first-child,
            .matrix .tr:last-child .td:last-child {
                border-bottom: solid 1pt black;
            }

        .hl {
            background-color: #FFFAE0;
        }

        .hl1 {
            background-color: #FFF8CF;
            .hl2

        {
            background-color: #FFEFC0;
        }
    </style>
</head>
<body>
    <ul class="menu">
        <li style="font-size:13pt; font-weight:bold; border-bottom: solid 1px gray; padding-bottom:3px; margin-bottom:6px;">目录</li>
        <li><a class="toc" href="#TOC_101">关于Calcpad</a></li>
        <li><a class="toc" href="#TOC_102">应用领域</a></li>
        <li><a class="toc" href="#TOC_103">安装</a></li>
        <li><a class="toc" href="#TOC_104">许可和使用条款</a></li>
        <li><a class="toc" href="#TOC_105">如何运行</a></li>
        <li><a class="toc" href="#TOC_106">理论背景</a></li>
        <li>
            <span class="exp" id="button2">+</span><a class="toc" href="#TOC_200">写计算代码</a><br />
            <ul id="list2">
                <li><a class="toc" href="#TOC_201">数字键盘</a></li>
                <li><a class="toc" href="#TOC_202">在文本中移动</a></li>
                <li><a class="toc" href="#TOC_203">选择</a></li>
                <li><a class="toc" href="#TOC_204">删除</a></li>
                <li><a class="toc" href="#TOC_205">复制</a></li>
                <li><a class="toc" href="#TOC_206">粘贴</a></li>
                <li><a class="toc" href="#TOC_207">撤回</a></li>
                <li><a class="toc" href="#TOC_208">重做</a></li>
                <li><a class="toc" href="#TOC_209">查找</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button3">+</span><a class="toc" href="#TOC_300">编程辅助功能</a><br />
            <ul id="list3">
                <li><a class="toc" href="#TOC_301">语法高亮</a></li>
                <li><a class="toc" href="#TOC_302">自动缩进</a></li>
                <li><a class="toc" href="#TOC_303">自动补全</a></li>
                <li><a class="toc" href="#TOC_304">括号匹配</a></li>
                <li><a class="toc" href="#TOC_305">希腊字母</a></li>
                <li><a class="toc" href="#TOC_306">用Notepad++辅助工作</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button4">+</span><a class="toc" href="#TOC_400">表达式</a><br />
            <ul id="list4">
                <li><a class="toc" href="#TOC_401">常量</a></li>
                <li><a class="toc" href="#TOC_402">变量</a></li>
                <li><a class="toc" href="#TOC_403">运算符</a></li>
                <li><a class="toc" href="#TOC_404">括号</a></li>
                <li><a class="toc" href="#TOC_405">函数</a></li>
                <li><a class="toc" href="#TOC_406">绘图</a></li>
                <li><a class="toc" href="#TOC_407">数值方法</a></li>
                <li><a class="toc" href="#TOC_408">迭代程序</a></li>
                <li><a class="toc" href="#TOC_409">单位</a></li>
                <li><a class="toc" href="#TOC_410">向量</a></li>
                <li><a class="toc" href="#TOC_411">矩阵</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button5">+</span><a class="toc" href="#TOC_500">报告</a><br />
            <ul id="list5">
                <li><a class="toc" href="#TOC_501">标题</a></li>
                <li><a class="toc" href="#TOC_502">文本/注释</a></li>
                <li><a class="toc" href="#TOC_503">注释中的单位</a></li>
                <li><a class="toc" href="#TOC_504">用Html和CSS设置格式</a></li>
                <li><a class="toc" href="#TOC_505">图像</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button6">+</span><a class="toc" href="#TOC_600">编程</a><br />
            <ul id="list6">
                <li><a class="toc" href="#TOC_601">输入表单</a></li>
                <li><a class="toc" href="#TOC_602">输出控制</a></li>
                <li><a class="toc" href="#TOC_603">按条件执行</a></li>
                <li><a class="toc" href="#TOC_604">迭代块</a></li>
                <li><a class="toc" href="#TOC_605">交互式(逐步)执行</a></li>
                <li><a class="toc" href="#TOC_606">子程序(调用)</a></li>
                <li><a class="toc" href="#TOC_607">宏和字符串变量</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button7">+</span><a class="toc" href="#TOC_700">结果</a><br />
            <ul id="list7">
                <li><a class="toc" href="#TOC_701">变量代入</a></li>
                <li><a class="toc" href="#TOC_702">舍入</a></li>
                <li><a class="toc" href="#TOC_703">格式化</a></li>
                <li><a class="toc" href="#TOC_704">缩放</a></li>
                <li><a class="toc" href="#TOC_705">保存</a></li>
                <li><a class="toc" href="#TOC_706">打印</a></li>
                <li><a class="toc" href="#TOC_707">复制</a></li>
                <li><a class="toc" href="#TOC_708">导出到Word</a></li>
                <li><a class="toc" href="#TOC_709">导出到PDF</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button8">+</span><a class="toc" href="#TOC_800">文件</a><br />
            <ul id="list8">
                <li><a class="toc" href="#TOC_801">新建</a></li>
                <li><a class="toc" href="#TOC_802">打开</a></li>
                <li><a class="toc" href="#TOC_803">保存</a></li>
                <li><a class="toc" href="#TOC_804">另存为…</a></li>
            </ul>
        </li>
    </ul>
    <div class="body">
        <ul style="float:right; font-size:9pt; list-style:none;">
            <li><img alt="Logo" src="Images/Logo.png" height="32"><span style="font-size:130%">®</span></li>
            <li>保加利亚,索菲亚1164,34-36 Peyo Yavorov blvd </li>
            <li>+359 2 423 4455</li>
            <li><a href="mailto:proektsoft.bg@gmail.com">proektsoft.bg@gmail.com</a></li>
        </ul>
        <h1><img alt="Calcpad.png" src="Images/Calcpad.png" height="32"> Calcpad</h1>
        <p style="margin-left:42px; margin-top:0;">7.1版自述文件</p>
        <h2 id="TOC_101">关于Calcpad</h2>
        <p>Calcpad是一款用于数学和工程计算的免费软件.它是一个灵活现代的可编程计算器,具有Html报告生成器.它简单易用,但也包含许多高级功能:</p>
        <ul>
            <li>实数和复数;</li>
            <li>度量单位(国际单位制、英制、美制和自定义单位制);</li>
            <li>向量和矩阵:方阵,对称阵,列阵,对角阵,上/下三角阵;</li>
            <li>自定义变量和单位;</li>
            <li>内置常用数学函数库;</li>
            <li>
                向量和矩阵函数: <ul>
                    <li>数据函数: 搜素, 查找, 排序, 计数等.;</li>
                    <li>聚合函数: min, max, sum, sumsq(平方和), srss(平方和的平方根), average(均值), product(积), 几何平均等.;</li>
                    <li>
                        数学函数: norm(范数), condition(条件数), determinant(行列式), rank(秩), trace(迹), transpose(转置), adjugate(伴随矩阵)及 cofactor(协因数矩阵), inverse(逆矩阵),
                        矩阵分解 (Cholesky, ldlt, lu, qr 和 svd), 特征值/特征向量和线性方程组;
                    </li>
                </ul>
            <li>多参数函数f(x; y; z; …);</li>
            <li>强大的数值方法,用于求根和极值、数值积分和微分;</li>
            <li>有限求和、乘积和迭代过程;</li>
            <li>模块、宏和字符串变量;</li>
            <li>带有条件和循环的程序流程控制;</li>
            <li>引号内的“标题”和'文本'注释;</li>
            <li>注释中支持Html和CSS进行丰富格式化;</li>
            <li>函数绘图、图像、表格、参数化SVG绘图等;</li>
            <li>自动生成用于数据输入的Html表单;</li>
            <li>专业外观的Html报告,用于查看和打印;</li>
            <li>导出为Word(*.docx)和PDF文档;</li>
            <li>变量替换和智能舍入数字;</li>
            <li>输出可见性控制和内容折叠;</li>
            <li>支持纯文本(*.txt,*.cpd)和二进制(*.cpdz)文件格式.</li>
        </ul>
        <p>该软件使用C#编程语言和最新的计算机技术开发.它会自动解析输入,替换变量,计算表达式并显示输出.所有结果都会发送到外观专业的Html报告中,供查看和打印.</p>
        <p style="text-align:center;"><img alt="Calcpad" src="Images/Sample.zh.png" width="650"></p>

        <h2 id="TOC_102">应用领域</h2>
        <p>这个软件适用于需要执行重复计算并将其呈现在官方文档(如计算说明)中的工程师和其他专业人士.他们可以通过创建强大可靠的Calcpad工作表来高效地自动化这项任务.它还可以帮助教师准备计算示例、论文、手册、书籍等等.学生可以使用它来解决各种问题、准备家庭作业、学位论文等.</p>

        <h2 id="TOC_103">安装</h2>
        <p>安装由自动化安装程序<a target="_blank" href="https://calcpad.eu/download/calcpad-setup-en-x64.zip">calcpad-setup-en-x64.exe</a>执行.按照安装向导的说明进行操作.该软件需要一台64位计算机,安装有Windows 10和<a target="_blank" href="https://dotnet.microsoft.com/en-us/download/dotnet/8.0">Microsoft .NET 8.0</a>.</p>

        <h2 id="TOC_104">许可和使用条款</h2>
        <p>这个软件对商业和非商业用途均免费.它是根据MIT许可证分发的:</p>
        <p>版权所有 © 2021 PROEKTSOFT EOOD®</p><hr />
        <p>特此授予任何获得本软件及相关文档文件(“软件”)副本的人免费使用本软件的权限,包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或销售本软件的副本,以及允许使用本软件的人这样做,但须遵守以下条件:</p>
        <p>上述版权声明和本许可声明应包含在所有副本或实质部分的软件中.</p>
        <p>本软件按“原样”提供,不附带任何形式的明示或暗示担保,包括但不限于适销性、特定用途适用性和非侵权性的担保.在任何情况下,作者或版权持有人均不对任何索赔、损害或其他责任承担责任,无论是在合同、侵权或其他方面,由于软件或使用或其他交易引起的或与之相关的软件而导致的,包括但不限于使用或其他交易的任何损失或利润损失.</p><hr />
        <p>源代码托管在GitHub上:</p>
        <p><a title="GitHub repository" href="https://github.com/Proektsoftbg/Calcpad">https://github.com/Proektsoftbg/Calcpad</a></p>
        <p>或在我们的SourceForge仓库:</p>
        <p><a title="SourceForge repository" href="https://sourceforge.net/p/calyx/code/ci/master/tree/">https://sourceforge.net/p/calyx/code/ci/master/tree/</a></p>
        <p>Calcpad开发的任何脚本均为各自作者的财产.除了作者本身指定的限制外,可以无限制地使用.</p>
        <h3>致谢</h3>
        <p>该项目使用了一些额外的第三方组件、软件和设计.它们在各自作者提供的许可条件下免费重新分发.</p>
        <p>1. 本项目使用<a target="_blank" href="https://icons8.com">icons8.com</a>创建了新的漂亮图标.</p>
        <p>2. 感谢<a target="_blank" href="https://wkhtmltopdf.org/">wkhtmltopdf.org</a>项目,赋予了该软件PDF导出功能.</p>
        <p>3. 本项目使用<a href="https://indestructibletype.com/">indestructible type*</a>开发的Jost*字体系列,根据<a href="https://scripts.sil.org/cms/scripts/page.php?item_id=OFL_web">SIL开源字体许可证</a>进行了分发.方括号稍作修改以适应本应用程序的需求.</p>

        <h2 id="TOC_105">工作原理</h2>
        <p>该软件快速且易于使用.只需按照以下简单步骤操作:</p>
        <ol>
            <li>在左边的"<strong>Code(代码)</strong>"窗口中<strong>输入</strong> 文本和表达式 "<strong>Code</strong>" .</li>
            <li>按<b>F5</b>或点击<img alt="Play" height="24" src="Images/Play.png"> 启动计算.结果将以专业排版的Html<b>报告</b>显示在右侧的"<b>Output(输出)</b>" 窗口中.</li>
            <li>点击 <img alt="PrintPreview" height="24" src="Images/PrintPreview.png"><b>打印</b>或<img alt="Copy" height="24" src="Images/Copy.png"> <b>复制</b>输出.<br />或将输出<b>导出</b>到<b>Html</b> <img alt="Html" height="24" src="Images/Save.png">, <b>PDF</b> <img alt="PDF" height="24" src="Images/Pdf.png">或<b>MS Word</b> <img alt="Word" height="24" src="Images/Word.png"> 文档中.</li>
        </ol>
        <p>该程序可以在两种不同的模式下使用:</p>
        <ul>
            <li><b>计算器</b> - 源代码可在左侧框中进行编辑.计算完成后,结果将显示在右侧框中.该模式适用于简短且简单的问题,不涉及复杂的格式.</li>
            <li><b>输入表单</b> - 源代码不可访问.相反,显示一个HTML输入表单.它包含了所有参数的输入字段,这些参数是计算所需的.其余内容被锁定不可编辑.这种模式更适用于需要丰富格式的复杂问题,并且经常使用.它清楚地显示了所需的输入参数,并保护源代码免受意外损坏.</li>
        </ul>
        <p>在"<b>输入表单</b>"模式下,您需要填写输入数据并点击<img alt="Play" height="24" src="Images/Play.png">按钮.您可以非常简便地直接通过源代码创建这样一个表单.只需在需要输入值的地方放置"<b>?{}</b>"符号.然后将问题文本保存为"*.cpd"文件.您可以在本手册的后面找到有关表单的更多信息.</p>

        <h2 id="TOC_106">理论基础</h2>
        <p style="font-style: italic;">(若觉无趣可直接跳过)</p>
        <p>Calcpad是如何工作的？它内部包含一个复杂的数学解析器,它完成了大部分的工作.首先,源代码会被扫描,使用词法分析将字节序列转换成令牌列表.每个令牌都由数据和类型(目的、角色)表示.</p>
        <p>
            然后解析器会检查所有令牌是否按照正确的顺序排列.我们需要知道表达式是否在数学上是正确的并且可以计算.否则,应该生成一个易于理解的错误消息.例如,"3 + a / 5" 是一个正确的表达式,而 "3 a + / 5"不是.为了实现这个目的,标准的数学表示法被表示为具有上下文无关文法的形式语言,并使用语法分析.
            .
        </p>
        <p>
            算术表达式通常以中缀表示法编写.这意味着每个运算符位于相应的操作数之间(例如 "5*3 + 2").问题在于,与人类不同,计算机很难理解这种表示法.主要问题是运算符的优先级和括号的使用.例如,上述表达式得出的结果是"17",而 "5*(3 + 2)" 得出的结果是"25".因此,表达式会被转换为不同类型的表示法,称为"后缀"或逆波兰表示法(RPN).对计算机来说,读取这种表示法非常容易.例如,表达式 "5*(3 + 2)" 在RPN中写作 "5 3 2 + *".其主要优势是可以明确指定操作的顺序,而无需使用括号.
        </p>
        <p>对于计算逆波兰表示法(RPN)的表达式,有一个简单而强大的算法.几乎所有的计算器都使用这种算法.然而,Calcpad还包括额外的功能,用于处理参数、函数、宏、条件执行、循环等.</p>
        <p>这是一份简短说明.若对该话题感兴趣,可以从专门的书籍、文章或网站中找到更多信息.推荐维基百科:
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Parsing">https://en.wikipedia.org/wiki/Parsing</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Context-free_grammar">https://en.wikipedia.org/wiki/Context-free_grammar</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">https://en.wikipedia.org/wiki/Shunting-yard_algorithm</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">https://en.wikipedia.org/wiki/Reverse_Polish_notation</a></p>

        <h2 id="TOC_200">编写代码</h2>
        <p>将代码输入到“<b>代码</b>”输入窗口中.空格和缩进会自动保持.您可以使用计算机键盘或下面的“<b>数字键盘</b>”.您可以从输入窗口或任何外部程序(例如<b>Word</b>)复制文本.输入窗口上方有一个工具栏,其中包含一些有用的编辑命令:复制、粘贴、撤消、重做和插入图像.</p>
        <p>源代码在逻辑上分为多行,自动编号.每个表达式应该在单独的一行上.特殊情况下,可以在同一行上有多个表达式,但它们必须用注释分隔开.当您完成一行时,按下“<b>Enter</b>”开始新的一行.语法高亮会自动执行.不同的代码元素以不同的颜色显示,具体取决于其类型.例如,注释以绿色显示,错误以红色显示.所有注释必须用引号括起来.它们可以包含普通文本和<b>Html</b>.您可以使用Html添加图片、表格和格式化报告.</p>

        <h3 id="TOC_201">数字键盘</h3>
        <p><img alt="Keyboard" height="180" src="Images/Keyboard.zh.png"></p>
        <p>当您使用平板电脑或带有触摸屏的笔记本电脑时,数字键盘非常有用.按下按钮时,相应的符号将插入到光标所在的位置.数字键盘分为四个部分:“<b>数字</b>”、“<b>运算符</b>”、“<b>函数</b>”和“<b>其他</b>”."<b>=</b>"键不像简单计算器那样计算答案.这是赋值运算符(例如,“<var>a</var> = 4”).如果您需要检查两个数字的相等性,请使用“<b>≡</b>”运算符(例如,“<var>a</var> ≡ <var>b</var>”表示:“<var>a</var>是否等于<var>b</var>？”)."<b>e</b>"、"<b>π</b>"和"<b>g</b>"键插入相应的内置常数<var>e</var> ≈ 2.7183、<var>π</var> ≈ 3.1416和<var>g</var> ≈ 9.8066.</p>
        <p>如果您不需要数字键盘并想释放一些空间,可以使用<img alt="Calc" height="24" src="Images/Calc.png">按钮隐藏它.再次点击可以显示数字键盘.</p>
        <p>“<b style="color:red">C</b>”按钮删除上一个符号,“<b style="color:red">AC</b>”删除整行.如果您双击此按钮,将清除整个文本.如果您不小心这样做了,可以使用<b>撤消</b> <img alt="Undo" height="24" src="Images/Undo.png">来恢复.</p>

        <h3 id="TOC_202">在文本中移动</h3>
        <p>在Calcpad中编写和编辑文本与任何其他Windows程序没有太大区别.如果您有一些经验,可以跳过这一部分,直接进入“<b>表达式</b>”.</p>
        <p>您可以在文本的任意位置输入.插入符号的位置称为“<b>文本光标</b>”(闪烁的垂直线“<b>|</b>”).您可以通过单击鼠标或使用键盘上的箭头“← → ↑ ↓”来更改光标位置.箭头将使光标向左或向右移动一个符号,并向上或向下移动一行.如果按住“<b>Ctrl</b>”键并按箭头键,光标将移动一个完整的单词.按下“<b>Home</b>”和“<b>End</b>”键将分别将光标发送到当前行的开头或结尾.如果事先按住“<b>Ctrl</b>”键,您将转到整个文本的开头或结尾.</p>

        <h3 id="TOC_203">选择文本</h3>
        <p>大多数编辑命令要求您选择要应用命令的一些文本.所选择的文本通常显示为<span style="background-color:LightSkyBlue;">蓝色背景</span>(根据您的系统设置可能会有所不同).您可以按照以下方式使用鼠标选择文本:在要选择的文本的起始位置按下左鼠标按钮.按住按钮并将鼠标移动到结束位置.然后释放按钮.或者,您可以在起始位置单击,按下<b>Shift</b>,然后在结束位置单击.您还可以使用计算机键盘.按住<b>Shift</b>并按箭头键或“<b>Home</b>”、“<b>End</b>”、“<b>Page Up</b>”、“<b>Page Down</b>”.</p>

        <h3 id="TOC_204">删除文本</h3>
        <p>您可以通过按下“<b>Delete</b>”(“Del”)或“<b>Backspace</b>”(“Bkspc”)键来删除单个符号.区别在于,“Delete”删除光标后的符号,“Backspace”删除光标前的符号.如果事先按住“<b>Ctrl</b>”键,您可以删除整个单词而不是单个符号.如果您需要删除文本的较大部分,可以选择它,然后按“Delete”或“Backspace”.</p>

        <h3 id="TOC_205">复制</h3>
        <p>如果文本的某个部分重复出现,您可以将其复制而不是再次输入.这需要两个步骤:"复制"和"粘贴".在第一步(复制)中,所选文本被发送到称为<b>剪贴板</b>的内存中.在第二步(粘贴)中,文本被插入到新位置.一旦复制,您可以将文本粘贴到多个位置.您可以通过按"<b>Ctrl+C</b>"或点击<img alt="Copy" height="24" src="Images/Copy.png">按钮将所选文本复制到剪贴板中.</p>

        <h3 id="TOC_206">粘贴</h3>
        <p>在从剪贴板中粘贴文本之前,您必须将光标定位到所需位置.然后按"<b>Ctrl+V</b>"或<img alt="Paste" height="24" src="Images/Paste.png">按钮.您可以将文本从Calcpad复制并粘贴到其他程序中,反之亦然.例如,您可以从Word中获取一些公式,在Calcpad中计算它们,然后将结果返回到Word中.</p>

        <h3 id="TOC_207">撤销</h3>
        <p>此命令撤消上一个编辑命令的结果并恢复先前的状态.您可以撤消多达10个步骤.只需按"<b>Ctrl+Z</b>"或单击<img alt="Undo" height="24" src="Images/Undo.png">按钮即可.</p>

        <h3 id="TOC_208">重做</h3>
        <p>"重做"(Redo)与"撤销"(Undo)的方式相反.它恢复了被撤销的命令.重做必须紧随上一个撤销.如果您在此期间输入或编辑一些文本,您将失去重做的能力.点击<img alt="Redo" height="24" src="Images/Redo.png">按钮进行重做.</p>

        <h3 id="TOC_209">查找</h3>
        <p>如果需要,您可以在代码中搜索某个特定文本并将其替换为另一个文本.选择"<b>编辑/查找</b>"菜单,点击<img alt="Find" height="24" src="Images/Search.png">按钮或按"<b>Ctrl+F</b>"键.将会出现"<b>查找和替换</b>"对话框.</p>
        <p><img alt="Find Dialog" width="450" src="Images/FindDialog.zh.png"></p>
        <p>输入要搜索的单词或短语,然后点击"<b>查找下一个</b>".程序从当前位置开始,在所选方向中查找第一次出现的搜索短语.如果找到了搜索短语,它会被突出显示,搜索就会停止.要查找下一个出现,再次点击"<b>查找下一个</b>".您还可以按"<b>F3</b>"键,即使在关闭对话框后也可以继续搜索.</p>
        <p>如果需要替换搜索到的文本,点击"<b>替换</b>"选项卡并填写"<b>替换为</b>"框中的内容,然后点击"<b>替换</b>"按钮.程序将替换当前出现的文本,并自动移动到下一个.如果您想替换代码中的所有出现,只需点击相应的按钮即可. </p>
        <p>有几个选项会影响搜索结果,如下所示:</p>
        <ul>
            <li><b>搜索方向</b>: "向上"、"向下"和"全部"."全部"和"向下"都是朝着文档的末尾搜索.不同之处在于,"全部"在到达文档末尾后会跳到开头重新开始搜索.</li>
            <li><b>选择</b>:它仅适用于"<b>全部替换</b>"命令.您需要先进行选择,然后显示"<b>查找和替换</b>"对话框.然后,如果选中"<b>选择</b>"选项,所有的替换都将仅在所选文本中进行.</li>
            <li><b>大小写</b>:如果选中,搜索将区分大小写.默认情况下,大小写被忽略.</li>
            <li><b>全字匹配</b>:如果选中,程序将仅搜索代表整个单词的序列.</li>
        </ul>

        <h2 id="TOC_300">编码辅助功能</h2>
        <h3 id="TOC_301">语法高亮</h3>
        <p>语法高亮将不同的颜色应用于编程语言的不同组成部分:函数、变量、运算符等.它会在您每次编辑并离开当前行时自动运行.所有错误都将以红色突出显示.程序区分已定义和未定义的变量和函数.颜色调色板是预定义的,无法更改.目前,Calcpad不支持自定义样式和主题.</p>

        <h3 id="TOC_302">自动缩进</h3>
        <p>程序会自动维护代码中各行的缩进.所有在条件和循环块内的行都会相应地缩进.此外,您可以在每行开头添加空格.虽然间距也是自动处理的,但前导空格不受影响.</p>

        <h3 id="TOC_303">自动补全</h3>
        <p>当您开始输入时,程序会显示一个下拉列表,其中包含与您刚刚输入的内容匹配的建议.它包含关键字、测量单位、内置函数和所有在当前行上面定义的自定义变量和函数.列表在您输入时动态过滤和排序.列表中的当前建议会被突出显示.如果这就是您需要的,请按“<b>Tab</b>”将其插入到当前位置.单击列表以插入其他建议中的一些.或者,您可以按“<b>向下箭头</b>”浏览可用的建议,按“<b>Enter</b>”插入所选的建议.如果列表在当前行上方,请改为按“<b>向上箭头</b>”.</p>

        <h3 id="TOC_304">括号匹配</h3>
        <p>程序可以找到匹配的开放和关闭括号.如果将光标放置在其中一个括号旁边,两个括号都会突出显示.如果没有相应的括号,则不会突出显示任何内容.</p>

        <h3 id="TOC_305">希腊字母</h3>
        <p>您可以通过点击代码编辑器下方的相应符号来插入希腊字母.或者,您可以从下面的表格中输入相应的拉丁字母,然后按"<b>Ctrl+G</b>".如果再次按下该键,您将把字母从希腊转换回拉丁.由于"j"/"J"和"V"保持未使用状态,它们分别映射为"ø"/"Ø"和"&measuredangle;".</p>
        <table class="bordered">
            <tr><th>名称		</th><th>希腊字母</th><th>拉丁字母</th><th>希腊字母</th><th>拉丁字母</th>
            <tr><td>alpha西格玛		</td><td>α</td><td>a</td><td>Α</td><td>A</td></tr>
            <tr><td>beta贝塔		</td><td>β</td><td>b</td><td>Β</td><td>B</td></tr>
            <tr><td>gamma伽马		</td><td>γ</td><td>g</td><td>Γ</td><td>G</td></tr>
            <tr><td>delta德尔塔		</td><td>δ</td><td>d</td><td>Δ</td><td>D</td></tr>
            <tr><td>epsilon伊普西隆		</td><td>ε</td><td>e</td><td>Ε</td><td>E</td></tr>
            <tr><td>zeta泽塔		</td><td>ζ</td><td>z</td><td>Ζ</td><td>Z</td></tr>
            <tr><td>eta伊塔			</td><td>η</td><td>h</td><td>Η</td><td>H</td></tr>
            <tr><td>theta西塔		</td><td>θ</td><td>q</td><td>Θ</td><td>Q</td></tr>
            <tr><td>theta-alt	</td><td>ϑ</td><td>v</td><td>&measuredangle;</td><td>V</td></tr>
            <tr><td>iota		</td><td>ι</td><td>i</td><td>Ι</td><td>I</td></tr>
            <tr><td>kappa		</td><td>κ</td><td>k</td><td>Κ</td><td>K</td></tr>
            <tr><td>lambda拉姆达		</td><td>λ</td><td>l</td><td>Λ</td><td>L</td></tr>
            <tr><td>mu缪			</td><td>μ</td><td>m</td><td>Μ</td><td>M</td></tr>
            <tr><td>nu			</td><td>ν</td><td>n</td><td>Ν</td><td>N</td></tr>
            <tr><td>xi			</td><td>ξ</td><td>x</td><td>Ξ</td><td>X</td></tr>
            <tr><td>omicron		</td><td>ο</td><td>o</td><td>Ο</td><td>O</td></tr>
            <tr><td>pi			</td><td>π</td><td>p</td><td>Π</td><td>P</td></tr>
            <tr><td>rho			</td><td>ρ</td><td>r</td><td>Ρ</td><td>R</td></tr>
            <tr><td>sigma		</td><td>σ</td><td>s</td><td>Σ</td><td>S</td></tr>
            <tr><td>tau			</td><td>τ</td><td>t</td><td>Τ</td><td>T</td></tr>
            <tr><td>upsilon		</td><td>υ</td><td>u</td><td>Υ</td><td>U</td></tr>
            <tr><td>phi			</td><td>φ</td><td>f</td><td>Φ</td><td>F</td></tr>
            <tr><td>chi			</td><td>χ</td><td>c</td><td>Χ</td><td>C</td></tr>
            <tr><td>psi			</td><td>ψ</td><td>y</td><td>Ψ</td><td>Y</td></tr>
            <tr><td>omega欧米伽		</td><td>ω</td><td>w</td><td>Ω</td><td>W</td></tr>
            <tr><td>phi-diam	</td><td>ø</td><td>j</td><td>Ø</td><td>J</td></tr>
        </table>

        <h3 id="TOC_306">使用Notepad++</h3>
        <p><b>Notepad++</b>是一款流行的文本/代码编辑器.它是免费且开源的,可以从官方网站<a href="https://notepad-plus-plus.org" target="_blank">https://notepad-plus-plus.org</a>下载.它支持许多编程或脚本语言.它的文本编辑功能比Calcpad更强大.它还非常适用于编写HTML代码.您也可以在Notepad++中使用<b>Calcpad</b>语法.它被预定义为一个XML文件,可以插入到Notepad++中.您可以通过选择"<b>语言</b>"菜单,然后点击"<b>定义您的语言</b>",然后"<b>导入...</b>"来实现.在您的<b>Program Files</b>目录或Calcpad安装目录中找到<b>Calcpad</b>文件夹,然后选择名为<a href="https://calcpad.eu/download/Notepadpp.zip" target="_blank">Calcpad-syntax-for-Notepad++.xml</a>的文件.</p>

        <h2 id="TOC_400">表达式</h2>
        <p>Calcpad的主要目的是进行计算.因此,除非用引号括起来,否则输入窗口中的所有内容都被视为数学表达式.如果用引号括起来,则被视为注释.默认情况下,每个表达式必须在单独的一行中,例如:</p>
        <ul style="list-style: none;">
            <li><code>2 + 3</code></li>
            <li><code>5*(3+1)</code></li>
            <li><code>15/2</code></li>
        </ul>
        <p>您不应在每个表达式的末尾添加"=".这是赋值运算符,用于将值赋给变量,例如"<var>a</var> = 2".点击<img alt="Play" height="24" src="Images/Play.png">按钮,在输出窗口中查看结果:</p>
        <ul style="list-style: none;">
            <li><code>2 + 3 = 5</code></li>
            <li><code>5∙(3 + 1) = 20</code></li>
            <li><code>15/2 = 7.5</code></li>
        </ul>
        <p>或者,您可以在一行中有多个表达式,但它们必须用注释分隔,例如:</p>
        <p style="margin-left: 2em;"><code><span class="comment">'长度 -'</span><var>a</var> = 3&thinsp;<i>m</i><span class="comment">', 宽度 -'</span><var>b</var> = 2*<var>a</var><span class="comment">', 高度 -'</span><var>c</var> = 5&thinsp;<i>m</i></code></p>
        <p>每个表达式可以包括常数(数字)、变量、运算符、函数和括号.它们必须正确排列以表示有效的表达式.使用通常接受的数学符号和运算符优先级,与学校教学的方式相同.下面详细描述了表达式组成部分.</p>
        <p>您可以像使用简单计算器一样计算单独的不相关表达式,或编写一个完整的程序来解决特定的问题.您可以定义变量并给它们赋值.此外,您可以使用它们来定义其他变量,依此类推,直到达到最终结果.您还可以添加文本、HTML和图像以创建详细且专业的计算报告.您可以将其保存到文件中,并多次使用它来解决类似的问题.下面是一个解二次方程的示例程序:</p>
        <p><img alt="Sample1" src="Images/Sample1.zh.png"></p>

        <h3 id="TOC_401">常数</h3>
        <h4>实数</h4>
        <p>实数常数可以是正负整数和小数.它们可以包括数字“<b>0</b>” - “<b>9</b>”和小数点“<b>.</b>”.您还可以将数字表示为分数,如“<b>3/4</b>”.但是,程序将将它们视为表达式(两个数字的除法).您不能以浮点格式定义数字:“<b>3.4e+6</b>”.您必须使用表达式“<b>3.4*10^6</b>”代替.</p>
        <p>所有常数和变量在内部以“双精度浮点”数字的形式存储.它们的值范围从<b>-1.7976931348623157E+308</b>到<b>1.7976931348623157E+308</b>.如果结果超出上述区间,程序将分别返回“<span class="err">-∞</span>”或“<span class="err">+∞</span>”.除以零会得到相同的结果,但“<b>0/0</b>”=“<span class="err">未定义</span>”.最小的正数是<b>4.94065645841247E-324</b>.更小的值将被精确地四舍五入为0.</p>
        <h4>复数</h4>
        <p>如果选择“<b>复数</b>”模式,您可以在计算中使用复数.否则,仅应用实数运算.每个复数由有序对(<b>a</b>;<b>b</b>)表示,其中“<b>a</b>”是实数,“<b>b</b> = |<b>b</b>|<b><var>i</var></b>”被称为“虚数”.它可以用所谓的代数形式表示:&plusmn;<b>a</b> &plusmn; <b>b<var>i</var></b>(例如“2 + 3<var>i</var>”).您还可以使用其他形式,如极坐标或指数形式,通过输入相应的表达式.在Calcpad中,虚数单位可以输入为“<var>i</var>”或“1<var>i</var>”(如果您有一个名为“<var>i</var>”的变量).虚数单位是满足表达式<var>i</var><sup> 2</sup> = -1的特殊数字.</p>

        <h3 id="TOC_402">变量</h3>
        <p>变量通过表达式“<var>a</var> = 4”来定义其名称和值.符号“<b>=</b>”是赋值运算符.左边只允许一个变量名.右边可以是任何有效的数学表达式,例如“<var>b</var> = <var>a</var> + 4”.变量的“生命周期”从其定义的位置到程序的结束.因此,在定义之前不能使用变量.这将引发错误.如果您用新值重新定义现有变量,它将替换旧变量,并且新值将继续使用.</p>
        <p>变量名称可以包含小写或大写的拉丁字母“<var>a</var>”-“<var>z</var>”,“<var>A</var>”-“<var>Z</var>”,希腊字母“<var>&alpha;</var>”-“<var>&omega;</var>”,“<var>&Alpha;</var>”-“<var>&Omega;</var>”和数字.名称区分大小写.例如,“<var>a</var>”和“<var>A</var>”是不同的变量.名称必须以字母或&measuredangle;开头.您还可以使用“,”(逗号)、“<b>‾</b>”(上划线)、“<b>_</b>”(下划线)、上标:“ <b>⁰</b> ”-“ <b>⁹</b> ”、“ <b>ⁿ</b> ”、“ <b>⁺</b> ”、“ <b>⁻</b> ”和其他符号:“ <b>′</b> ”、“ <b>″</b> ”、“ <b>‴</b> ”、“ <b>⁗</b> ”、“ <b>ø</b> ”、“<b>Ø</b>”、“ <b>°</b> ”、“<b>∡</b>”.名称中下划线的第一次出现会开始一个下标.例如,“a_1_1”将显示为“<var>a</var><sub>1_1</sub>”.变量可以存储实数或复数(在“复数”模式下).</p>

        <h3 id="TOC_403">运算符</h3>
        <p>Calcpad语言支持下列运算:</p>
        <ul>
            <li>
                算术:
                <ul style="list-style-type:none;">
                    <li>"<b>!</b>" - 级数;</li>
                    <li>"<b>^</b>" - 指数;</li>
                    <li>"<b>/</b>" - 浮点除法;</li>
                    <li>"<b>\</b>" - 整除; </li>
                    <li>"<b>÷</b>" - division bar; </li>
                    <li>"<b style="font-size:80%;">⦼</b>" - 求模 (%%, 求余);</li>
                    <li>"<b>*</b>" - 乘法;</li>
                    <li>"<b>-</b>" - 减法; </li>
                    <li>"<b>+</b>" - 加法; </li>
                </ul>
            </li>
            <li>
                关系(比较):
                <ul style="list-style-type:none;">
                    <li>"<b>≡</b>" - 等于(==);</li>
                    <li>"<b>≠</b>" - 不等于(!=);</li>
                    <li>"<b>&lt;</b>" - 小于(&lt;);</li>
                    <li>"<b>&gt;</b>" - 大于(&gt;);</li>
                    <li>"<b>&le;</b>" - 小于等于(&lt;=);</li>
                    <li>"<b>&ge;</b>" - 大于等于(&gt;=);</li>
                </ul>
            </li>
            <li>
                逻辑值:
                <ul style="list-style-type:none;">
                    <li>"<b>∧</b>" - 逻辑值 "且";</li>
                    <li>"<b>∨</b>" - 逻辑值 "或";</li>
                    <li>"<b style="font-size:80%;">⊕</b>" - 逻辑值 “异或”;</li>
                </ul>
            </li>
            <li>"<b>=</b>" - 赋值.</li>
        </ul>

        <h4>运算符快捷方式</h4>
        <p>您可以使用相应的C风格等效运算符来替代"≡"、"≠"、"&le;"和"&ge;",如下所示:"=="、"!="、"&lt;="和"&gt;=".它们将自动替换为相应的Calcpad运算符.快捷方式“%%”将转换为模运算符“⦼”.这是必要的,因为“%”被保留用于百分比单位.由于这个符号不太常见,它在输出中被呈现为“mod”,例如“7 mod 5 = 2”,而不是“7 ⦼ 5 = 2”.</p>

        <h4>运算符优先级和结合性</h4>
        <p>上述运算符按照它们的优先级顺序列出.这是它们在表达式中将被评估的顺序.当在一个表达式中有不同类型的运算符时,指数运算先进行评估,然后是除法和乘法,减法和加法,最后是比较运算.当我们有一个一元负号和指数运算时,指数运算先进行评估.例如:“-2^2 = -(2^2) = -4” 所有关系运算符的优先级相同.如果您需要改变评估的顺序,可以使用括号.例如,“5 + 2∙3”得到“11”.如果要先进行加法,写成“(5 + 2)∙3”.您将得到“7∙3 = 21”.优先级相同的运算符从左到右进行评估.这被称为运算符的结合性.例如,“3 - 2 + 1”得到“(3 - 2) + 1 = 2”而不是“3 - (2 + 1) = 0”.另一个很好的例子是“2∙3 / 2∙3”,得到“9”而不是“1”.</p>
        <p>在Calcpad中,所有运算符都是左结合的(计算从左到右进行).唯一的例外是指数运算,它是右结合的.它是从右到左进行计算的,这意味着<var>x</var>^<var>a</var>^<var>b</var>将被评估为<var>x</var><sup>a<sup>b</sup></sup>.然而,许多手持计算器和电子表格软件(如Excel)使用左结合性进行指数运算.在这种情况下,<var>x</var>^<var>a</var>^<var>b</var>将被评估为<var>x</var><sup>a&middot;b</sup>.如果您需要得到<var>x</var><sup>a<sup>b</sup></sup>,您将需要添加括号:<var>x</var>^(<var>a</var>^<var>b</var>).</p>

        <h4>关系表达式</h4>
        <p>关系运算符只能返回两个值:“<b>1</b>”表示“<b>true</b>”,“<b>0</b>”表示“<b>false</b>”.您可以与算术运算符一起在表达式中使用它们.例如,您可以通过表达式“<var>a</var>*(<var>a</var> &ge; <var>b</var>) + <var>b</var>*(<var>a</var> &lt; <var>b</var>)”获得两个数<var>a</var>和<var>b</var>中的较大值.但是您需要小心.如果您使用“<b>&le;</b>”而不是“<b>&lt;</b>”,对于<var>a</var>等于<var>b</var>的情况,您将得到<var>a</var> + <var>b</var>,这可能不是您想要的结果.为了这个特殊目的,最好使用内置函数<b>max</b>(<var>a</var>; <var>b</var>)、逻辑运算符或条件执行(请查看本手册后面的内容).算术运算符的优先级高于关系运算符,两者在逻辑运算符之前进行评估.</p>


        <h4>逻辑表达式</h4>
        <p>Calcpad仅处理数值数据,并没有专门的布尔数据类型.与关系运算符类似,逻辑运算符也使用"<b>1</b>"表示"<b>true(真)</b>",使用"<b>0</b>"表示"<b>false(假)</b>".任何非0的输入值也被视为"<b>true</b>".您可以通过使用逻辑运算符和/或逻辑函数(请参阅本手册后面的内容)来构建逻辑表达式.它们的工作原理如下:</p>
        <ul style="list-style-type:none;">
            <li>"∧"(and)如果两个操作数都为1,则返回1,否则返回0;</li>
            <li>"∨"(or)如果任何一个操作数为1,则返回1,如果两个操作数都为0,则返回0;</li>
            <li>"⊕"(xor)如果只有一个操作数为1,则返回1,否则返回0.</li>
        </ul>
        <p>上述运算符的结果如下表所示:</p>
        <table width="100%">
            <tr>
                <td style="border:none;">
                    <p><b>且</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x∧y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>0</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>或</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x∨y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>异或</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x<span style="font-size:80%">⊕</span>y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>0</td></tr>
                    </table>
                </td>
            </tr>
        </table>

        <h4>复数代数</h4>
        <p>除了阶乘"<b>!</b>"、整数除法"<b>\</b>"、求余"<b>⦼</b>"和比较运算符"<b>&lt;</b>"、"<b>&le;</b>"、"<b>&gt;</b>"、"<b>&ge;</b>"之外,所有运算符都支持复数.复杂表达式的求值比实数稍微复杂一些.基本复数运算的规则如下:</p>
        <ul>
            <li>加法: <code>(a + b<var>i</var>) + (c + d<var>i</var>) = (a + c) + (b + d)<var>i</var></code>;</li>
            <li>减法: <code>(a + b<var>i</var>) &minus; (c + d<var>i</var>) = (a &minus; c) + (b &minus; d)<var>i</var></code>;</li>
            <li>乘法: <code>(a + b<var>i</var>)&middot;(c + d<var>i</var>) = (ac &minus; bd) + (bc + ad)<var>i</var></code>;</li>
            <li>除法: <code>(a + b<var>i</var>)/(c + d<var>i</var>) = (ac + bd)/(c<sup>2</sup> + d<sup>2</sup>) + (bc &minus; ad)/(c<sup>2</sup> + d<sup>2</sup>)<var>i</var></code>;</li>
        </ul>

        <h3 id="TOC_404">括号</h3>
        <p>括号有两种用途:改变计算顺序和括住函数参数.只允许使用圆括号:" <b>(</b>" 和 "<b>)</b>".软件会检查每个表达式是否满足以下规则:</p>
        <ul>
            <li>表达式中的第一个括号必须是左括号;</li>
            <li>左括号和右括号的数量必须相等;</li>
            <li>左括号之前只允许使用运算符或函数标识符;</li>
            <li>在运算符或函数标识符之后不允许使用右括号;</li>
            <li>函数标识符后必须始终跟随左括号.</li>
        </ul>
        <p>在渲染输出时,Calcpad使用"智能"括号插入.这意味着重复或不影响计算顺序的括号将从输出中省略.另一方面,在输入中不需要的情况下,会添加括号以增加清晰度.这通常发生在替换负数或复数变量时.例如:</p>
        <ul>
            <li>如果<var>a</var> = -2,则<var>a</var><sup>2</sup> = (-2)<sup>2</sup> = 4,而不是<var>a</var><sup>2</sup> = -2<sup>2</sup>.第二种情况是不明确的,符号可以应用于指数运算,结果为-4.此外,对复数变量的指数运算添加了括号;</li>
            <li>如果<var>a</var> = -2,则<var>b</var> = -<var>a</var> = -(-2) = 2,而不是<var>b</var> = -<var>a</var> = --2 = 2;</li>
            <li>在乘法和除法中,对负变量添加括号:<var>a</var>&middot;<var>b</var> = -2&middot;(-3) = 6;</li>
            <li>几乎每次我们需要替换复数变量时都需要添加括号:<var>a</var>&middot;<var>b</var> = (2 + 3<var>i</var>)&middot;(3 - 2<var>i</var>) = 12 + 5<var>i</var>.</li>
        </ul>

        <h3 id="TOC_405">函数</h3>
        <h4>库(内置)函数</h4>
        <p>Calcpad包含一个常用数学函数库,可以直接使用:</p>
        <ul>
            <li>
                三角函数:<ul style="list-style-type:none;">
                    <li><code><b>sin</b>(<var>x</var>)</code> - 正弦;</li>
                    <li><code><b>cos</b>(<var>x</var>)</code> - 余弦;</li>
                    <li><code><b>tan</b>(<var>x</var>)</code> - 正切 = <code><b>sin</b>(<var>x</var>)/<b>cos</b>(<var>x</var>)</code>, for each <var>x</var> ≠ kπ, k=1, 2, 3…;</li>
                    <li><code><b>csc</b>(<var>x</var>)</code> - 余割 = <code>1/<b>sin</b>(<var>x</var>)</code>, for each <var>x</var> ≠ kπ, k=1, 2, 3…;</li>
                    <li><code><b>sec</b>(<var>x</var>)</code> - 正割 = <code>1/<b>cos</b>(<var>x</var>)</code>, for each <var>x</var> ≠ π/2 + kπ, k=1, 2, 3…;</li>
                    <li><code><b>cot</b>(<var>x</var>)</code> - 余切 = <code><b>cos</b>(<var>x</var>)/<b>sin</b>(<var>x</var>)</code>, for each <var>x</var> ≠ π/2 + kπ, k=1, 2, 3…;</li>
                </ul>
            </li>
            <li>
                双曲三角函数:<ul style="list-style-type:none;">
                    <li><code><b>sinh</b>(<var>x</var>)</code> - 双曲正弦 = <code>(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>)/2</code>;</li>
                    <li><code><b>cosh</b>(<var>x</var>)</code> - 双曲余弦 = <code>(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)/2</code>;</li>
                    <li><code><b>tanh</b>(<var>x</var>)</code> - 双曲正切 = <code>(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>)/(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)</code>;</li>
                    <li><code><b>csch</b>(<var>x</var>)</code> - 双曲余割 = <code>1/<b>sinh</b>(<var>x</var>)</code>;</li>
                    <li><code><b>sech</b>(<var>x</var>)</code> - 双曲正割 = <code>1/<b>cosh</b>(<var>x</var>)</code>;</li>
                    <li><code><b>coth</b>(<var>x</var>)</code> - 双曲余切 = <code>(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)/(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>), for <var>x</var> ≠ 0</code>;</li>
                </ul>
            </li>
            <li>
                反三角函数:<ul style="list-style-type:none;">
                    <li><code><b>asin</b>(<var>x</var>)</code> - 反正弦, 定义域: -1 &le; <var>x</var> &le; 1;</li>
                    <li><code><b>acos</b>(<var>x</var>)</code> - 反余弦, 定义域: -1 &le; <var>x</var> &le; 1;</li>
                    <li><code><b>atan</b>(<var>x</var>)</code> - 反正切;</li>
                    <li><code><b>atan2</b>(<var>x</var>; <var>y</var>)</code>  - 正切值为<var>y</var>/<var>x</var>的角度;</li>
                    <li><code><b>acsc</b>(<var>x</var>)</code> - 反余割 = <code><b>asin</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>asec</b>(<var>x</var>)</code> - 反正割 = <code><b>acos</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>acot</b>(<var>x</var>)</code> - 反余切;</li>
                </ul>
            </li>
            <li>
                反双曲函数:<ul style="list-style-type:none;">
                    <li><code><b>asinh</b> (<var>x</var>)</code> - 反双曲正弦 = <code><b>ln</b>(<var>x</var> + <span class="root">√</span><span class="ovr"><var>x</var><sup>2</sup> + 1</span>)</code>, 定义域: -∞ &le; <var>x</var> &le; +∞;</li>
                    <li><code><b>acosh</b>(<var>x</var>)</code> - 反双曲余弦 = <code><b>ln</b>(<var>x</var> + <span class="root">√</span><span class="ovr"><var>x</var> + 1</span>&middot;<span class="root">√</span><span class="ovr"><var>x</var> - 1</span>)</code>, 定义域: <var>x</var> &ge; 1;</li>
                    <li><code><b>atanh</b>(<var>x</var>)</code> - 反双曲正切 = <code>1/2&middot;<b>ln</b>[(1 + <var>x</var>)/(1 - <var>x</var>)]</code>, for -1 &lt; <var>x</var> &lt; 1;</li>
                    <li><code><b>acsch</b>(<var>x</var>)</code> - 反双曲余切 = <code><b>atanh</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>asech</b>(<var>x</var>)</code> - 反双曲正割 = <code><b>acosh</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>acoth</b>(<var>x</var>)</code> - 反双曲余切 = <code>1/2&middot;<b>ln</b>[(<var>x</var> + 1)/(<var>x</var> - 1)]</code>, for |<var>x</var>| &gt; 1;</li>
                </ul>
            </li>
            <li>
                对数, 指数 和 根:<ul style="list-style-type:none;">
                    <li><code><b>log</b>(<var>x</var>)</code> - 十进制对数(底数为10), 定义域: <var>x</var> &gt; 0;</li>
                    <li><code><b>ln</b>(<var>x</var>)</code> - 自然对数(底数<var>e</var> ≈ 2.7183), 定义域: <var>x</var> &gt; 0;</li>
                    <li><code><b>log_2</b>(<var>x</var>)</code>  - 二进制对数 (底数为2), 定义域: <var>x</var> &gt; 0;</li>
                    <li><code><b>exp</b>(<var>x</var>)</code> - 自然指数函数 = <var>e</var>&hairsp;ˣ;</li>
                    <li><code><b>sqr</b>(<var>x</var>)</code>  或 <code><b>sqrt</b>(<var>x</var>)</code>  - 平方根 (<span class="root">√</span><span class="ovr"><var>x</var></span> ), 定义域: 定义域: <var>x</var> &ge; 0;</li>
                    <li><code><b>cbrt</b>(<var>x</var>)</code> - 立方根 ( <sup><sup>3</sup></sup><span class="root">√</span><span class="ovr"><var>x</var></span> );</li>
                    <li><code><b>root</b>(<var>x</var>; <var>n</var>)</code> - n次方根 ( <sup><sup>n</sup></sup><span class="root">√</span><span class="ovr"><var>x</var></span> );</li>
                </ul>
            </li>
            <li>
                舍入:<ul style="list-style-type:none;">
                    <li><code><b>round</b>(<var>x</var>)</code> - 舍入到最接近的整数;</li>
                    <li><code><b>floor</b>(<var>x</var>)</code> - 舍入到稍小的整数(向 -∞方向舍入);</li>
                    <li><code><b>ceiling</b>(<var>x</var>)</code> - 舍入到稍大的整数(向 +∞方向舍入);</li>
                    <li><code><b>trunc</b>(<var>x</var>)</code> - 舍入到稍小的整数(向0的方向舍入);</li>
                </ul>
            </li>
            <li>
                整数相关:<ul style="list-style-type:none;">
                    <li><code><b>mod</b>(<var>x</var>; <var>y</var>)</code> - 整除的余数;</li>
                    <li><code><b>gcd</b>(<var>x</var>; <var>y</var>)</code> - 最大公约数;</li>
                    <li><code><b>lcm</b>(<var>x</var>; <var>y</var>)</code> - 最小公倍数;</li>
                </ul>
            </li>
            <li>
                复数:<ul style="list-style-type:none;">
                    <li><code><b>abs</b>(<var>x</var>)</code> - 实数的绝对值(模)| <var>x</var> |;</li>
                    <li><code><b>abs</b>(a + b<var>i</var>)</code> - 复数模 = <b>sqrt</b>(a<sup>2</sup> + b<sup>2</sup>);</li>
                    <li><code><b>re</b>(a + b<var>i</var>)</code> - 仅返回复数的实部, <b>re</b>(a + b<var>i</var>) = a;</li>
                    <li><code><b>im</b>(a + b<var>i</var>)</code> - 返回复数的虚部的数值(实数), <b>im</b>(a + b<var>i</var>) = b;</li>
                    <li><code><b>phase</b>(a + b<var>i</var>)</code> - 复数的阶(辐角) = <b>atan2</b>(a; b).</li>
                </ul>
            </li>
            <li>
                聚合和内插:<ul style="list-style-type:none;">
                    <li><code><b>min</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 最小值;</li>
                    <li><code><b>max</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 最大值;</li>
                    <li><code><b>sum</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 求和<code> = <var>x</var> + <var>y</var> + <var>z</var>…</code>;</li>
                    <li><code><b>sumsq</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 平方和<code> = <var>x</var>² + <var>y</var>² + <var>z</var>²…</code>;</li>
                    <li><code><b>srss</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 平方和的平方根<code> = <b>sqrt</b>(<var>x</var>² + <var>y</var>² + <var>z</var>²…)</code>;</li>
                    <li><code><b>average</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 平均值<code> = (<var>x</var> + <var>y</var> + <var>z</var>…)/n</code>;</li>
                    <li><code><b>product</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 累积<code> = <var>x</var>·<var>y</var>·<var>z</var>…;</code></li>
                    <li><code><b>mean</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - 几何平均<code> = (<var>x</var>·<var>y</var>·<var>z</var>…)的n次方<b>根</b></code>;</li>
                    <li><code><b>take</b>(<var>n</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - 返回列表中的第n个元素;</li>
                    <li><code><b>line</b>(<var>x</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - 以<var>x</var>为参数在特定值中执行线性插值>;</li>
                    <li><code><b>spline</b>(<var>x</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - 执行Hermite多线性插值;</li>
                </ul>
            </li>
            <li>
                条件和逻辑:<ul style="list-style-type:none;">
                    <li><code><b>if</b>(&lt;<em>条件</em>&gt;; &lt;<em>条件为真的返回值</em>&gt;; &lt;<em>条件为假的返回值</em>&gt;)</code> - 如果<var>条件</var>满足,则函数返回第一个值,否则返回第二个值.当条件计算结果为非零数时,条件被满足;</li>
                    <li><code><b>switch</b>(&lt;<em>条件1</em>&gt;; &lt;<em>值1</em>&gt;; &lt;<em>条件2</em>&gt;; &lt;<em>值2</em>&gt;;…; &lt;<em>默认值</em>&gt;)</code> - 返回满足相应条件的值.条件从左到右进行检查.如果没有条件被满足,则最后返回默认值;</li>
                    <li><code><b>not</b>(<var>x</var>)</code> - 逻辑值 "否";</li>
                    <li><code><b>and</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 逻辑值 "且";</li>
                    <li><code><b>or</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 逻辑值 "或";</li>
                    <li><code><b>xor</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 逻辑值 "异或";</li>
                </ul>
            </li>
            <li>
                其他:<ul style="list-style-type:none;">
                    <li><code><b>sign</b>(<var>x</var>)</code> - 符号函数 = -1, if <var>x</var> < 0; 1, if <var>x</var> > 0, 0 if <var>x</var> = 0;</li>
                    <li><code><b>random</b>(<var>x</var>)</code> - 生成0 和 <var>x</var>之间的随机数.</li>
                </ul>
            </li>
            <li>
                向量:<ul>
                    <li>
                        创建相关:<ul style="list-style-type:none;">
                            <li><code><b>vector</b>(<var>n</var>)</code> - 创建长度为 <var>n</var>的空向量;</li>
                            <li><code><b>fill</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>)</code> - 以<var>x</var>的值填充向量<var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>range</b>(<var>x</var><sub>1</sub>; <var>x</var><sub>n</sub>; <var>s</var>)</code> - 创建一个向量其元素值从 <var>x</var><sub>1</sub> 到 <var>x</var><sub>n</sub> 以步 <var>s</var>变化;</li>
                        </ul>
                    </li>
                    <li>
                        结构相关:<ul style="list-style-type:none;">
                            <li><code><b>len</b>(<var><span class="vec">⃗</span>v</var>)</code> - 返回向量 <var><span class="vec">⃗</span>v</var>的长度(维数);</li>
                            <li><code><b>size</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量的实际大小 <var><span class="vec">⃗</span>v</var> (最后一个非0元素的索引号);</li>
                            <li><code><b>resize</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - 设置 <var>n</var> 为向量 <var><span class="vec">⃗</span>v</var>新的长度值;</li>
                            <li><code><b>join</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 通过合并:矩阵,向量和标量创建一个向量;</li>
                            <li><code><b>slice</b>(<var><span class="vec">⃗</span>v</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 返回向量的 <var><span class="vec">⃗</span>v</var> 索引号 <var>i</var><sub>1</sub> 到 <var>i</var><sub>2</sub> (包含边界)的部分;</li>
                            <li><code><b>first</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的前 <var>n</var>个元素;</li>
                            <li><code><b>last</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的后 <var>n</var>个元素;</li>
                            <li><code><b>extract</b>(<var><span class="vec">⃗</span>v</var>; <var><span class="vec">⃗</span>i</var>)</code> - 从向量 <var><span class="vec">⃗</span>v</var> 中提取元素,元素的索引号包含在向量 <var><span class="vec">⃗</span>i</var>中;</li>
                        </ul>
                    </li>
                    <li>
                        数据相关:<ul style="list-style-type:none;">
                            <li><code><b>sort</b>(<var><span class="vec">⃗</span>v</var>)</code> - 对向量 <var><span class="vec">⃗</span>v</var> 的元素按升↑序排列;</li>
                            <li><code><b>rsort</b>(<var><span class="vec">⃗</span>v</var>)</code> - 对向量 <var><span class="vec">⃗</span>v</var> 的元素按降↓序排列;</li>
                            <li><code><b>order</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的索引号, 以元素的升序排列;</li>
                            <li><code><b>revorder</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的索引号, 以元素的降序排列;</li>
                            <li><code><b>reverse</b>(<var><span class="vec">⃗</span>v</var>)</code> - 一个新向量包含 <var><span class="vec">⃗</span>v</var> 的元素,但逆序排列;</li>
                            <li><code><b>count</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第i个元素后= <var>x</var>的元素个数;</li>
                            <li><code><b>search</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后= <var>x</var>的第一个元素的索引号;</li>
                            <li><code><b>find</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> 或 </li>
                            <li><code><b>find_eq</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后= <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>find_ne</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后≠ <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>find_lt</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后 &lt; <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>find_le</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后 &le; <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>find_gt</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后 &gt; <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>find_ge</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>中, 第<var>i</var>个元素后 &ge; <var>x</var>的所有元素的索引号;</li>
                            <li><code><b>lookup</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> 或</li>
                            <li><code><b>lookup_eq</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有 = <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                            <li><code><b>lookup_ne</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有 ≠ <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                            <li><code><b>lookup_lt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有   &lt; <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                            <li><code><b>lookup_le</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有   &le; <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                            <li><code><b>lookup_gt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有   &gt; <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                            <li><code><b>lookup_ge</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - 向量 <var><span class="vec">⃗</span>a</var> 中所有   &ge; <var>x</var>的元素的索引号在<var><span class="vec">⃗</span>b</var>中对应的所有元素(顺序组成新向量);</li>
                        </ul>
                    </li>
                    <li>
                        数学相关:<ul style="list-style-type:none;">
                            <li><code><b>norm_1</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的L1 (Manhattan)范数;</li>
                            <li><code><b>norm</b>(<var><span class="vec">⃗</span>v</var>)</code> 或</li>
                            <li><code><b>norm_2</b>(<var><span class="vec">⃗</span>v</var>)</code> 或</li>
                            <li><code><b>norm_e</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的L2 (Euclidean)范数;</li>
                            <li><code><b>norm_p</b>(<var><span class="vec">⃗</span>v</var>; <var>p</var>)</code> - 向量<var><span class="vec">⃗</span>v</var>的Lp 范数;</li>
                            <li><code><b>norm_i</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的L∞ (无穷)范数;</li>
                            <li><code><b>unit</b>(<var><span class="vec">⃗</span>v</var>)</code> - 向量 <var><span class="vec">⃗</span>v</var>的规范化 (L2 范数 = 1);</li>
                            <li><code><b>dot</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code> - 2个向量 <var><span class="vec">⃗</span>a</var> 和 <var><span class="vec">⃗</span>b</var>的标量积;</li>
                            <li><code><b>cross</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code> - -2个向量(长度2或3) <var><span class="vec">⃗</span>a</var> 和 <var><span class="vec">⃗</span>b</var> 的叉积;</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                矩阵:<ul>
                    <li>
                        创建相关:<ul style="list-style-type:none;">
                            <li><code><b>matrix</b>(<var>m</var>; <var>n</var>)</code> - 创建一个 <var>m</var>⨯<var>n</var>的空矩阵;</li>
                            <li><code><b>identity</b>(<var>n</var>)</code> - 创建一个 <var>n</var>⨯<var>n</var>的单位矩阵;</li>
                            <li><code><b>diagonal</b>(<var>n</var>; <var>d</var>)</code> - 创建一个<var>n</var>⨯<var>n</var> 对角元素值为 <var>d</var>的对角矩阵;</li>
                            <li><code><b>column</b>(<var>m</var>; <var>c</var>)</code> - 创建一个 <var>m</var>⨯1的列矩阵, 元素值都为 <var>c</var>;</li>
                            <li><code><b>utriang</b>(<var>n</var>)</code> - 创建一个 <var>n</var>⨯<var>n</var>的上三角矩阵;</li>
                            <li><code><b>ltriang</b>(<var>n</var>)</code> - 创建一个 <var>n</var>⨯<var>n</var>的下三角矩阵;</li>
                            <li><code><b>symmetric</b>(<var>n</var>)</code> - 创建一个 <var>n</var>⨯<var>n</var>的对称矩阵;</li>
                            <li><code><b>vec2diag</b>(<var><span class="vec">⃗</span>v</var>)</code> - 用向量 <var><span class="vec">⃗</span>v</var>的元素创建一个对角矩阵;</li>
                            <li><code><b>vec2row</b>(<var><span class="vec">⃗</span>v</var>)</code> - 用向量 <var><span class="vec">⃗</span>v</var>创建包含元素的行矩阵;</li>
                            <li><code><b>vec2col</b>(<var><span class="vec">⃗</span>v</var>)</code> - 用向量 <var><span class="vec">⃗</span>v</var>的元素创建一个列矩阵;</li>
                            <li><code><b>join_cols</b>(<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub>…)</code> - 通过合并列向量创建新矩阵;</li>
                            <li><code><b>join_rows</b>(<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub>…)</code> - 通过合并行向量创建新矩阵;</li>
                            <li><code><b>augment</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 通过对矩阵<var>A</var><span class="o">;</span> <var>B</var><span class="o">;</span> <var>C</var> 左右相接扩充创建新矩阵;</li>
                            <li><code><b>stack</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - 通过对矩阵 <var>A</var><span class="o">;</span> <var>B</var><span class="o">;</span> <var>C</var> 上下相接创建新矩阵;</li>
                        </ul>
                    </li>
                    <li>
                        结构相关:<ul style="list-style-type:none;">
                            <li><code><b>n_rows</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的行数;</li>
                            <li><code><b>n_cols</b>(<var>M</var>)</code> - 矩阵<var>M</var>的列数;</li>
                            <li><code><b>mresize</b>(<var>M</var>; <var>m</var>; <var>n</var>)</code> - 对矩阵 <var>M</var>设置新的维数 <var>m</var> 和 <var>n</var> ;</li>
                            <li><code><b>mfill</b>(<var>M</var>; <var>x</var>)</code> - 以 <var>x</var>值填充矩阵 <var>M</var> ;</li>
                            <li><code><b>fill_row</b>(<var>M</var>; <var>i</var>; <var>x</var>)</code> - 以 <var>x</var>填充矩阵 <var>M</var>的第 <var>i</var> 行;</li>
                            <li><code><b>fill_col</b>(<var>M</var>; <var>j</var>; <var>x</var>)</code> - 以 <var>x</var>填充矩阵 <var>M</var>的第 <var>j</var> 列;</li>
                            <li><code><b>copy</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code> - 将 <var>A</var> 的所有元素复制到 <var>B</var>, <var>B</var>的索引起始号为行: <var>i</var> ;列: <var>j</var>;</li>
                            <li><code><b>add</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code> - 将 <var>A</var> 的所有元素加到 <var>B</var>, <var>B</var>的索引起始号为行: <var>i</var> ;列: <var>j</var>;</li>
                            <li><code><b>row</b>(<var>M</var>; <var>i</var>)</code> - 提取矩阵<var>M</var>第 <var>i</var>行为一个向量;</li>
                            <li><code><b>col</b>(<var>M</var>; <var>j</var>)</code> - 提取矩阵<var>M</var>第 <var>j</var>列为一个向量;</li>
                            <li><code><b>extract_rows</b>(<var>M</var>; <var><span class="vec">⃗</span>i</var>)</code> - 从矩阵<var>M</var> 中提取行,行号包含在向量<var><span class="vec">⃗</span>i</var>中;</li>
                            <li><code><b>extract_cols</b>(<var>M</var>; <var><span class="vec">⃗</span>j</var>)</code> - 从矩阵<var>M</var> 中提取列,行号包含在向量<var><span class="vec">⃗</span>j</var>中;</li>
                            <li><code><b>diag2vec</b>(<var>M</var>)</code> - 将矩阵 <var>M</var>的对角元素提取到一个向量中;</li>
                            <li><code><b>submatrix</b>(<var>M</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 在矩阵 <var>M</var>中提取一个次矩阵, 行号 <var>i</var><sub>1</sub> 到 <var>i</var><sub>2</sub> 列号 <var>j</var><sub>1</sub> 到 <var>j</var><sub>2</sub>, 上下界限包含在内;</li>
                        </ul>
                    </li>
                    <li>
                        数据相关:<ul style="list-style-type:none;">
                            <li><code><b>sort_cols</b>(<var>M</var>; <var>i</var>)</code> - 以第 <var>i</var> 行的值为准对矩阵<var>M</var>的列按照升序排列;</li>
                            <li><code><b>rsort_cols</b>(<var>M</var>; <var>i</var>)</code> - 以第 <var>i</var> 行的值为准对矩阵<var>M</var>的列按照降序排列;</li>
                            <li><code><b>sort_rows</b>(<var>M</var>; <var>j</var>)</code> - 以第 <var>j</var> 列的值为准对矩阵<var>M</var>的行按照升序排列;</li>
                            <li><code><b>rsort_rows</b>(<var>M</var>; <var>j</var>)</code> - 以第 <var>j</var> 列的值为准对矩阵<var>M</var>的行按照降序排列;</li>
                            <li><code><b>order_cols</b>(<var>M</var>; <var>i</var>)</code> - 以矩阵 <var>M</var>第 <var>i</var> 行的值按照升序排列,对应的的列号排序;</li>
                            <li><code><b>revorder_cols</b>(<var>M</var>; <var>i</var>)</code> - 以矩阵 <var>M</var>第 <var>i</var> 行的值按照降序排列,对应的的列号排序;</li>
                            <li><code><b>order_rows</b>(<var>M</var>; <var>j</var>)</code> - 以矩阵 <var>M</var>第 <var>j</var> 列的值按照升序排列,对应的的行号排序;</li>
                            <li><code><b>revorder_rows</b>(<var>M</var>; <var>j</var>)</code> - 以矩阵 <var>M</var>第 <var>j</var> 列的值按照降序排列,对应的的行号排序;</li>
                            <li><code><b>mcount</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var>出现 <var>x</var>值的次数 ;</li>
                            <li>
                                <code><b>msearch</b>(<var>M</var>; <var>x</var>; <var>i</var>; <var>j</var>)</code> - 以在矩阵 <var>M</var>中第一次出现<var>x</var>的行号 <var>i</var> 和列号 <var>j</var>组成的向量;
                            </li>
                            <li><code><b>mfind</b>(<var>M</var>; <var>x</var>)</code> 或</li>
                            <li><code><b>mfind_eq</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 = <var>x</var>的元素的索引号;</li>
                            <li><code><b>mfind_ne</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 ≠ <var>x</var>的元素的索引号;</li>
                            <li><code><b>mfind_lt</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 &lt; <var>x</var>的元素的索引号;</li>
                            <li><code><b>mfind_le</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 &le; <var>x</var>的元素的索引号;</li>
                            <li><code><b>mfind_gt</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 &gt; <var>x</var>的元素的索引号;</li>
                            <li><code><b>mfind_ge</b>(<var>M</var>; <var>x</var>)</code> - 矩阵 <var>M</var> 中所有 &ge; <var>x</var>的元素的索引号;</li>
                            <li><code><b>hlookup</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> 或</li>
                            <li><code><b>hlookup_eq</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  = <var>x</var>时,该列对应的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>hlookup_ne</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  ≠ <var>x</var>时,该列对应的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>hlookup_lt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  &lt; <var>x</var>时,该列对应的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>hlookup_le</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  &le; <var>x</var>时,该元素所在列的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>hlookup_gt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  &gt; <var>x</var>时,该元素所在列的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>hlookup_ge</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  &ge; <var>x</var>时,该元素所在列的第<var>i</var><sub>2</sub>行的元素值(组成的向量);</li>
                            <li><code><b>vlookup</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> 或</li>
                            <li><code><b>vlookup_eq</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  =<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                            <li><code><b>vlookup_ne</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  ≠<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                            <li><code><b>vlookup_lt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  &lt;<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                            <li><code><b>vlookup_le</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  &le;<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                            <li><code><b>vlookup_gt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  &gt;<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                            <li><code><b>vlookup_ge</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - 矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  &ge;<var>x</var>时,该元素所在行的第<var>j</var><sub>2</sub>列的元素值(组成的向量);</li>
                        </ul>
                    </li>
                    <li>
                        数学相关:<ul style="list-style-type:none;">
                            <li><code><b>hprod</b>(<var>A</var>; <var>B</var>)</code> - 矩阵 <var>A</var>和<var>B</var>的Hadamard积;</li>
                            <li><code><b>fprod</b>(<var>A</var>; <var>B</var>)</code> - 矩阵 <var>A</var> 和 <var>B</var>的Frobenius积;</li>
                            <li><code><b>kprod</b>(<var>A</var>; <var>B</var>)</code> - 矩阵 <var>A</var> 和 <var>B</var>的Kronecker积;</li>
                            <li><code><b>mnorm_1</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的L1范数;</li>
                            <li><code><b>mnorm</b>(<var>M</var>)</code> 或<br />
                            <li><code><b>mnorm_2</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的L2范数;</li>
                            <li><code><b>mnorm_e</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的Frobenius范数;</li>
                            <li><code><b>mnorm_i</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的L∞范数;</li>
                            <li><code><b>cond_1</b>(<var>M</var>)</code> - 矩阵 <var>M</var> 基于L1范数的条件数;</li>
                            <li><code><b>cond</b>(<var>M</var>)</code> 或</li>
                            <li><code><b>cond_2</b>(<var>M</var>)</code> - 矩阵 <var>M</var> 基于 L2范数的条件数;</li>
                            <li><code><b>cond_e</b>(<var>M</var>)</code> - 矩阵 <var>M</var> 基于  Frobenius范数的条件数;</li>
                            <li><code><b>cond_i</b>(<var>M</var>)</code> - 矩阵 <var>M</var> 基于 L∞ 范数的条件数;</li>
                            <li><code><b>det</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的行列式;</li>
                            <li><code><b>rank</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的秩;</li>
                            <li><code><b>trace</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的迹;</li>
                            <li><code><b>transp</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的转置矩阵;</li>
                            <li><code><b>adj</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的伴随矩阵(adjugate matrix);</li>
                            <li><code><b>cofactor</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的协因数/共因子矩阵(cofactor matrix);</li>
                            <li><code><b>eigenvals</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的特征值(eigenvalues);</li>
                            <li><code><b>eigenvecs</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的特征向量(eigenvectors);</li>
                            <li><code><b>eigen</b>(<var>M</var>)</code> - 矩阵<var>M</var>的特征值及特征向量;</li>
                            <li><code><b>cholesky</b>(<var>M</var>)</code> - 对称且正-定矩阵<var>M</var>的Cholesky分解;</li>
                            <li><code><b>lu</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的LU分解;</li>
                            <li><code><b>qr</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的QR分解;</li>
                            <li><code><b>svd</b>(<var>M</var>)</code> - 矩阵<var>M</var>的奇异值分解(SVD);</li>
                            <li><code><b>inverse</b>(<var>M</var>)</code> - 矩阵 <var>M</var>的逆矩阵;</li>
                            <li><code><b>lsolve</b>(<var>A</var>; <var>b</var>)</code> - 求解线性方程组 <var>A <span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var>:对对称矩阵使用 LDL<sup>T</sup> 分解,对非对称矩阵使用 LU分解;</li>
                            <li><code><b>clsolve</b>(<var>A</var>; <var>b</var>)</code> - 求解线性矩阵方程 <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var> :对对称且正-定系数矩阵<var>A</var> 使用Cholesky 分解;</li>
                            <li><code><b>msolve</b>(<var>A</var>; <var>B</var>)</code> - 求解一般矩阵方程 <var>AX</var> = <var>B</var> :对对称矩阵使用 LDL<sup>T</sup> 分解;对非对称矩阵使用LU分解;</li>
                            <li>
                                <code><b>cmsolve</b>(<var>A</var>; <var>B</var>)</code> - 求解一般矩阵方程 <var>AX</var> = <var>B</var> :对对称且正-定系数矩阵<var>A</var> 使用Cholesky分解;<br />
                            </li>
                    </li>
                </ul>
            </li>
            <li>
                双重插值:<ul style="list-style-type:none;">
                    <li><code><b>take</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - 返回矩阵 <var>M</var> 行号 <var>x</var> 列号 <var>y</var>的元素;</li>
                    <li><code><b>line</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - 基于 <var>x</var> 和 <var>y</var>值对<var>M</var>中元素的双重线性插值;</li>
                    <li><code><b>spline</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - 基于 <var>x</var> 和 <var>y</var>值对<var>M</var>中元素的双重Hermite样条曲线插值.</li>
                </ul>
            </li>
        </ul>
        </li>
        </ul>
        <p>参数必须用圆括号括起来.它们可以是常数、变量或任何有效的表达式.多个参数必须用分号 ";" 分隔.当参数超出范围时,函数返回 "<span class="err">未定义</span>".不适用此规则的例外是 "<b>cot</b>(0)" 和 "<b>coth</b>(0)",它们返回 "<span class="err">+∞</span>".</p>
        <p>三角函数的参数可以是 <b>度</b>、<b>弧度</b> 或 <b>梯度</b>.角度单位可以以三种不同的方式指定:</p>
        <p>1. 通过输出窗口上方的单选按钮 (<small>🔘</small><b>D</b>、<small>🔘</small><b>R</b>、<small>🔘</small><b>G</b>).</p>
        <p>2. 通过代码内的编译器开关.您必须插入一行单独的代码,其中包含:<span class="cond">#deg</span> 表示度,<span class="cond">#rad</span> 表示弧度或 <span class="cond">#gra</span> 表示梯度.这将影响当前行后的所有表达式,直到找到另一个指令为止.</p>
        <p>3. 通过将原生单位附加到值本身:<i>deg</i>、<i>°</i>、<i>′</i>、<i>″</i>、<i>rad</i>、<i>grad</i>、<i>rev</i>(请参见本手册中的“单位”部分).</p>
        <p>原生单位具有最高优先级,其次是源代码中的编译器开关.两者都会覆盖单选按钮设置,后者为最低优先级.</p>
        <p>所有函数也在复数域中定义,除了<b>mod</b>(<var>x</var>; <var>y</var>)、<b>gcd</b>(<var>x</var>; <var>y</var>)、<b>lcm</b>(<var>x</var>; <var>y</var>)、<b>min</b>(<var>x</var>; <var>y</var>) 和 <b>max</b>(<var>x</var>; <var>y</var>).</p>
        <p>逻辑函数接受数值并返回“<b>0</b>”表示“<b>false</b>”,返回“<b>1</b>”表示“<b>true</b>”.两个参数(一个为“<b>not</b>”)的结果如下表所示:</p>
        <table width="100%">
            <tr>
                <td style="border:none; vertical-align:top;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th style="width:60%">not(x)</th></tr>
                        <tr><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">and(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>0</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">or(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">xor(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>0</td></tr>
                    </table>
                </td>
            </tr>
        </table>
        <p>任何与0不同的数值都被视为1(真).多个参数按照上述表格从左到右顺序进行评估.我们从第一个和第二个开始.然后,依次评估获得的结果和下一个值,以此类推.</p>
        <p>使用<b>round</b>()函数对中点值进行四舍五入,结果为离0最近的整数.<b>floor</b>()函数向较小的值(向-∞)进行舍入.<b>ceiling</b>()函数向较大的值(向+∞)进行舍入.与<b>floor</b>()不同,<b>trunc</b>()函数向0进行舍入,相当于简单地截断小数部分.下表提供了一些负数和正数舍入的示例:</p>
        <table width="70%">
            <tr>
                <td style="border:none;">
                    <p><b>正数</b></p>
                    <table width="90%" class="tr">
                        <tr><th>函数</th><th style="width:30%">x</th><th>结果</th></tr>
                        <tr><th>round(x)</th><td>4.5</td><td>5</td></tr>
                        <tr><th>floor(x)</th><td>4.8</td><td>4</td></tr>
                        <tr><th>ceiling(x)</th><td>4.2</td><td>5</td></tr>
                        <tr><th>trunc(x)</th><td>4.8</td><td>4</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>负数</b></p>
                    <table width="90%" class="tr">
                        <tr><th>函数</th><th style="width:30%">x</th><th>结果</th></tr>
                        <tr><th>round(x)</th><td>-4.5</td><td>-5</td></tr>
                        <tr><th>floor(x)</th><td>-4.8</td><td>-5</td></tr>
                        <tr><th>ceiling(x)</th><td>-4.2</td><td>-4</td></tr>
                        <tr><th>trunc(x)</th><td>-4.8</td><td>-4</td></tr>
                    </table>
                </td>
            </tr>
        </table>
        <p>舍入复数会影响实部和虚部.</p>

        <h4>自定义函数</h4>
        <p>您可以定义自己的函数,并在计算中进一步使用它们.自定义函数可以有无限数量的参数.它们在函数名后面指定,用括号“(”…“)”括起来,并用分号“;”分隔.每个函数的定义格式如下:“<b>f</b>(<var>x</var>;<var>y</var>;<var>z</var>;…)= <b>expression(表达式)</b>”,其中“<b>f</b>”是函数名,“<b>x</b>”、“<b>y</b>”和“<b>z</b>”是函数参数.在右侧,您可以有任何有效的表达式,包括常数、运算符、变量甚至其他函数,例如:</p>
        <ul style="list-style-type:none;">
            <li><code><b>f</b>(<var>x</var>) = <var>x</var>^2 + 2*x*<b>sin</b>(<var>x</var>)</code></li>
            <li><code><b>g</b>(<var>x</var>; <var>y</var>) = <b>f</b>(<var>x</var>)/(<var>y</var> - 4)</code></li>
        </ul>
        <p>定义后,您可以在任何表达式中使用函数,只需写出函数名,然后在括号中指定参数,例如 <var>b</var> = <b>g</b>(<var>a</var> + 2;3) + 3.函数名必须符合变量名的规则.参数可以是任何有效的表达式.您必须提供与函数参数数量相同的参数.函数的生命周期从定义的位置到代码的结尾.如果您定义了一个同名的新函数,旧函数将被替换.您不能重新定义库函数.例如,<b>sin</b>(<var>x</var>)= <var>x</var>^2 将返回错误.</p>
        <p>不需要预先定义用于参数的变量.但是,如果在函数体内使用其他变量,则必须在第一次调用函数之前定义它们.参数在函数体内起到局部变量的作用.如果函数外存在同名变量,对该函数的调用不会重写全局变量的值.例如:</p>
        <ul style="list-style-type:none;">
            <li>若变量 "<var>x</var> = 4"</li>
            <li>且函数"<b>f</b>(<var>x</var>) = <var>x</var><sup>2</sup>".</li>
            <li>当调用 "<b>f</b>(2)", 将得到 <var>x</var><sup>2</sup> = 2<sup>2</sup> = 4, 因为局部变量 <var>x</var> = 2</li>
            <li>如果在这之后调用 "<var>x</var><sup>2</sup>" , 将得到 <var>x</var><sup>2</sup> = 4<sup>2</sup> = 16, 因为全局变量 <var>x</var> 仍为4.</li>
        </ul>
        <p>自定义函数支持实数和复数.</p>

        <h3 id="TOC_406">绘图</h3>
        <p>除了函数外,Calcpad还提供了用于高级操作的特殊命令.它们接受函数和表达式作为参数,并执行绘图、迭代解和数值方法.它们的名称以"$"开头,以与普通函数区分.它们的参数必须用花括号"{"和"}"括起来.其中一个是绘图命令<span class="cond">$Plot</span>.它可以在指定的区间内绘制一个变量的函数.它的格式如下:</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Plot</span>{<b>y</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>, 其中:</p>
        <ul style="list-style-type:none;">
            <li><b>y</b>(<var>x</var>) - 要绘制的函数.可以使用任何有效的表达式代替<b>y</b>(<var>x</var>),它将用于计算纵坐标的值;</li>
            <li><var>x</var> - 横坐标上的变量名.您只能在此处放置一个变量名.不需要预先定义该变量;</li>
            <li><var>a</var>和<var>b</var>是<var>x</var>变量的区间限制.您可以在<var>a</var>和<var>b</var>处放置数字、变量或任何有效的表达式.</li>
        </ul>
        <p>例如,如果您输入:<code><span class="cond">$Plot</span>{<var>x</var>^2 - 5*<var>x</var> + 3 &#64; x = -1:6}</code>,您将得到以下结果:</p>
        <p style="text-align:center;"><img width="400" src="Images/Plot.png" alt="Plot.png"></p>
        <p>上述命令一次只能绘制一个变量的一个函数.还有其他格式可以使用:</p>
        <p style="margin-left: 2em;">
            <code><span class="cond">$Plot</span>{<b>x</b>(<var>t</var>)|<b>y</b>(<var>t</var>) &#64; <var>t</var> = <var>a</var> : <var>b</var>}</code> - 参数化函数绘图:坐标都是参数的函数;<br />
            <code><span class="cond">$Plot</span>{<b>y</b><sub>1</sub>(<var>x</var>) &amp; <b>y</b><sub>2</sub>(<var>x</var>) &amp;  … &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code> - 单图多函数:在一个图上绘制多个函数;<br />
            <code><span class="cond">$Plot</span>{<b>x</b><sub>1</sub>(<var>t</var>)|<b>y</b><sub>1</sub>(<var>t</var>) &amp; <b>x</b><sub>2</sub>(<var>t</var>)|<b>y</b><sub>2</sub>(<var>t</var>) &amp; … &#64; <var>t</var> = <var>a</var> : <var>b</var>}</code> - 多个参数绘图;<br />
            <code><span class="cond">$Map</span>{<b>f</b>(<var>x</var>; <var>y</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var> &amp; <var>y</var> = <var>c</var> : <var>d</var>}</code> - 绘制由<b>f</b>(<var>x</var>; <var>y</var>)定义的3D表面的2D颜色图.
        </p>
        <p><span class="cond">$Plot</span>{...}函数必须在一行中最先出现.在它之前只能有空格和制表符,甚至不能有注释.否则,程序将返回错误.在闭括号"}"之后的任何文本都将被忽略.绘图仅支持实数.只有在绘图区间上,<var>x</var>和<var>y</var>都是实数并且函数返回实数结果时,才能在复数模式下使用.</p>
        <p>您可以通过定义两个变量:<var>PlotWidth</var>和<var>PlotHeight</var>(以像素为单位)来指定绘图区域的大小.默认值为<var>PlotWidth</var> = 400和<var>PlotHeight</var> = 250.</p>
        <p><span class="cond">$Map</span>{...}函数可以使用不同的调色板.从程序窗口底部的"<b>调色板(Palette)</b>"组合框中选择首选项.如果选择了"<b>平滑(Smooth)</b>"复选框,刻度将显示为平滑渐变.否则,程序将绘制彩色条.您还可以通过选择相应的组合框来为图形添加3D效果.</p>
        <p>以下是不同绘图方法的示例:</p>
        <table class="nb">
            <tr>
                <td style="line-height:150%;">
                    <b>参数化绘图</b><br />
                    方程:<br /><br />
                    <code><b>r</b>(<var>θ</var>) = <b>cos</b>(5/2*<var>θ</var>)</code><br />
                    <code><span class="cond">$Plot</span>{<b>r</b>(<var>θ</var>)*<b>cos</b>(<var>θ</var>)|<b>r</b>(<var>θ</var>)*<b>sin</b>(<var>θ</var>) &#64; <var>θ</var> = 0:6*π}</code>
                </td>
                <td style="line-height:150%;">
                    <b>多变量函数绘图</b><br />
                    方程:<br />
                    <code><b>y</b><sub>1</sub>(<var>θ</var>) = <b>cos</b>(<var>θ</var>) - <b>sin</b>(<var>θ</var>)</code><br />
                    <code><b>y</b><sub>2</sub>(<var>θ</var>) = <b>cos</b>(<var>θ</var>) + <b>sin</b>(<var>θ</var>)</code><br />
                    <code><span class="cond">$Plot</span>{<b>cos</b>(<var>θ</var>) & <b>y</b><sub>1</sub>(<var>θ</var>) & <b>y</b><sub>2</sub>(<var>θ</var>) &#64; <var>θ</var> = 0:<var>π</var>}</code>
                </td>
            </tr>
            <tr>
                <td>
                    结果: "玫瑰" 曲线<br />
                    <img style="height:220pt;" src="Images/Plot-Rose.png" alt="Plot-Rose.png">
                </td>
                <td>
                    结果: 3个三角函数构成的树叶形<br />
                    <img style="height:220pt;" src="Images/Plot-Leaf.png" alt="Plot-Leaf.png">
                </td>
            </tr>
            <tr>
                <td style="line-height:150%;">
                    <b>多参数化</b><br />
                    方程:<br />
                    <code><b>x</b>(<var>θ</var>) = <b>sqr</b>(<var>θ</var>)*<b>cos</b>(<var>θ</var>)</code><br />
                    <code><b>y</b>(<var>θ</var>) = <b>sqr</b>(<var>θ</var>)*<b>sin</b>(<var>θ</var>)</code><br />
                    <code><span class="cond">$Plot</span>{<b>x</b>(<var>θ</var>)|<b>y</b>(<var>θ</var>) & -<b>x</b>(<var>θ</var>)|-<b>y</b>(<var>θ</var>) &#64; <var>θ</var> = 0:3*<var>π</var>}</code>
                </td>
                <td style="line-height:150%;">
                    <b>彩色映射图</b><br />
                    方程:<br /><br />
                    <code><b>f</b>(<var>x</var>; <var>y</var>) = <b>cos</b>(<var>x</var>/3) + <b>sin</b>(<var>y</var>) - <b>sin</b>(<var>x</var>)*<b>cos</b>(<var>y</var>/4)</code><br />
                    <code><span class="cond">$Map</span>{<b>f</b>(<var>x</var>; <var>y</var>) &#64; <var>x</var> = -15 : 15 & <var>y</var> = -15 : 15}</code>
                </td>
            </tr>
            <tr>
                <td>
                    结果:双Fermat螺旋线<br />
                    <img style="height:220pt;" src="Images/Plot-Fermat.png" alt="Plot-Fermat.png">
                </td>
                <td>
                    结果: 2D波浪图<br />
                    <img style="height:220pt;" src="Images/Map-Wave.png" alt="Plot-Wave.png">
                </td>
            </tr>
        </table>

        <h3 id="TOC_407">数值方法</h3>
        <p>Calcpad内置了一个"<b>Solver(求解器)</b>"模块,可以使用数值方法解决更复杂的问题.它只能处理实数,而不能处理复数.该模块包括以下函数:</p>

        <h4>求根</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Root</span>{<b>f</b>(<var>x</var>) = const &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p style="margin-left: 2em;"><code><span class="cond">$Root</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>它在区间[<var>a</var>, <var>b</var>]内找到方程"<b>f</b>(<var>x</var>) = const"的一个根.如果"const"为零,您可以省略"= const".程序使用<a href="https://iopscience.iop.org/article/10.1088/1757-899X/1276/1/012010">混合括号法</a>,它是二分法和Anderson-Bjork方法的组合.它随后缩小根周围的区间,直到小于指定的精度.要求函数"<b>f</b>(<var>x</var>) - const"在区间的两端具有相反的符号.根据波尔查诺定理,如果函数在区间内是连续的,至少存在一个根.括号法算法将在有限次迭代后找到一个近似值.</p>
        <p style="text-align:center;"><img style="height:130pt;" src="Images/Root.png" alt="Root.png"></p>
        <p>使用此方法,您只能找到函数与"<var>y</var> = const"相交的根.当"<b>f</b>(<var>x</var>) - const"完全为正或负,并且只从一侧"触碰"该线时,您无法通过任何括号法找到根.</p>
        <p>如果初始区间内不存在根,则程序返回错误.如果有多个根,它只会找到其中的一个.在这种情况下,最好先绘制函数.然后,您可以看到根的大致位置,并将区间分成几个部分 - 每个根一个区间.最后,您可以多次调用函数来找到所有的根.在某些情况下,可以开发自动分割区间的程序.</p>

        <h4>最小值</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Inf</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>它在指定区间[<var>a</var>, <var>b</var>]内找到函数<b>f</b>(<var>x</var>)的最小值.为此,应用黄金分割搜索方法.如果函数在区间内包含局部最小值,则将其作为结果返回.否则,函数将返回区间两端值中较小的一个:<b>f</b>(<var>a</var>)或<b>f</b>(<var>b</var>).如果存在多个局部最小值,则程序将仅返回其中一个,但不一定是最小的.在这种情况下,最好将区间分割.找到最小值的<var>x</var>值存储在变量<var>x</var><sub>inf</sub>中.如果您使用不同的参数名称,而不是<var>x</var>,它将在该名称末尾添加"_inf".</p>

        <h4>最大值</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Sup</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>它的工作方式类似于查找最小值的函数,但它找到的是最大值.存储最大值所在的<var>x</var>值的变量名为<var>x</var><sub>sup</sub>.</p>

        <h4>数值积分</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Area</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>它计算指定区间[<var>a</var>, <var>b</var>]内函数<b>f</b>(<var>x</var>)的定积分值.为此,应用自适应高斯-洛巴托积分与Kronrod扩展 (<a target="_blank" href="https://www.researchgate.net/publication/226706221_Adaptive_Quadrature-Revisited">Gander & Gautschi</a>, 2000).</p>

        <p style="margin-left: 2em;"><code><span class="cond">$Integral</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>这个命令与上面的命令类似,但它使用了Tanh-Sinh积分(<a target="_blank" href="https://ems.press/content/serial-article-files/2719">Takahasi＆Mori</a>,1974),后来由<a target="_blank" href="https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001;jsessionid=55mdimh9e060a.x-ic-live-03">Michashki＆Mosig</a>(2016)和<a target="_blank" href="https://www.genivia.com/files/qthsh.pdf">Van Engelen</a>(2022)进行了进一步的改进.在Calcpad中进行了进一步的改进,通过预计算和缓存横坐标和权重,这个算法在连续和光滑函数的情况下显著优于<code class="cond">$Area</code>.但是,如果函数不满足这些要求,则<b>不应</b>使用<code class="cond">$Integral</code>方法.这时,你有两个选项:</p>
        <ol>
            <li>通过使用不连续点将区间[<var>a</var>,<var>b</var>]分成较小的部分,对每个部分分别应用该方法,并将结果相加;</li>
            <li>如果你不确定不连续点在哪里,请改用<code class="cond">$Area</code>方法.</li>
        </ol>

        <h4>数值微分</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Slope</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var>}</code></p>
        <p>它找到函数<b>f</b>(<var>x</var>)在<var>x</var>=<var>a</var>处的一阶导数值.导数表示函数在相应点的切线斜率.使用两点模板的Richardson外推法.</p>

        <h4>一般性考虑</h4>
        <p>与绘图命令不同,你可以在表达式中包含数值方法.它们返回可用于进一步计算的值.例如,你可以将结果存储到一个变量中:</p>
        <p style="margin-left: 2em;"><code><var>y</var><sub>min</sub> = <span class="cond">$Inf</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>与标准函数类似,"<var>x</var>"对于所有数值方法都是局部的,在调用方法后不会修改它的全局值.</p>

        <h3 id="TOC_408">迭代过程</h3>
        <p>还有一些其他命令可以让你以迭代的方式计算结果.与数值方法不同,它们可以处理复数.</p>

        <h4>求和</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Sum</span>{<b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>它对所有整数<var>k</var>在<var>a</var>和<var>b</var>之间的<b>f</b>(<var>k</var>)的值进行求和.<var>k</var>的值只能增加,所以需要满足<var>a</var> &lt; <var>b</var>.你可以在<b>f</b>(<var>k</var>)的位置上放置任何包含<var>k</var>的有效表达式.否则,它将简单地将相同的值<var>k</var>累加<var>k</var>次.例如,你可以使用级数来计算常数.这是计算π的莱布尼兹公式的例子:</p>
        <p style="margin-left: 2em;"><code>4*<span class="cond">$Sum</span>{(-1)<sup><var>k</var>+1</sup>/(2*<var>k</var> - 1) &#64; <var>k</var> = 1:1000}= 3.1406</code></p>
        <p>你还可以使用级数来定义函数.当然,它们不能是无限的.迭代次数应足够提供所需结果的精度.下面的模式可以用来用傅里叶级数近似一个函数:</p>
        <p style="margin-left: 2em;"><code><b>f</b>(<var>x</var>) = <var>a</var><sub>0</sub>/2 + <span class="cond">$Sum</span>{<b>a</b>(<var>k</var>)*<b>cos</b>(<var>k</var>*<var>x</var>*π/<var>l</var>) &#64; <var>k</var> = 1:<var>n</var>} + <span class="cond">$Sum</span>{<b>b</b>(<var>k</var>)*<b>sin</b>(<var>k</var>*<var>x</var>*π/<var>l</var>) &#64; <var>k</var> = 1:<var>n</var>}</code></p>
        <p>例如,我们可以在区间(0; 2*<var>l</var>)上用方程: f(<var>x</var>) = <var>x</var>/(2*<var>l</var>)取一条直线. 积分常数为 <var>a</var>(<var>k</var>) = 0 及 <var>b</var>(<var>k</var>) = -1/(<var>k</var>*π). 若对<var>n</var> = 5画出Fourier(傅里叶)近似,可以得到如下结果:</p>
        <p style="text-align:center;"><img alt="Fourier" src="Images/Fourier.png" width="400"></p>

        <h4>累积</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Product</span>{<b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>类似"<b>Sum</b>", 只是变成了多个量的连乘. 例如, 可以这样自定义阶乘函数:</p>
        <p style="margin-left: 2em;"><code><b>F</b>(<var>n</var>) = <span class="cond">$Product</span> {<var>k</var> &#64; <var>k</var> = 1 : <var>n</var>}</code></p>
        可以进一步利用表达式: <b>C</b>(<var>n</var>; <var>k</var>) = <b>F</b>(<var>n</var>)/(<b>F</b>(<var>k</var>)*<b>F</b>(<var>n</var> - <var>k</var>))计算二项式系数. 然而,自定义一个特殊程序来直接计算系数比使用阶乘更高效:
        <p style="margin-left: 2em;"><code><span class="cond">$Product</span>{(<var>i</var> + <var>n</var> - <var>k</var>)/<var>i</var> &#64; <var>i</var> = <var>1</var>:<var>k</var>}</code></p>
        <p>而且,与阶乘相比,后者不会因为<var>n</var>数值过大而溢出.</p>

        <h4>循环</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Repeat</span>{<b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>这是一个通用的内联迭代过程,可以重复计算<b>f</b>(<var>k</var>).它可以用于求和和乘积,而不是相应的过程,但效率不太高.然而,有些表达式只能通过"<b>Repeat</b>"命令来计算.通常,如果你将结果赋给一个变量以在下一次迭代中使用,这样的表达式才有意义.因此,在实践中更有可能应用以下模式:</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Repeat</span>{<var>x</var> = <b>f</b>(<var>x</var>; <var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>例如,你可以使用这个命令在一行中定义Mandelbrot集:</p>
        <p style="margin-left: 2em;"><code><b>f</b>(<var>z</var>; <var>c</var>) = <span class="cond">$Repeat</span>{<var>z</var> = <var>z</var>^2 + <var>c</var> &#64; <var>i</var> = 1:100}</code></p>
        <p>你不应忘记切换到"Complex"模式.然后你可以绘制结果:</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Map</span>{<b>abs</b>(<b>f</b>(0; <var>x</var> + 1i*<var>y</var>)) &#64; <var>x</var> = -1.5:0.5 & <var>y</var> = -1:1}</code></p>
        <p style="text-align:center;"><img alt="Mandelbrot" src="Images/Mandelbrot.png" width="500"></p>

        <h3 id="TOC_409">单位</h3>
        <p>Calcpad提供了对物理单位的全面支持.当前版本支持公制(国际单位制和兼容单位制)、美制和英制单位.有七个基本单位对应于七个物理维度:</p>
        <ul>
            <li>质量 - 千克(<i>kg</i>)</li>
            <li>长度 - 米(<i>m</i>)</li>
            <li>时间 - 秒(<i>s</i>)</li>
            <li>电流 - 安培(<i>A</i>)</li>
            <li>温度 - 摄氏度(<i>°C</i>)</li>
            <li>物质的量 - 摩尔(<i>mol</i>)</li>
            <li>光强 - 坎德拉(<i>cd</i>)</li>
        </ul>
        <p>所有其他单位都是派生单位.它们是通过相应的物理定律得到的.例如,力 = 质量&middot;加速度,所以牛顿是通过 <i>N</i> = <i>kg</i>&middot;<i>m</i>/<i>s</i><sup>2</sup> 得到的.单位的倍数也可以通过在单位名称后添加相应的前缀来表示.例如,<i>kN</i> = 10<sup>3</sup>&thinsp;<i>N</i>,<i>MN</i> = 10<sup>6</sup>&thinsp;<i>N</i>等等.</p>
        <p>此外,还有一些“无量纲”单位,如百分比、千分比和角度(度、弧度等),它们不包含任何物理维度.然而,角度存在于一个特殊的(第八个)非物理维度中,以避免在混合时被取消和转换为百分比(这将很奇怪).</p>
        <p>你可以在数字后面输入单位名称来附加单位,例如 15&thinsp;<i>kg</i>.然后,你可以像其他值一样在表达式中使用它们.单位的取消和转换在计算过程中会自动进行.例如,以下表达式将被计算为:</p>
        1
        <table border="1">
            <thead>
                <tr>
                    <th>
                        Code(代码)
                    </th>
                    <th>
                        Output(结果)
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="line-height:180%;">
                        <code>'距离 -'<var>s</var>_1 = 50<i>m</i></code><br />
                        <code>'时间 -'<var>t</var>_1 = 2<i>s</i></code><br />
                        <code>'速度 -'<var>V</var> = <var>s</var>_1/<var>t</var>_1|<i>km</i>/<i>h</i></code><br />
                        <code>'运动的距离'<var>t</var>_2 = 5<i>s</i>'?</code><br />
                        <code><var>s</var>	_2 = <var>V</var>*<var>t</var>_2|<i>m</i></code>
                    </td>
                    <td style="line-height:150%;">
                        距离 - <var>s</var><sub>1</sub> = 50&thinsp;<i>m</i><br />
                        时间 - <var>t</var><sub>1</sub> = 2&thinsp;<i>s</i><br />
                        速度 - <var>V</var> = <var>s</var><sub>1</sub>/<var>t</var><sub>1</sub> = 50&thinsp;<i>m</i>/2&thinsp;<i>s</i> = 90&thinsp;<i>km</i>/<i>h</i><br />
                        时间<var>t</var><sub>2</sub>内运动的距离 = 5&thinsp;<i>s</i> ? <br />
                        <var>s</var><sub>2</sub> = <var>V</var>·<var>t</var><sub>2</sub> = 90&thinsp;<i>km</i>/<i>h</i>·5&thinsp;<i>s</i> = 125&thinsp;<i>m</i>
                    </td>
                </tr>
            </tbody>
        </table>

        <h4>内置单位</h4>
        <p>Calcpad包含大量内置单位:</p>
        <p>无量纲单位:</p>
        <ul>
            <li>
                部分:
                <i title="百分比">%</i>,
                <i title="千分之一">‰</i>,
                <i title="permyriad">‱</i>,
                <i title="per 100 000">pcm</i>,
                <i title="per million">ppm</i>,
                <i title="per billion">ppb</i>,
                <i title="per trillion">ppt</i>,
                <i title="per quadrillion">ppq</i>;
            </li>
            <li>
                角度:
                <i title="度">°</i>,
                <i title="分">′</i>,
                <i title="秒">″</i>,
                <i title="度">deg</i>,
                <i title="弧度">rad</i>,
                <i title="grades">grad</i>,
                <i title="revolutions">rev</i>;
            </li>
        </ul>
        <p>米制单位 (SI标准制及相容单位):</p>
        <ul>
            <li>
                质量:
                <i title="克">g</i>,
                <i title="百克">hg</i>,
                <i title="千克">kg</i>,
                <i title="吨">t</i>,
                <i title="千吨">kt</i>,
                <i title="兆吨">Mt</i>,
                <i title="吉吨">Gt</i>,
                <i title="分克">dg</i>,
                <i title="厘克">cg</i>,
                <i title="毫克">mg</i>,
                <i title="微克">μg</i>,
                <i title="纳克">ng</i>,
                <i title="pico克">pg</i>,
                <i title="Dal吨">Da</i> (或
                <i title="Dal吨(alt)">u</i>);
            </li>
            <li>
                长度:
                <i title="米">m</i>,
                <i title="千米">km</i>,
                <i title="分米">dm</i>,
                <i title="厘米">cm</i>,
                <i title="毫米">mm</i>,
                <i title="微米">μm</i>,
                <i title="纳米">nm</i>,
                <i title="pico米">pm</i>,
                <i title="宇宙单位">AU</i>,
                <i title="光年">ly</i>;
            </li>
            <li>
                时间:
                <i title="秒">s</i>,
                <i title="毫秒">ms</i>,
                <i title="微秒">μs</i>,
                <i title="纳秒">ns</i>,
                <i title="pico秒">ps</i>,
                <i title="分钟">min</i>,
                <i title="小时">h</i>,
                <i title="天">d</i>,
                <i title="周">w</i>,
                <i title="年">y</i>;
            </li>
            <li>
                频率:
                <i title="赫兹">Hz</i>,
                <i title="千赫兹">kHz</i>,
                <i title="兆赫兹">MHz</i>,
                <i title="吉赫兹">GHz</i>,
                <i title="tera赫兹">THz</i>,
                <i title="毫赫兹">mHz</i>,
                <i title="微赫兹">μHz</i>,
                <i title="纳赫兹">nHz</i>,
                <i title="tera赫兹">pHz</i>,
                <i title="转每分种">rpm</i>;
            </li>
            <li>
                速度:
                <i title="千米每小时">kmh</i>;
            </li>
            <li>
                电流:
                <i title="安培">A</i>,
                <i title="千安">kA</i>,
                <i title="兆安">MA</i>,
                <i title="吉安">GA</i>,
                <i title="tera安">TA</i>,
                <i title="毫安">mA</i>,
                <i title="微安">μA</i>,
                <i title="纳安">nA</i>,
                <i title="pico安">pA</i>;
            </li>
            <li>
                温度:
                <i title="摄氏度">°C</i>,
                <i title="摄氏度温差">Δ°C</i>,
                <i title="开尔文">K</i>;
            </li>
            <li>
                物质量:
                <i title="摩尔">mol</i>;
            </li>
            <li>
                光强:
                <i title="坎德拉">cd</i>;
            </li>
            <li>
                面积:
                <i title="公亩">a</i>,
                <i title="十are">daa</i>,
                <i title="hectare">ha</i>;
            </li>
            <li>
                体积:
                <i title="升">L</i>,
                <i title="十升">daL</i>,
                <i title="百升">hL</i>,
                <i title="分升">dL</i>,
                <i title="厘升">cL</i>,
                <i title="毫升">mL</i>,
                <i title="微升">μL</i>,
                <i title="纳升">nL</i>,
                <i title="pico升">pL</i>;
            </li>
            <li>
                力:
                <i title="牛顿">N</i>,
                <i title="十牛">daN</i>,
                <i title="百牛">hN</i>,
                <i title="千牛">kN</i>,
                <i title="兆牛">MN</i>,
                <i title="吉牛">GN</i>,
                <i title="tera牛">TN</i>,
                <i title="克-力">gf</i>,
                <i title="千克-力">kgf</i>,
                <i title="吨-力">tf</i>,
                <i title="dyne">dyn</i>;
            </li>
            <li>
                力矩:
                <i title="牛-米">Nm</i>,
                <i title="千牛-米">kNm</i>;
            </li>
            <li>
                压强:
                <i title="帕斯卡">Pa</i>,
                <i title="十帕">daPa</i>,
                <i title="百帕">hPa</i>,
                <i title="千帕">kPa</i>,
                <i title="兆帕">MPa</i>,
                <i title="吉帕">GPa</i>,
                <i title="tera帕">TPa</i>,<br />
                &emsp;&emsp;
                <i title="分帕">dPa</i>,
                <i title="厘帕">cPa</i>,
                <i title="微帕">mPa</i>,
                <i title="毫帕">μPa</i>,
                <i title="纳帕">nPa</i>,
                <i title="pico帕">pPa</i>,<br />
                &emsp;&emsp;
                <i title="巴">bar</i>,
                <i title="毫巴">mbar</i>,
                <i title="微巴">μbar</i>,
                <i title="大气压">atm</i>,
                <i title="technical大气压">at</i>,
                <i title="Torr">Torr</i>,
                <i title="毫米水银">mmHg</i>;
            </li>
            <li>
                黏度:
                <i title="Poise">P</i>,
                <i title="厘poise">cP</i>,
                <i title="Stokes">St</i>,
                <i title="厘stokes">cSt</i>;
            </li>
            <li>
                能量功:
                <i title="焦耳">J</i>,
                <i title="千焦">kJ</i>,
                <i title="兆焦">MJ</i>,
                <i title="吉焦">GJ</i>,
                <i title="tera焦">TJ</i>,
                <i title="毫焦">mJ</i>,
                <i title="微焦">μJ</i>,
                <i title="纳焦">nJ</i>,
                <i title="pico焦">pJ</i>,<br />
                &emsp;&emsp;&emsp;
                <i title="瓦-时">Wh</i>,
                <i title="千瓦-时">kWh</i>,
                <i title="兆瓦-时">MWh</i>,
                <i title="吉瓦-时">GWh</i>,
                <i title="tera瓦-时">TWh</i>,
                <i title="毫瓦-时">mWh</i>,
                <i title="微瓦-时">μWh</i>,
                <i title="纳瓦-时">nWh</i>,
                <i title="pico瓦-时">pWh</i>,<br />
                &emsp;&emsp;&emsp;
                <i title="electron伏特">eV</i>,
                <i title="千electron伏特">keV</i>,
                <i title="兆electron伏特">MeV</i>,
                <i title="吉electron伏特">GeV</i>,
                <i title="teraelectron伏特">TeV</i>,
                <i title="petaelectron伏特">PeV</i>,
                <i title="exaelectron伏特">EeV</i>,
                <i title="卡路里">cal</i>,
                <i title="千卡">kcal</i>,
                <i title="erg">erg</i>;
            </li>
            <li>
                功率:
                <i title="瓦特">W</i>,
                <i title="千瓦">kW</i>,
                <i title="兆瓦">MW</i>,
                <i title="吉瓦">GW</i>,
                <i title="tera瓦">TW</i>,
                <i title="毫瓦">mW</i>,
                <i title="微瓦">μW</i>,
                <i title="纳瓦">nW</i>,
                <i title="pico瓦">pW</i>,
                <i title="马力 (metric)">hpM</i>,
                <i title="马力 (metric)">ks</i>,<br />
                &emsp;&emsp;
                <i title="伏-安">VA</i>,
                <i title="千伏-安">kVA</i>,
                <i title="兆伏-安">MVA</i>,
                <i title="吉伏-安">GVA</i>,
                <i title="tera伏-安">TVA</i>,
                <i title="毫伏-安">mVA</i>,
                <i title="微伏-安">μVA</i>,
                <i title="纳伏-安">nVA</i>,
                <i title="pico伏-安">pVA</i>,<br />
                &emsp;&emsp;
                <i title="伏-安 (reactive)">VAR</i>,
                <i title="千伏-安 (reactive)">kVAR</i>,
                <i title="兆伏-安 (reactive)">MVAR</i>,
                <i title="吉伏-安 (reactive)">GVAR</i>,
                <i title="tera伏-安 (reactive)">TVAR</i>,
                <i title="毫伏-安 (reactive)">mVAR</i>,
                <i title="微伏-安 (reactive)">μVAR</i>,
                <i title="纳伏-安 (reactive)">nVAR</i>,
                <i title="pico伏-安 (reactive)">pVAR</i>;
            </li>
            <li>
                电量:
                <i title="库伦">C</i>,
                <i title="千库伦">kC</i>,
                <i title="兆库伦">MC</i>,
                <i title="吉库伦">GC</i>,
                <i title="tera库伦">TC</i>,
                <i title="毫库伦">mC</i>,
                <i title="微库伦">μC</i>,
                <i title="纳库伦">nC</i>,
                <i title="pico库伦">pC</i>,
                <i title="安-时">Ah</i>,
                <i title="毫安-时">mAh</i>;
            </li>
            <li>
                电势:
                <i title="伏特">V</i>,
                <i title="千伏特">kV</i>,
                <i title="兆伏特">MV</i>,
                <i title="吉伏特">GV</i>,
                <i title="tera伏特">TV</i>,
                <i title="毫伏特">mV</i>,
                <i title="微伏特">μV</i>,
                <i title="纳伏特">nV</i>,
                <i title="pico伏特">pV</i>;
            </li>
            <li>
                电容:
                <i title="法拉">F</i>,
                <i title="千法拉">kF</i>,
                <i title="兆法拉">MF</i>,
                <i title="吉法拉">GF</i>,
                <i title="tera法拉">TF</i>,
                <i title="毫法拉">mF</i>,
                <i title="微法拉">μF</i>,
                <i title="纳法拉">nF</i>,
                <i title="pico法拉">pF</i>;
            </li>
            <li>
                电阻:
                <i title="欧姆">Ω</i>,
                <i title="千欧姆">kΩ</i>,
                <i title="兆欧姆">MΩ</i>,
                <i title="吉欧姆">GΩ</i>,
                <i title="tera欧姆">TΩ</i>,
                <i title="毫欧姆">mΩ</i>,
                <i title="微欧姆">μΩ</i>,
                <i title="纳欧姆">nΩ</i>,
                <i title="pico欧姆">pΩ</i>;
            </li>
            <li>
                电导:
                <i title="西门子">S</i>,
                <i title="千西门子">kS</i>,
                <i title="兆西门子">MS</i>,
                <i title="吉西门子">GS</i>,
                <i title="tera西门子">TS</i>,
                <i title="毫西门子">mS</i>,
                <i title="微西门子">μS</i>,
                <i title="纳西门子">nS</i>,
                <i title="pico西门子">pS</i>,<br />
                &emsp;&emsp;
                <i title="mho">℧</i>,
                <i title="千mho">k℧</i>,
                <i title="兆mho">M℧</i>,
                <i title="吉mho">G℧</i>,
                <i title="teramho">T℧</i>,
                <i title="毫mho">m℧</i>,
                <i title="微mho">μ℧</i>,
                <i title="纳mho">n℧</i>,
                <i title="picomho">p℧</i>;
            </li>
            <li>
                磁通量:
                <i title="韦伯">Wb </i>,
                <i title="千韦伯">kWb</i>,
                <i title="兆韦伯">MWb</i>,
                <i title="吉韦伯">GWb</i>,
                <i title="tera韦伯">TWb</i>,
                <i title="毫韦伯">mWb</i>,
                <i title="微韦伯">μWb</i>,
                <i title="纳韦伯">nWb</i>,
                <i title="pico韦伯">pWb</i>;
            </li>
            <li>
                磁感应强度/磁通量密度/磁通密度:
                <i title="特斯拉">T</i>,
                <i title="千特斯拉">kT</i>,
                <i title="兆特斯拉">MT</i>,
                <i title="吉特斯拉">GT</i>,
                <i title="tera特斯拉">TT</i>,
                <i title="毫特斯拉">mT</i>,
                <i title="微特斯拉">μT</i>,
                <i title="纳特斯拉">nT</i>,
                <i title="pico特斯拉">pT</i>;
            </li>
            <li>
                电感:
                <i title="亨利">H</i>,
                <i title="千亨利">kH</i>,
                <i title="兆亨利">MH</i>,
                <i title="吉亨利">GH</i>,
                <i title="tera亨利">TH</i>,
                <i title="毫亨利">mH</i>,
                <i title="微亨利">μH</i>,
                <i title="纳亨利">nH</i>,
                <i title="pico亨利">pH</i>;
            </li>
            <li>
                光通量:
                <i title="流明">lm</i>;
            </li>
            <li>
                照度/照明度:
                <i title="勒克斯">lx</i>;
            </li>
            <li>
                放射性活度:
                <i title="贝克勒尔">Bq</i>,
                <i title="千贝克勒尔">kBq</i>,
                <i title="兆贝克勒尔">MBq</i>,
                <i title="吉贝克勒尔">GBq</i>,
                <i title="tera贝克勒尔">TBq</i>,
                <i title="毫贝克勒尔">mBq</i>,
                <i title="微贝克勒尔">μBq</i>,
                <i title="纳贝克勒尔">nBq</i>,
                <i title="pico贝克勒尔">pBq</i>,
                <i title="Curie">Ci</i>,
                <i title="Rutherford">Rd</i>;
            </li>
            <li>
                吸收剂量:
                <i title="格雷">Gy</i>,
                <i title="千格雷">kGy</i>,
                <i title="兆格雷">MGy</i>,
                <i title="吉格雷">GGy</i>,
                <i title="tera格雷">TGy</i>,
                <i title="毫格雷">mGy</i>,
                <i title="微格雷">μGy</i>,
                <i title="纳格雷">nGy</i>,
                <i title="pico格雷">pGy</i>;
            </li>
            <li>
                等效剂量:
                <i title="Sievert">Sv</i>,
                <i title="千sievert">kSv</i>,
                <i title="兆sievert">MSv</i>,
                <i title="吉sievert">GSv</i>,
                <i title="terasievert">TSv</i>,
                <i title="毫sievert">mSv</i>,
                <i title="微sievert">μSv</i>,
                <i title="纳sievert">nSv</i>,
                <i title="picosievert">pSv</i>;
            </li>
            <li>
                催化活性:
                <i title="katal">kat</i>;
            </li>
        </ul>
        <p>非米制单位 (英制/美制):</p>
        <ul>
            <li>
                质量:
                <i title="grain">gr</i>,
                <i title="drachm">dr</i>,
                <i title="盎司">oz</i>,
                <i title="磅">lb</i> (或
                <i title="磅-质量">lbm</i>,
                <i title="磅-质量 (alt)">lb</i><sub>_m</sub>),
                <i title="千磅-质量">kipm</i>(或
                <i title="千磅-质量 (alt)">kip</i><sub>_m</sub>),
                <i title="stone">st</i>,
                <i title="quarter">qr</i>,<br />&emsp;&emsp;&ensp;
                <i title="hundredweight">cwt</i>(或
                <i title="hundredweight (UK)">cwt</i><sub>_UK</sub>,
                <i title="hundredweight (US)">cwt</i><sub>_US</sub>),
                <i title="吨">ton</i> (或
                <i title="吨 (UK)">ton</i><sub>_UK</sub>,
                <i title="吨 (US)">ton</i><sub>_US</sub>),
                <i title="slug">slug</i>;
            </li>
            <li>
                长度:
                <i title="thou">th</i>,
                <i title="inch">in</i>,
                <i title="foot">ft</i>,
                <i title="yard">yd</i>,
                <i title="chain">ch</i>,
                <i title="furlong">fur</i>,
                <i title="mile">mi</i>,
                <i title="fathom">ftm</i>(或
                <i title="fathom (UK)">ftm</i><sub>_UK</sub>,
                <i title="fathom (US)">ftm</i><sub>_US</sub>),
                <br />&emsp;&emsp;&ensp;&ensp;
                <i title="cable">cable</i>(或
                <i title="cable (UK)">cable</i><sub>_UK</sub>,
                <i title="cable (US)">cable</i><sub>_US</sub>),
                <i title="nautical mile">nmi</i>,
                <i title="link">li</i>,
                <i title="rod">rod</i>,
                <i title="pole">pole</i>,
                <i title="perch">perch</i>,
                <i title="league">lea</i>;
            </li>
            <li>
                速度:
                <i title="英里每小时">mph</i>,
                <i title="节">knot</i>;
            </li>
            <li>
                温度:
                <i title="华氏度">°F</i>,
                <i title="华氏度°F差">Δ°F</i>,
                <i title="Rankine度">°R</i>;
            </li>
            <li>
                面积:
                <i title="rood">rood</i>,
                <i title="acre">ac</i>;
            </li>
            <li>
                液体体积:
                <i title="fluid 盎司">fl_oz</i>,
                <i title="gill">gi</i>,
                <i title="pint">pt</i>,
                <i title="quart">qt</i>,
                <i title="gallon">gal</i>,
                <i title="barrel">bbl</i>, 或:
                <br />&emsp;&emsp;&emsp;&emsp;
                <i title="fluid 盎司 (UK)">fl_oz</i><sub>_UK</sub>,
                <i title="gill (UK)">gi</i><sub>_UK</sub>,
                <i title="pint (fluid, UK)">pt</i><sub>_UK</sub>,
                <i title="quart (fluid, UK)">qt</i><sub>_UK</sub>,
                <i title="gallon (fluid, UK)">gal</i><sub>_UK</sub>,
                <i title="barrel (fluid, UK)">bbl</i><sub>_UK</sub>,
                <br />&emsp;&emsp;&emsp;&emsp;
                <i title="fluid 盎司 (US)">fl_oz</i><sub>_US</sub>,
                <i title="gill (US)">gi</i><sub>_US</sub>,
                <i title="pint (fluid, US)">pt</i><sub>_US</sub>,
                <i title="quart (fluid, US)">qt</i><sub>_US</sub>,
                <i title="gallon (fluid, US)">gal</i><sub>_US</sub>,
                <i title="barrel (fluid, US)">bbl</i><sub>_US</sub>;
            </li>
            <li>
                干体积:
                (US)<i title="pint (dry, US)">pt</i><sub>_dry</sub>,
                (US)<i title="quart (dry, US)">qt</i><sub>_dry</sub>,
                (US)<i title="gallon (dry, US)">gal</i><sub>_dry</sub>,
                (US)<i title="barrel (dry, US)">bbl</i><sub>_dry</sub>,
                <br />&emsp;&emsp;&emsp;
                <i title="peck">pk</i> (或
                <i title="peck (dry, UK)">pk</i><sub>_UK</sub>,
                <i title="peck (dry, US)">pk</i><sub>_US</sub>),
                <i title="bushel">bu</i> (或
                <i title="bushel (dry, UK)">bu</i><sub>_UK</sub>,
                <i title="bushel (dry, US)">bu</i><sub>_US</sub>);
                (US) <i title="pint (dry, US)">pt</i><sub>_dry</sub>,
                (US) <i title="quart (dry, US)">qt</i><sub>_dry</sub>,
                (US) <i title="gallon (dry, US)">gal</i><sub>_dry</sub>,
                (US) <i title="barrel (dry, US)">bbl</i><sub>_dry</sub>,
                <br />&emsp;&emsp;&emsp;
                <i title="peck">pk</i> (或
                <i title="peck (UK)">pk</i><sub>_UK</sub>,
                <i title="peck (US)">pk</i><sub>_US</sub>),
                <i title="bushel">bu</i> (或
                <i title="bushel (UK)">bu</i><sub>_UK</sub>,
                <i title="bushel (US)">bu</i><sub>_US</sub>);
            </li>
            <li>
                力:
                <i title="盎司-力">ozf</i> (或
                <i title="盎司-力 (alt)">oz</i><sub>_f</sub>),
                <i title="磅-力">lbf</i> (或
                <i title="磅-力 (alt)">lb</i><sub>_f</sub>),
                <i title="千磅">kip</i> (或
                <i title="千磅-力">kipf</i>,
                <i title="千磅-力 (alt)">kip</i><sub>_f</sub>),
                <i title="吨-力">tonf</i> (or
                <i title="吨-力 (alt)">ton</i><sub>_f</sub>),
                <i title="poundal">pdl</i>;
            </li>
            <li>
                压强:
                <i title="盎司-力每平方inch">osi</i>,
                <i title="盎司-力每平方foot">osf</i>
                <i title="磅-力每平方inch">psi</i>,
                <i title="磅-力每平方foot">psf</i>,
                <i title="千磅-力每平方inch">ksi</i>,
                <i title="千磅-力每平方foot">ksf</i>,
                <i title="吨-力每平方inch">tsi</i>,
                <i title="吨-力每平方foot">tsf</i>,
                <i title="inches of mercury (conventional)">inHg</i>;
            </li>
            <li>
                能量/功:
                <i title="英制热单位">BTU</i>,
                <i title="萨姆">therm</i>, <span class="b">(</span>or
                <i title=" 萨姆(UK)">therm</i><sub>_UK</sub>,
                <i title="萨姆 (US)">therm</i><sub>_US</sub><span class="b">)</span>,
                <i title="quad">quad</i>;
            </li>
            <li>
                功率:
                <i title="马力">hp</i>,
                <i title="马力(电)">hpE</i>,
                <i title="马力(锅炉)">hpS</i>.
            </li>
            <li>
                能量/功:
                <i title="英国热单位">BTU</i>,
                <i title="therm">therm</i> (or
                <i title="therm (UK)">therm</i><sub>_UK</sub>,
                <i title="therm (US)">therm</i><sub>_US</sub>),
                <i title="quad">quad</i>;
            </li>
            <li>
                功率:
                <i title="horsepower">hp</i>,
                <i title="horsepower (电力)">hpE</i>,
                <i title="horsepower (锅炉)">hpS</i>.
            </li>
        </ul>
        <p>角度单位适用于三角函数,并覆盖所有其他设置.反三角函数默认返回无单位的值.如果您希望它们返回当前单位的结果,您需要定义一个变量:<var>ReturnAngleUnits</var> = 1.</p>
        <p>紧跟数字后面的文字被解析为单位,例如"2&thinsp;<i>m</i>".独立的文字可以是单位或变量,例如"<i>N</i>*<i>m</i>".解析的规则如下:如果一个文字没有被定义为变量,它会被解析为单位.否则,它会被解析为变量,即使存在同名的单位.如果在文字前面加上一个点,即使存在同名的变量,它也会被解析为单位,例如".<i>N</i>*.<i>m</i>".</p>

        <h4>自定义单位</h4>
        <p>您可以定义自己的"自定义"单位,并像其他单位一样在代码中使用它们.定义单位类似于定义变量,但名称必须以点"."为前缀:</p>
        <p>&emsp;&emsp;<code>.<i>单位名称</i> = 表达式</code></p>
        <p>名称可以包括一些货币符号,如:€, £, ₤, ¥, ¢, ₽, ₹, ₩, ₪.如果您需要创建从其他单位派生的单位,可以在右侧使用数字和单位编写表达式.您还可以通过将第一个单位设置为 "= 1" 并将其他单位设置为倍数来定义无量纲单位,例如货币(USD、EUR、€、₤)或信息(bit、byte、KiB 等).例如:</p>
        <p>
            <code>
                &emsp;&emsp;.<i>bit</i> = 1<br />
                &emsp;&emsp;.<i>byte</i> = 8*<i>bit</i><br />
                &emsp;&emsp;.<i>KiB</i> = 1024*<i>byte</i><br />
                &emsp;&emsp;...
            </code>
        </p>
        <p>自定义无量纲单位存在于特殊的(第九个)非物理维度中.这样它们在混合时不会被取消或转换为其他无量纲单位,比如百分比或角度.然而,如果您在一个文件中有两种类型的无量纲单位,它们将存在于同一个维度中,所以您应该避免混合使用它们.</p>
        <h3 id="TOC_410">向量</h3>
        <p><b>向量的内部存储及类型</b></p>
        <p>Calcpad中包含2种类型的向量: 常规(小)的和大的.向量可以仅包含带单位的实数.现版本不支持复数向量 . 单个向量可以包含带不同类型的单位的元素,甚至不同量纲. 然而,一些向量函数或运算可能由于不同元素间单位的冲突而无法运行.</p>
        <p>超过100个元素的向量为”大“. 整体上它们与常规的向量无异,用户感知差异不强. 但从内在机制上,它们的运行机制殊异. 大向量的结构如下图所示:</p>
        <p><img width="500" src="Images/Vector.png"></p>
        <p>向量由其完整的"数学" 长度所定义,但起初没有为它预留内存.向量长度通过<b>len</b>(<var><span class="vec">⃗</span>v</var>) 函数获取. 非零元素的最大索引号决定了向量的内在长度. 该长度可用 <b>size</b>(<var><span class="vec">⃗</span>v</var>) 函数获取. 非零元素以外的元素为0,因此程序无需将它们存储到内存. 访问这些元素时,直接返回0.</p>
        <p>上述处理使得程序可以高效处理稀疏向量. 在工程计算这种向量很常见,例如有限元分析中的荷载向量. 不过, Calcpad在上述长度基础上预留了一部分内存, 称为 "容量". 这是因为重新调整向量的长度在计算上消耗巨大. 由于我们一般在一个循环内对元素赋值, 这种条件下我们避免了每次迭代重新调整向量长度.</p>
        <p><b>定义</b></p>
        <p>可用如下语法定义向量:</p>
        <p>&emsp;&emsp;<var><span class="vec">⃗</span>a</var> = [<var>a</var><sub>1</sub>; <var>a</var><sub>2</sub>; <var>a</var><sub>3</sub>; … ;<var>a</var><sub>i</sub>; … ;<var>a</var><sub>n</sub>]</p>
        <p>向量各个元素的值可以用含变量,运算符,函数等的表达式来明确. 例如:</p>
        <p>&emsp;&emsp;<code><var>a</var> = [cos(0); 2; 3; 2*2; 6 - 1]</code>' = [1&ensp;2&ensp;3&ensp;4&ensp;5].</p>
        <p>也可以在上述列表中包含其他向量. 它们的元素将按顺序各自包含其中, 例如:</p>
        <p>&emsp;&emsp;<code><var>b</var> = [0; <var>a</var>; 6; 7; 8]</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5&ensp;6&ensp;7&ensp;8].</p>
        <p>如果包含矩阵, 元素将依次接续所有的行元素. 向量也可定义为函数,这样它们可以根据输入的特定参数自动生成元素. 例如:</p>
        <p>
            &emsp;&emsp;<code><var>a</var>(<var>x</var>) = [1; <var>x</var>; <var>x</var>^2; <var>x</var>^3; <var>x</var>^4]</code><br />
            &emsp;&emsp;<code><var>a</var>(2)</code>' =  [1&ensp;2&ensp;4&ensp;8&ensp;16]
        </p>
        <p>除了方括号[],也可以用如下创建相关函数定义向量:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = <b>vector</b>(5)</code>' = [0&ensp;0&ensp;0&ensp;0&ensp;0] - 创建一个包含5个元素的空向量;<br />
            &emsp;&emsp;<code><b>fill</b>(<var>a</var>; 5)</code>' = [5&ensp;5&ensp;5&ensp;5&ensp;5] - 用 5填充向量;<br />
            &emsp;&emsp;<code><var>a</var> = <b>range</b>(0; 10; 2)</code>' = [0&ensp;2&ensp;4&ensp;6&ensp;8&ensp;10] - 创建一个元素值始于0终于10步幅2的向量.
        </p>
        <p><b>索引</b></p>
        <p>可以通过索引访问向量的单个元素用于读取或写入. 你需要明确向量名称,后面时".",再后面是索引号. 第一个元素索引号为1. 索引号可以是1个数, 或表达式. 当为后者时表达式必须以括号括起来. 示例:
        <p>
            &emsp;&emsp;<code><var>a</var> = [2; 4; 6; 8; 10]</code><br />
            &emsp;&emsp;<code><var>a</var>.2</code>' = 4<br />
            &emsp;&emsp;<code><var>k</var> = 3', '<var>a</var>.<var>k</var></code>' = <var><span class="vec">⃗</span>a</var><sub>3</sub> = 6<br />
            &emsp;&emsp;<code><var>a</var>.(2*<var>k</var> - 1)</code>' = <var><span class="vec">⃗</span>a</var><sub>5</sub> = 10
        </p>
        <p>
            若索引值 &lt;1 或大于向量长度 <b>len</b>(<var><span class="vec">⃗</span>a</var>), 程序将报错: <span class="err">索引超限</span>. 你可以用索引来对循环嵌套(块或单行的)中的向量初始化. 为此,必须将循环次数包括到索引中. 例如:
        </p>
        <p>
            &emsp;&emsp;<code><var>a</var> = <b>vector</b>(6)','<var>b</var> = <b>vector</b>(6)</code><br />
            &emsp;&emsp;<code>'循环块</code><br />
            &emsp;&emsp;<code>#for <var>k</var> = 1 : <b>len</b>(<var>a</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code><var>a</var>.<var>k</var> = <var>k</var>^2</code><br />
            &emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>'单行循环</code><br />
            &emsp;&emsp;<code>$Repeat{<var>b</var>.<var>k</var> = <var>a</var>.(<var>k</var> - 1) @ <var>k</var> = 2 : <b>len</b>(<var>b</var>)}</code><br />
        </p>
        <p>以上代码将生成下列2个向量:</p>
        <p>
            &emsp;&emsp;<var><span class="vec">⃗</span>a</var> = [1&ensp;4&ensp;9&ensp;16&ensp;25&ensp;36] 和<br />
            &emsp;&emsp;<var><span class="vec">⃗</span>b</var> = [0&ensp;1&ensp;4&ensp;9&ensp;16&ensp;25].
        </p>

        <p><b>结构相关函数</b></p>
        <p>包含所有读取或调整向量结构的函数. 这意味着结果不取决于向量内容,即元素值.Calcpad支持下列函数:</p>

        <p>&emsp;&emsp;<code><b>len</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 向量长度 <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;表示向量的完整长度(即元素数量).<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>len</b>([1; 0; 2; 3])</code>' = 4
        </p>

        <p>&emsp;&emsp;<code><b>size</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 向量的内部存储长度 <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">若 <var><span class="vec">⃗</span>a</var> 为1个大向量,则返回最后1个非零元素的索引号,否则返回向量的长度.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>a</var> = <b>vector</b>(200)<br />
                    <var>a</var>.35 = 1<br /><b>len</b>(<var>a</var>)
                </code>' = 200<br />
                <code><b>size</b>(<var>a</var>)</code>' = 35<br />
                <code><b>size</b>([1; 2; 3; 0; 0])</code>' = 5
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>resize</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 向量;<br />
                <var>n</var> - (正整数)向量 <var><span class="vec">⃗</span>a</var>的新长度.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;调整长度后的向量 <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">通过原位调整设置向量 <var><span class="vec">⃗</span>a</var>的新长度为<var>n</var> 返回一个相同向量的索引作为结果.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>a</var> = [1; 2; 3; 4; 5]<br />
                    <var>b</var> = <b>resize</b>(<var>a</var>; <var>3</var>)
                </code>' = [1&ensp;2&ensp;3]<br />
                <code><var>a</var></code>' = [1&ensp;2&ensp;3]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;包含矩阵、向量和标量的列表.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;合并列表中的参量得到的1个新向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">列表可以包含无限个不同类型的项, 顺序随意. 矩阵首先会按照行号依次排列所有行元素,列向量类似.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = [1; 2|3; 4]<br />
                    <var>b</var> = [7; 8; 9]<br />
                    <var>c</var> = <b>join</b>(0; <var>A</var>; 5; 6; <var>b</var>)
                </code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5&ensp;6&ensp;7&ensp;8&ensp;9]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>slice</b>(<var><span class="vec">⃗</span>a</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 向量;<br />
                <var>i</var><sub>1</sub> - (正整数) 起始索引号;<br />
                <var>i</var><sub>2</sub> - (正整数) 终止索引号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">返回向量的 <var><span class="vec">⃗</span>v</var> 索引号 <var>i</var><sub>1</sub> 到 <var>i</var><sub>2</sub> (包含边界)的部分成为一个新向量;.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">不要求 <var>i</var><sub>1</sub> &le; <var>i</var><sub>2</sub>. 若第二索引号大于向量长度, 则所有的<var>i</var><sub>1</sub>后的元素都被包含.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>slice</b>([1; 2; 3; 4; 5; 6; 7; 8]; 3; 7)</code>' = [3&ensp;4&ensp;5&ensp;6&ensp;7]<br />
                <code><b>slice</b>([1; 2; 3; 4; 5; 6; 7; 8]; 6; 10)</code>' = [6&ensp;7&ensp;8]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>first</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>
                    <span class="vec">⃗</span>a
                </var> - 向量;<br />
                <var>n</var> - (正整数)返回向量的元素数量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;向量 <var><span class="vec">⃗</span>a</var>的前 <var>n</var>个元素组成的新向量;.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">若 <var>n</var>&gt;<var><span class="vec">⃗</span>a</var>的长度, 则所有元素将被返回. 与 <b>resize</b>不同, 原向量未被调整.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>first</b>([0; 1; 2; 3; 4; 5]; 3)</code>' = [0&ensp;1&ensp;2]<br />
                <code><b>first</b>([0; 1; 2; 3; 4; 5]; 10)</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>last</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 向量;<var>n</var> - 正整数.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;</span></a> -向量<var><span class="vec">⃗</span>a</var>的后 <var>n</var>个元素组成一个新向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;若 <var>n</var>&gt;<var><span class="vec">⃗</span>a</var>的长度, 则所有元素将被返回.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>last</b>([0; 1; 2; 3; 4; 5]; 3)</code>' = [3&ensp;4&ensp;5]<br />
                <code><b>last</b>([0; 1; 2; 3; 4; 5]; 10)</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 将要被提取元素的向量;<br />
                <var><span class="vec">⃗</span>i</var> - 将要从向量 <var><span class="vec">⃗</span>a</var>中提取元素的索引号组成的向量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;从向量 <var><span class="vec">⃗</span>a</var> 中提取元素组成一个新向量,元素的索引号包含在向量 <var><span class="vec">⃗</span>i</var>中.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">向量 <var><span class="vec">⃗</span>i</var>中所有索引号必须为正整数. 若某个索引号 &gt;向量<var><span class="vec">⃗</span>a</var>的长度, 将会报错:"<span class="err">索引号超出范围</span>".</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>a</var> = [0; 1; 2; 3; 4; 5; 6]</code><br />
                <code><b>extract</b>(<var>a</var>; [2; 4; 6])</code>' = [1&ensp;3&ensp;5]
            </span>
        </p>

        <p><b>数据相关函数</b></p>
        <p>该类函数将向量作为数值数据处理. 主要关系排序、排列、查找和计数. 与结构相关函数不同, 其结果依赖元素值. 程序支持以下函数:</p>

        <p>&emsp;&emsp;<code><b>sort</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 输入向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;对向量 <var><span class="vec">⃗</span>a</var> 的元素按升↑序排列后返回一个向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;向量 <var><span class="vec">⃗</span>a</var>的原内容不变.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>a</var> = [4; 0; 2; 3; -1; 1]<br /><var>b</var> = <b>sort</b>(<var>a</var>)</code>' = [-1&ensp;0&ensp;1&ensp;2&ensp;3&ensp;4]<br />
                <code><var>a</var></code>' = [4&ensp;0&ensp;2&ensp;3&ensp;-1&ensp;1]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>rsort</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 输入向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;对向量 <var><span class="vec">⃗</span>a</var> 的元素按降↓序排列后返回一个向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;与<b>sort</b>相似,向量 <var><span class="vec">⃗</span>a</var>的原内容不变.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>rsort</b>([4; 0; 2; 3; -1; 1])</code>' = 4&ensp;3&ensp;2&ensp;1&ensp;0&ensp;-1]
        </p>

        <p>&emsp;&emsp;<code><b>order</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 输入向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个带索引的向量,由向量 <var><span class="vec">⃗</span>a</var>的元素升↑序排列而生成.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">输出向量 <var><span class="vec">⃗</span>i</var> 中的每个元素显示<var><span class="vec">⃗</span>a</var>中相应位置的元素在 所有元素中排序的序号. 你可以通过调用函数 <b>extract</b>&hairsp;(&hairsp;<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>i</var> )输出完整的元素升↑序序列.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>a</var> = [4; 0; 2; 3; -1; 1]<br />
                    <var>i</var> = <b>order</b>(<var>a</var>)
                </code>' = [5&ensp;2&ensp;6&ensp;3&ensp;4&ensp;1]<br />
                <code><var>b</var> = <b>extract</b>(<var>a</var>; <var>i</var>)</code>' = [-1&ensp;0&ensp;1&ensp;2&ensp;3&ensp;4]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>revorder</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 输入向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个带索引的向量,由向量 <var><span class="vec">⃗</span>a</var>的元素降↓序排列而生成.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;其作用原理同 <b>order</b> 函数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>revorder</b>([4; 0; 2; 3; -1; 1])</code>' = [1&ensp;4&ensp;3&ensp;6&ensp;2&ensp;5]
        </p>

        <p>&emsp;&emsp;<code><b>reverse</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 输入向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个以逆转顺序包含向量<var><span class="vec">⃗</span>a</var> 元素的新向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;向量<var><span class="vec">⃗</span>a</var> 的原内容保持不变.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>reverse</b>([1; 2; 3; 4; 5])</code>' = [5&ensp;4&ensp;3&ensp;2&ensp;1]
        </p>

        <p>&emsp;&emsp;<code><b>count</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 向量;<br />
                <var>x</var> - (标量)要计数的值;<br />
                <var>i</var> - (正整数) 起始索引号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 向量 <var><span class="vec">⃗</span>a</var>中第 <var>i</var>个等于 <var>x</var>的元素（包含）以后的元素数量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;若<var>i</var> &gt;向量<var><span class="vec">⃗</span>a</var>的长度, 则返回0.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>count</b>([0; 1; 2; 1; 4; 1]; 1; 4)</code>' = 2
        </p>

        <p>&emsp;&emsp;<code><b>search</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 向量;<br />
                <var>x</var> - (标量) 要查找的值;<br />
                <var>i</var> - (正整数)起始索引号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 向量<var><span class="vec">⃗</span>a</var>中第 <var>i</var>个元素(包含)以后第一个= <var>x</var>的元素的索引号.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;若<var>i</var> &gt;向量<var><span class="vec">⃗</span>a</var>的长度或未找到该值, 则返回0.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang"><code><b>search</b>([0; 1; 2; 1; 4; 1]; 1; 3)</code>' = 4<br /><code><b>search</b>([0; 1; 2; 1; 4; 1]; 1; 7)</code>' = 0</span>
        </p>

        <p>&emsp;&emsp;<code><b>find</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - vector;<br />
                <var>x</var> - (标量) 要查找的值;<br />
                <var>i</var> - (正整数)起始索引号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">向量 <var><span class="vec">⃗</span>a</var>中第 after the <var>i</var> 个元素(包含)以后= <var>x</var><br />的所有元素的索引号构成的新向量.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">若<var>i</var> &gt;向量<var><span class="vec">⃗</span>a</var>的长度或未找到该值, 则返回1个空向量(长度为0).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang"><code><b>find</b>([0; 1; 2; 1; 4; 1]; 1; 2)</code>' = [2&ensp;4&ensp;6]<br /><code><b>find</b>([0; 1; 2; 1; 4; 1]; 3; 2)</code>' = []</span>
        </p>

        <p>&emsp;&emsp;<code><b>lookup</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - 包含搜素值的向量;<br />
                <var><span class="vec">⃗</span>b</var> - 包含返回值的向量;<br />
                <var>x</var> - (标量) 要搜索的值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个由向量 <var><span class="vec">⃗</span>b</var>中的部分元素组成的新向量, 这些元素在向量<var><span class="vec">⃗</span>a</var> 中对应的元素= <var>x</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">若该值未找到,则返回一个空向量(长度未0)</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang"><code><var>a</var> = [0; 1; 0; 0; 1; 1]<br /><var>b</var> = [1; 2; 3; 4; 5; 6]<br /><b>lookup</b>(<var>a</var>; <var>b</var>; 0)</code>' =  [1&ensp;3&ensp;4]<br /><code><b>lookup</b>(<var>a</var>; <var>b</var>; 2)</code>' = []</span>
        </p>

        <p><b>find</b> 和 <b>lookup</b> 函数的后缀不同,代表不同的对比操作符.可用的后缀列于下表:</p>
        <table class="bordered">
            <tr><th>后缀</th><th>find</th><th>lookup</th><th>对比操作符</th></tr>
            <tr><td><code>_eq</code></td><td><code><b>find_eq</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_eq</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>=</code> - 等于</td></tr>
            <tr><td><code>_ne</code></td><td><code><b>find_ne</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_ne</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>≠</code> - 不等于</td></tr>
            <tr><td><code>_lt</code></td><td><code><b>find_lt</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_lt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&lt;</code> - 小于</td></tr>
            <tr><td><code>_le</code></td><td><code><b>find_le</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_le</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&le;</code> - 小于等于</td></tr>
            <tr><td><code>_gt</code></td><td><code><b>find_gt</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_gt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&gt;</code> - 大于</td></tr>
            <tr><td><code>_ge</code></td><td><code><b>find_ge</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_ge</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&ge;</code> - 大于等于</td></tr>
        </table>

        <p><b>数学函数</b></p>
        <p>所有标准标量数学函数也接受向量参数.对于输入向量中的每个元素,函数将分别应用,并且将结果返回到相应的输出向量中.示例:</p>
        <p>&emsp;&emsp;<code><b>sin</b>([0; 30; 45; 90])</code>' = [0&ensp;0.5&ensp;0.707&ensp;1]</p>
        <p>Calcpad也包含几个向量专属数学函数:</p>

        <p>&emsp;&emsp;<code><b>norm_p</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;代表 向量 <var><span class="vec">⃗</span>a</var>的L<sub>p</sub> 范数的标量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;L<sub>p</sub> 范数通过下列方程得到: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub><var>p</var></sub> = <span class="b1">(</span><span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b><sup><var>p</var></sup><span class="b1">)</span><sup class="raised">1/<var>p</var></sup></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>norm_p</b>([1; 2; 3]; 3)</code>' = 3.3019
        </p>

        <p>&emsp;&emsp;<code><b>norm_1</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示向量<var><span class="vec">⃗</span>a</var>的L<sub>1</sub>范数的标量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;L<sub>1</sub>范数通过下列方程得到: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>1</sub> = <span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>norm_1</b>([-1; 2; 3])</code>' = 6
        </p>

        <p>&emsp;&emsp;<code><b>norm</b>(<var><span class="vec">⃗</span>a</var>)</code> 或 <code><b>norm_2</b>(<var><span class="vec">⃗</span>a</var>)</code> 或 <code><b>norm_e</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示向量<var><span class="vec">⃗</span>a</var>的L<sub>2</sub> (Euclidian)范数的标量 .<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;L<sub>2</sub> 范数通过下列方程得到: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>2</sub> = &emsp;<span class="o2"><span class="r2"></span><span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><var>a</var><sub><var>i</var></sub><sup>2</sup></span></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>norm_2</b>([1; 2; 3])</code>' = 3.7417
        </p>

        <p>&emsp;&emsp;<code><b>norm_i</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示向量 <var><span class="vec">⃗</span>a</var>的L<sub>∞</sub> (无穷)范数的标量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;L<sub>∞</sub> 范数通过下列方程得到: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>∞</sub> = max <b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>norm_i</b>([1; 2; 3]; 3)</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>unit</b>(<var><span class="vec">⃗</span>a</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;归一化向量 <var><span class="vec">⃗</span>a</var> (with L<sub>2</sub> 范数 ||<var><span class="vec">⃗</span>a</var>||<sub>2</sub> = 1).<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">归一化向量 <var><span class="vec">⃗</span>u</var> 的元素通过下式计算: <var>u</var><sub><var>i</var></sub> = <var>a</var><sub><var>i</var></sub> / ||<var>a</var>||<sub>2</sub></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>unit</b>([1; 2; 3])</code>' = [0.26726&ensp;0.53452&ensp;0.80178]
        </p>

        <p>&emsp;&emsp;<code><b>dot</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var>, <var><span class="vec">⃗</span>b</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;标量:表示2个向量 <var><span class="vec">⃗</span>a</var>&hairsp;&middot;<var><span class="vec">⃗</span>b</var>点积;<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;点积按下列表达式得到: <span class="eq"><var><span class="vec">⃗</span>a</var>&hairsp;&middot;<var><span class="vec">⃗</span>b</var> = <span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span> <var>a</var><sub><var>i</var></sub>&hairsp;&middot;<var>b</var><sub><var>i</var></sub></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>a</var> = [1; 2; 4]<br />
                    <var>b</var> = [5; 3; 1]<br />
                    <b>dot</b>(<var>a</var>; <var>b</var>)
                </code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cross</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>a</var>, <var><span class="vec">⃗</span>b</var> - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示叉积的向量 <var><span class="vec">⃗</span>c</var> = <var><span class="vec">⃗</span>a</var> &times; <var><span class="vec">⃗</span>b</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                该函数仅用于长度为2或3的向量.输出向量<var><span class="vec">⃗</span>c</var>的元素按下式计算:<br />
                <var>c</var><sub>1</sub> = <var>a</var><sub>2</sub>&hairsp;<var>b</var><sub>3</sub> &minus;  <var>a</var><sub>3</sub>&hairsp;<var>b</var><sub>2</sub><br />
                <var>c</var><sub>2</sub> = <var>a</var><sub>3</sub>&hairsp;<var>b</var><sub>1</sub> &minus;  <var>a</var><sub>1</sub>&hairsp;<var>b</var><sub>3</sub><br />
                <var>c</var><sub>3</sub> = <var>a</var><sub>1</sub>&hairsp;<var>b</var><sub>2</sub> &minus;  <var>a</var><sub>2</sub>&hairsp;<var>b</var><sub>1</sub><br />
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>a</var> = [1; 2; 4]<br />
                    <var>b</var> = [5; 3; 1]<br />
                    <b>cross</b>(<var>a</var>; <var>b</var>)
                </code>' = [-10&ensp;19&ensp;-7]
            </span>
        </p>

        <p><b>聚合和插值函数</b></p>
        <p>所有聚合函数都可以处理向量.由于它们是多变量的,每个聚合函数都可以接受一个单一的向量,也可以接受一个标量、向量和矩阵的混合列表,这些元素可以任意顺序排列.在这种情况下,所有参数都会被合并成一个单一的标量数组,从左到右依次排列.例如:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [0; 2; 6]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 3; 1]</code><br />
            &emsp;&emsp;<code><b>sum</b>(10; <var>a</var>; <var>b</var>; 11)</code>' = 38
        </p>
        <p>插值函数的行为类似,但第一个参数必须是标量,代表插值变量.例如:</p>
        &emsp;&emsp;
        <code><b>take</b>(3; <var>a</var>)</code>' = 6
        <br />
        &emsp;&emsp;
        <code><b>line</b>(1.5; <var>a</var>)</code>' = 1
        <br />
        &emsp;&emsp;
        <code><b>spline</b>(1.5; <var>a</var>)</code>' = 0.8125
        <br />
        <p>与聚合函数类似, 插值函数也接受变量的混合列表,例如:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [1; 2; 3]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 6; 7; 8]</code><br />
            &emsp;&emsp;<code><b>take</b>(7; <var>a</var>; 4;  <var>b</var>; 9; 10)</code>' = 7
        </p>
        <p>返回值为向量 <var><span class="vec">⃗</span>b</var>的第3个元素,但在最终序列中序号为7. 关于可用的聚合和插值函数完整列表在本手册前面给出 (见上文 "表达式/函数"部分).</p>

        <p><b>运算符</b></p>
        <p>所有运算符都可以用于向量.运算是逐元素进行的,结果返回到输出向量中.这也适用于乘法运算符.对乘法运算符同样如此.例如:</p>
        <p>&emsp;&emsp;<code>[2; 4; 5]*[2; 3; 4]</code>' = [4&ensp;12&ensp;20]</p>
        <p>在Calcpad中,如果两个向量的长度不同,较短的向量会用零填充到与较长向量相同的长度.点积和叉积在Calcpad中被实现为函数(如上所述).所有二元运算符都类似,支持向量-标量和标量-向量操作.例如:</p>
        <p>&emsp;&emsp;<code>[2; 4; 5]*2</code>' = [4&ensp;8&ensp;10]</p>

        <h3 id="TOC_411">矩阵</h3>
        <p><b>矩阵的内部存储和类型</b></p>
        <p>Calcpad 包含不同类型的矩阵:一般(矩形)和特殊(列、对称、对角、上/下三角).在内部,每种类型的矩阵以不同的方式实现,利用其特定结构来提高效率.在外部,它们的行为相似,只有少数例外情况.</p>
        <p>每种矩阵类型都以向量数组的形式实现,如下图所示.通常情况下,向量代表矩阵的行,但对角线和列矩阵除外.</p>
        <p><img width="800" src="Images/Matrices.png"></p>
        <p>Calcpad 使用大向量来存储值,因此不为部分填充(带状)矩阵存储额外的零元素.每种类型的索引运算符在内部被重新定义,以便在尝试读取矩阵结构或带宽之外的值时直接返回零.</p>
        <table>
            <tr><td>a) 对角矩阵 -  		 </td><td>M[i, j] = d[i],i = j;0,i ≠ j;</td></tr>
            <tr><td>b) 列矩阵 - 			 </td><td>M[i, j] = c[i], j = 1; 否则 – 错误;</td></tr>
            <tr><td>c) 上三角矩阵 - </td><td>M[i, j] = r<sub>i</sub>[j – i + 1],j ≥ i;否则 0;</td></tr>
            <tr><td>d) 下三角矩阵 - </td><td>M[i, j] = r<sub>i</sub>[j], j ≤ i;否则 0;</td></tr>
            <tr><td>e) 行矩阵 - 			 </td><td>M[i, j] = r[j], i = 1;否则 – 错误;</td></tr>
            <tr><td>f) 对称矩阵 -		 </td><td>M[i, j] = r<sub>i</sub>[j – i + 1], i ≥ j;否则= r<sub>i</sub> [i – j + 1];</td></tr>
            <tr><td>g) 矩形矩阵 - </td><td>M[i, j] = r<sub>i</sub>[j];</td></tr>
        </table>
        <p>如果我们在矩阵结构之外尝试写入一个非零值,将会得到一个“索引超出范围”的错误.例如,你不能将一个非零值赋给对角型矩阵主对角线之外的元素.</p>
        <p><b>定义</b></p>
        <p>与向量相似,你可以使用方括号定义矩阵, 但是不同行元素之间必须用竖线 " | "分割, 示例:</p>
        <p><var>A</var><sub>m⨯n</sub> = [<var>a</var><sub>1,1</sub>; <var>a</var><sub>1,2</sub>;  … ; <var>a</var><sub>1,n</sub> | <var>a</var><sub>2,1</sub>; <var>a</var><sub>2,2</sub>; … ; <var>a</var><sub>2,n</sub> | … |  <var>a</var><sub>m,1</sub>; <var>a</var><sub>m,2</sub>; … ; <var>a</var><sub>m,n</sub>]</p>
        <p>用该方法,仅能创建一般(矩形)矩阵.对于特殊矩阵, 需要使用本手册后需介绍的相应的创建函数. 如果行向量长度不同,则列的数量 <var>n</var>假设为行向量的最大元素数量. 其他缺失的列单元都假设为0. 示例:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1|2; 3|4; 5; 6|7; 8]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>
        <p>你可以对矩阵元素使用表达式,表达式可包含变量、运算符、函数、向量和其他矩阵等. 例如, 以下代码将通过对每行应用不同的表达式来创建行向量,从而创建一个包含三行的矩阵:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [1; 2; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = [<var>a</var>|2*<var>a</var> + 1|3*<var>a</var> + 2]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">9</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">8</span><span class="td">14</span><span class="td"></span></span>
            </span>
        </p>
        <p>就像向量,矩阵也可以定义为函数形式从而按照需要动态创建它们. 下列函数用一个向量创建了一个4×4的Vandermonde矩阵,该向量包含矩阵第一列的元素:</p>
        <p>
            &emsp;&emsp;<code><var>A</var>(<var>x</var>) = <b>transp</b>([<var>x</var>^0|<var>x</var>|<var>x</var>^2|<var>x</var>^3|<var>x</var>^4])</code><br />
            &emsp;&emsp;<code><var>x</var> = [1; 2; 3; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = <var>A</var>(<var>x</var>)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td">8</span><span class="td">16</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">9</span><span class="td">27</span><span class="td">81</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">16</span><span class="td">64</span><span class="td">256</span><span class="td"></span></span>
            </span>
        </p>
        <p><b>索引</b></p>
        <p>你可以使用索引功能访问矩阵元素以读取和写入它们的数值. 与向量类似,通多.标符号加索引号实现,但对矩阵需要明确2个索引号,示例如下:</p>
        <p>
            &emsp;&emsp;<code><var>A</var>.(<var>i</var>; <var>j</var>)</code>, 其中:<br />
            &emsp;&emsp;&emsp;&emsp;<code><var>i</var></code> - 元素所在行号,<br />
            &emsp;&emsp;&emsp;&emsp;<code><var>j</var></code> - 元素所在列号.
        </p>
        <p>索引号必须置于括号对中并以;分隔.行号和列号的取值最小为1. 以上述的 Vandermonde矩阵为例:</p>
        <p>&emsp;&emsp;<code><var>A</var>.(3; 2)</code>' = 3.</p>
        <p>你也可以在括号内的索引号处使用表达式来计算索引号:</p>
        <p>
            &emsp;&emsp;<code><var>i</var> = 2', '<var>j</var> = 3</code><br />
            &emsp;&emsp;<code><var>A</var>.(2*<var>i</var> - 1; <var>j</var> + 1)</code>' <var>A</var><sub>3, 4</sub> = 27.
        </p>
        <p>这样,你可以定义循环次数通过迭代来遍历矩阵的元素. 你可以使用行内或者块循环语句来实现该目的. 下面代码示例用向量<var><span class="vec">⃗</span>x</var>作为矩阵第(6)列 创建一个Vandermonde矩阵:</p>
        <p>
            &emsp;&emsp;<code><var>x</var> = [1; 2; 3; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = <b>matrix</b>(len(<var>x</var>); 7)</code><br />
            &emsp;&emsp;<code>#hide</code><br />
            &emsp;&emsp;<code>#for <var>i</var> = 1 : <b>n_rows</b>(<var>A</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code>#for <var>j</var> = 1 : <b>n_cols</b>(<var>A</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code><var>A</var>.(<var>i</var>; <var>j</var>) = <var>x</var>.<var>i</var>^(<var>j</var> - 1)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>#show</code><br />
            &emsp;&emsp;<code><var>A</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td">8</span><span class="td">16</span><span class="td">32</span><span class="td">64</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">9</span><span class="td">27</span><span class="td">81</span><span class="td">243</span><span class="td">729</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">16</span><span class="td">64</span><span class="td">256</span><span class="td">1024</span><span class="td">4096</span><span class="td"></span></span>
            </span>
        </p>
        <p>上述循环的单行等效循环如下:</p>
        <p>&emsp;&emsp;<code>$Repeat{$Repeat{<var>A</var>.(<var>i</var>; <var>j</var>) = <var>x</var>.<var>i</var>^(<var>j</var> - 1) @ <var>j</var> = 1 : <b>n_cols</b>(<var>A</var>)} @ <var>i</var> = 1 : <b>n_rows</b>(<var>A</var>)}</code></p>
        <p><b>创建相关的函数</b></p>
        <p>方括号"[]"对创建尺寸确定的小矩阵来说灵活好用. 然而,其局限也很多.例如, 它无法创建特殊类型的矩阵,也无法定义矩阵的维度. 因此, Calcpad 还包含了下列创建矩阵的函数:</p>

        <p>&emsp;&emsp;<code><b>matrix</b>(<var>m</var>; <var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>m</var> - (正整数)行数;<br />
                <var>n</var> - (正整数)列数.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个 m⨯n的空矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang"><var>m</var>和 <var>n</var> 必须为1~1 000 000的正整数.这也同样约束下列其他矩阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>matrix</b>(3; 4)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>identity</b>(<var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>n</var> - 行/列数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个维数n⨯n的单位矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">创建一个对角阵,所有对角元素为1.<br />该函数与<b>diagonal</b>&hairsp;(&hairsp;<var>n</var>&hairsp;; 1)等效.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>identity</b>(3)</code>' =<span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>diagonal</b>(<var>n</var>; <var>d</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>n</var> - 行/列数;<br />
                <var>d</var> - 主对角元素值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个n⨯n 的对角矩阵, 主对角元素值为 <var>d</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;从内存上该函数不同于一个n⨯n 的对称阵,且比它高效.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>diagonal</b>(3; 2)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">2</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>column</b>(<var>m</var>; <var>c</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>m</var> - 行数;<br />
                <var>c</var> - 用于填充矩阵元素的数值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个 m⨯1 的列矩阵, 所有元素值为 <var>c</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;从内存上该函数不同于一个m⨯1 的矩阵,且比它高效.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>column</b>(3; 2)</code>' =<span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>utriang</b>(<var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>n</var> - 行/列数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个维度n⨯n的空上三角矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;从内存上该函数不同于一个一般n×n 的方阵,且比它高效.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>U</var> = <b>utriang</b>(3)</code><br />
                <code><b>mfill</b>(<var>U</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>ltriang</b>(<var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>n</var> - 行/列数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个维度n⨯n的空下三角矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;从内存上该函数不同于一个一般n×n 的方阵,且比它高效.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>L</var> = <b>ltriang</b>(3)</code><br />
                <code><b>mfill</b>(<var>L</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>symmetric</b>(<var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>n</var> - 行/列数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个空的 n⨯n 对称方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">从内存上该函数不同于一个一般n×n 的方阵,且比它高效. 仅被填充的右-上半矩阵元素需要存储, 形成一个天际线形结构.如果改变一侧的值则两侧的元素值都改变,始终保持方阵对称.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = <b>symmetric</b>(4)</code><br />
                <code><var>A</var>.(1; 1) = 5', '<var>A</var>.(1; 2) = 4</code><br />
                <code><var>A</var>.(2; 2) = 3', '<var>A</var>.(2; 3) = 2</code><br />
                <code><var>A</var>.(4; 2) = 1', '<var>A</var>.(4; 4) = 1</code><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">3</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vec2diag</b>(<var><span class="vec">⃗</span>v</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>v</var> - 一个包含矩阵对角元素的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个对角元素来自向量 <var><span class="vec">⃗</span>v</var>的矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;矩阵的大小等于向量 <var><span class="vec">⃗</span>v</var>中元素个数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>vec2diag</b>([1; 2; 3]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vec2row</b>(<var><span class="vec">⃗</span>v</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>v</var> - 包含行矩阵元素的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个元素值为向量 <var><span class="vec">⃗</span>v</var>元素的行矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;矩阵的行数等于向量的大小<var><span class="vec">⃗</span>v</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>vec2row</b>([1; 2; 3]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span>
                <span class="td">1</span>
                <span class="td">2</span>
                <span class="td">3</span>
            <span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vec2col</b>(<var><span class="vec">⃗</span>v</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>v</var> - 一个包含列矩阵元素的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个元素值为向量 <var><span class="vec">⃗</span>v</var>的元素的列矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;矩阵的行数等于向量<var><span class="vec">⃗</span>v</var>的维数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>vec2col</b>([1; 2; 3]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join_cols</b>(<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub> …)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub> … - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个通过合并列向量得到的新矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">你可以指定任意数量的输入向量,这些向量的长度可以不同.矩阵行数等于最长的向量长度,其他列用零填充到末尾.向量从左到右依次连接.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>join_cols</b>([1]; [4; 5; 6]; [7; 8]; [10; 11; 12]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">7</span><span class="td">10</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">8</span><span class="td">11</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">6</span><span class="td">0</span><span class="td">12</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join_rows</b>(<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub> …)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub> … - 向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个新的矩阵,其行是指定的向量参数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">你可以指定任意数量的输入向量,这些向量的长度可以不同.矩阵列数等于最长的向量长度,其他行用零填充到末尾.根据向量在函数中从左到右的顺序,在矩阵中从上到下依次堆叠.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>join_rows</b>([1; 2; 3; 4]; [6; 7; 8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>augment</b>(<var>A</var>; <var>B</var>; <var>C</var>…)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>A</var>, <var>B</var>, <var>C</var> … - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;通过对矩阵<var>A</var><span class="o">;</span> <var>B</var><span class="o">;</span> <var>C</var> … 左右相接依次扩充创建的一个新矩阵;<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">可以指定任意数量的输入矩阵,且这些矩阵可以行数不同. 矩阵维度以最大行/列数为准,小的矩阵合并进新矩阵时尾部的空元素位填充为0. 矩阵从左至右顺序相接. 若参数包含向量,则作为列阵处理.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code><br />
                <code><var>B</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code><br />
                <code><var>c</var> = [10; 11; 12; 13]</code><br />
                <code><var>D</var> = <b>augment</b>(<var>A</var>; <var>B</var>; <var>c</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">10</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">11</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">12</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">13</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>stack</b>(<var>A</var>; <var>B</var>; <var>C</var>…)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>A</var>, <var>B</var>, <var>C</var> … - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;通过对矩阵上下相接创建新矩阵<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">可以指定任意数量的输入矩阵,且这些矩阵可以行数不同. 矩阵维度以最大行/列数为准,小的矩阵合并进新矩阵时尾部的空元素位填充为0. 矩阵从上至下顺序相接. 若参数包含向量,则作为列阵处理.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code><br />
                <code><var>B</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code><br />
                <code><var>c</var> = [10; 11]</code><br />
                <code><var>D</var> = <b>stack</b>(<var>A</var>; <var>B</var>; <var>c</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p><b>结构相关函数</b></p>
        <p>结构相关函数仅与矩阵结构相关. 与数据和数学函数不同, 函数结果对元素值相关性较低.</p>

        <p>&emsp;&emsp;<code><b>n_rows</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵 <var>M</var>的行数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>n_rows</b>([1; 2|3; 4|5; 6])</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>n_cols</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵 <var>M</var>的列数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <code><b>n_cols</b>([1|2; 3|4; 5; 6])</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>mresize</b>(<var>M</var>; <var>m</var>; <var>n</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 要调整维数的对象矩阵;<br />
                <var>m</var> - 调整后的行数;<br />
                <var>n</var> - 调整后的列数.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵 <var>M</var> 调整为 <var>m</var> 行、 <var>n</var> 列.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">若调整后的新维数增大,增加的元素初始化为0. 若调整后新维数减小,原矩阵被截取. 若新维数与矩阵类型兼容,则原矩阵维数被调整并返回一个索引. 否则, 返回一个新的矩形阵,其维数为指定的维数,而原矩阵保持不变.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span> - 一般类型.<br />
                <code><var>B</var> = <b>mresize</b>(<var>A</var>; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                </span>- 同样为一般类型.<br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                </span> - 原矩阵被改变.<br />
                <code><var>A</var> = <b>diagonal</b>(3; 5)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">5</span><span class="td"></span></span>
                </span> - 对角型.<br />
                <code><var>B</var> = <b>mresize</b>(<var>A</var>; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span> - 一般类型.<br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">5</span><span class="td"></span></span>
                </span> - 原矩阵保持不变.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mfill</b>(<var>M</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要被填充的矩阵;<br />
                <var>x</var> - 用于填充矩阵元素的值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;  以<var>x</var>的值填充的矩阵<var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">矩阵 <var>M</var> 被原位调整并返回其引用. 该函数是结构适应的. 特殊矩阵仅指定区域被填充,并保持其矩阵类型.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = <b>matrix</b>(2; 3)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>mfill</b>(<var>A</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>L</var> = <b>mfill</b>(<b>ltriang</b>(4); 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fill_row</b>(<var>M</var>; <var>i</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 行即将被填充的对象矩阵;<br />
                <var>i</var> - 即将被填充的矩阵行号;<br />
                <var>x</var> - 用于填充矩阵行的数值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;第 <var>i</var>行被以数值<var>x</var>填充的矩阵<var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">矩阵<var>M</var> 被原位调整并返回索引. 该函数是结构适应的. 特殊矩阵仅指定区域被填充,并保持其矩阵类型.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = <b>matrix</b>(3; 4)</code>' - 一般矩阵<br />
                <code><b>fill_row</b>(<var>A</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>L</var> = <b>utriang</b>(4)</code>' - 上三角矩阵<br />
                <code>$Repeat{<b>fill_row</b>(<var>L</var>; k; k) @ k = 1 : <b>n_rows</b>(<var>L</var>)}</code><br />
                <code><var>L</var></code>' = <span class="eq matrix">
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl1">2</span><span class="td hl1">2</span><span class="td hl1">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td hl2">3</span><span class="td hl2">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td hl2">4</span><span class="td"></span></span>
                </span> - 下三角部分保持不变.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fill_col</b>(<var>M</var>; <var>j</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 其列将被填充的矩阵;<br />
                <var>j</var> - 将要被填充的列号;<br />
                <var>x</var> - 将要用于填充列元素的数值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;第 <var>j</var>列被以<var>x</var>填充的矩阵<var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">The matrix <var>M</var> 被原位调整并返回索引 该函数是结构适应的. 特殊矩阵仅指定区域被填充,并保持其矩阵类型.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = <b>matrix</b>(3; 4)</code><br />
                <code><b>fill_col</b>(<var>A</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>symmetric</b>(4)</code>' - 对称阵.<br />
                <code><b>fill_col</b>(<var>B</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td hl">1</span><span class="td hl">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span> - 对称性保持不变.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>copy</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 源矩阵;<br />
                <var>B</var> - 复制元素去向的目标矩阵;<br />
                <var>i</var> - 矩阵中的起始行号<var>B</var>;<br />
                <var>j</var> - 矩阵中的起始列号 <var>B</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">矩阵<var>B</var>中起始行号 <var>i</var> 、起始列号 <var>j</var>的元素调整为矩阵<var>A</var>中的元素.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">从矩阵 <var>A</var>中复制元素到矩阵<var>B</var>中,原位调整了矩阵<var>B</var> . 矩阵 <var>B</var>的原元素被从 <var>A</var>中复制的元素替换. 结果返回 <var>B</var> 的索引.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6]</code><br />
                <code><var>B</var> = <b>mfill</b>(<b>matrix</b>(3; 4); -1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>copy</b>(<var>A</var>; <var>B</var>; 1; 1)</code><br />
                <code><b>copy</b>(<var>A</var>; <var>B</var>; 2; 2)</code><br />
                <code><var>B</var></code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">1</span><span class="td hl">2</span><span class="td hl">3</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td hl">4</span><span class="td hl2">1</span><span class="td hl2">2</span><span class="td hl1">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td hl1">4</span><span class="td hl1">5</span><span class="td hl1">6</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>add</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 源矩阵;<br />
                <var>B</var> - 元素将要被加的目标矩阵;<br />
                <var>i</var> - 矩阵中的起始行号<var>B</var>;<br />
                <var>j</var> - 矩阵中的起始列号 <var>B</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">矩阵<var>B</var>中起始行号 <var>i</var> 、起始列号 <var>j</var>的元素加上矩阵<var>A</var>中的元素.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">将矩阵<var>A</var>的元素加到矩阵 <var>B</var> 上原位调整了矩阵 <var>B</var> . 结果返回 <var>B</var> 的索引.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6]</code><br />
                <code><var>B</var> = <b>mfill</b>(<b>matrix</b>(3; 4); -1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>add</b>(<var>A</var>; <var>B</var>; 1; 1)</code><br />
                <code><b>add</b>(<var>A</var>; <var>B</var>; 2; 2)</code><br />
                <code><var>B</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">0</span><span class="td hl">1</span><span class="td hl">2</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td hl">3</span><span class="td hl2">5</span><span class="td hl2">7</span><span class="td hl1">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td hl1">3</span><span class="td hl1">4</span><span class="td hl1">5</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>row</b>(<var>M</var>; <var>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>i</var> -将要被提取的行的行号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵<var>M</var>的第<var>i</var>行元素组成的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;返回行的完整宽度,也适用于特殊矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>row</b>(<var>A</var>; 3)</code>' = [7&ensp;8&ensp;9]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>col</b>(<var>M</var>; <var>j</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>j</var> -将要提取的列号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;the 矩阵<var>M</var>的第<var>j</var>列向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;返回列的完整高度,也适用于特殊矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td hl">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>col</b>(<var>A</var>; 2)</code>' = [2&ensp;5&ensp;8]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract_rows</b>(<var>M</var>; <var><span class="vec">⃗</span>i</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var><span class="vec">⃗</span>i</var> - 包含要提取的行的行号的向量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个新矩阵,包含矩阵 <var>M</var>的行,行号在向量 <var><span class="vec">⃗</span>i</var>中指定.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">按照向量 <var><span class="vec">⃗</span>i</var>指定的顺序提取行.也可以用 <b>order_rows</b> 函数得到.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>extract_rows</b>(<var>A</var>; [1; 2; 1])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract_cols</b>(<var>M</var>; <var><span class="vec">⃗</span>j</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var><span class="vec">⃗</span>j</var> -
                <var><span class="vec">⃗</span>i</var> - 包含要提取的列的列号的向量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个新矩阵,包含矩阵 <var>M</var>的列,列号在向量 <var><span class="vec">⃗</span>j</var>中指定..<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">按照向量 <var><span class="vec">⃗</span>j</var>指定的顺序提取列. 也可以用 <b>order_cols</b> 函数得到.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>extract_cols</b>(<var>A</var>; [3; 2; 1])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>diag2vec</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个包含矩阵 <var>M</var>对角元素的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">不要求矩阵 <var>M</var> 为方阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6; 7|8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td hl">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td hl">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><b>diag2vec</b>(<var>A</var>)</code>' = [1&ensp;4&ensp;7]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>submatrix</b>(<var>M</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>i</var><sub>1</sub> - 起始行号;<br />
                <var>i</var><sub>2</sub> - 终止行号;<br />
                <var>j</var><sub>1</sub> - - 起始列号;<br />
                <var>j</var><sub>2</sub> - 终止列号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个由矩阵<var>M</var>第<var>i</var><sub>1</sub> ~ <var>i</var><sub>2</sub>行、第 <var>j</var><sub>1</sub> ~ <var>j</var><sub>2</sub>列的子矩阵构成的新矩阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">起始索引号可以大于终止索引号. 然而,返回的是矩阵的同一部分. 结果总是一个一般(矩形)矩阵, 即使源矩阵是特殊阵也一样.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [ 1; &nbsp;2; &nbsp;3; &nbsp;4| _</code><br />
                &emsp;&emsp;&ensp; <code>&nbsp;5; &nbsp;6; &nbsp;7; &nbsp;8| _</code><br />
                &emsp;&emsp;&ensp; <code>&nbsp;9; 10; 11; 12| _</code><br />
                &emsp;&emsp;&ensp; <code>13; 14; 15; 16]</code><br />
                <code><b>submatrix</b>(<var>A</var>; 2; 3; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">11</span><span class="td">12</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p><b>数据相关函数</b></p>
        <p>数据相关函数与矩阵结构无关,而仅与元素值相关. 下列函数可用:</p>
        <p>
            &emsp;&emsp;<code><b>sort_cols</b>(<var>M</var>; <var>i</var>)</code><br />
            &emsp;&emsp;<code><b>rsort_cols</b>(<var>M</var>; <var>i</var>)</code>
        </p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要被排序的矩阵;<br />
                <var>i</var> - 将要根据值大小排序的元素行号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;a new 一个新矩阵<var>M</var>,其列按照第<var>i</var>行元素大小排序.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang"><b>sort_cols</b> 按照升序排列, 而 <b>rsort_cols</b>则按照降序排列. 源矩阵未作调整.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>sort_cols</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td">8</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>rsort_cols</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">9</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span> - 源矩阵不变.
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>sort_rows</b>(<var>M</var>; <var>j</var>)</code><br />
            &emsp;&emsp;<code><b>rsort_rows</b>(<var>M</var>; <var>j</var>)</code>
        </p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要被排序的矩阵<br />
                <var>j</var> - 将要基于值大小排序的元素的列号
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;按照第 <var>j</var>列元素大小排序后的新矩阵<var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang"><b>sort_rows</b> 按照升序排列, 而 <b>rsort_rows</b>则按照降序排列. 源矩阵未作调整.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>sort_rows</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>rsort_rows</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span> - 源矩阵不变.
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>order_cols</b>(<var>M</var>; <var>i</var>)</code><br />
            &emsp;&emsp;<code><b>revorder_cols</b>(<var>M</var>; <var>i</var>)</code>
        </p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要被排序的矩阵;<br />
                <var>i</var> - 将用于排序的基准行的行号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个向量,包含了矩阵 <var>M</var> 基于第 <var>i</var>行的元素值排序后的列号序列.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang"><b>order_cols</b> 返回升序排列的索引号, 而 <b>revorder_cols</b>则返回降序排列的索引号. 源矩阵未作调整.每一个输出向量 <var><span class="vec">⃗</span>j</var> 的索引号显示矩阵<var>M</var> 中的列(号)应被放在当前位置以获得在第<var>i</var>行的排序. 你可以通过调用 <b>extract_cols</b>&hairsp;(<var>M</var>&hairsp;; <var><span class="vec">⃗</span>j</var>&hairsp;)得到排序后的矩阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>order_cols</b>(<var>A</var>; 2)</code>' = [3&ensp;1&ensp;2]<br />
                <code><var>B</var> = <b>extract_cols</b>(<var>A</var>; <var>b</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td">8</span><span class="td"></span></span>
                </span><br />
                <code><var>c</var> = <b>revorder_cols</b>(<var>A</var>; 2)</code>' = [2&ensp;1&ensp;3]<br />
                <code><var>C</var> = <b>extract_cols</b>(<var>A</var>; <var>c</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">9</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>order_rows</b>(<var>M</var>; <var>j</var>)</code><br />
            &emsp;&emsp;<code><b>revorder_rows</b>(<var>M</var>; <var>j</var>)</code>
        </p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> -  <br />
                <var>j</var> - 作为排列基准的列号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个包含矩阵 <var>M</var>行号的向量, 行号按照第<var>j</var>列的值排列.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang"><b>order_rows</b> 以升序返回索引号, 而 <b>revorder_rows</b> - 则以降序返回索引号. 矩阵未被调整. 输出向量<var><span class="vec">⃗</span>i</var> 中每个索引号显示矩阵 <var>M</var>中将被置于当前位置的行,以获得在第 <var>j</var>列的排序. 你可以通过调用 <b>extract_rows</b>&hairsp;(<var>M</var>&hairsp;; <var><span class="vec">⃗</span>i</var>&hairsp;)得到排序后的矩阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>order_rows</b>(<var>A</var>; 2)</code>' = [1&ensp;3&ensp;2]<br />
                <code><var>B</var> = <b>extract_rows</b>(<var>A</var>; <var>b</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>c</var> = <b>revorder_rows</b>(<var>A</var>; 2)</code>' = [2&ensp;3&ensp;1]<br />
                <code><var>B</var> = <b>extract_rows</b>(<var>A</var>; <var>c</var>)</code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mcount</b>(<var>M</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>x</var> - 计数出现次数的值.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;值 <var>x</var> 在矩阵 <var>M</var>出现的次数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 0; 1|2; 1; 2|1; 3; 1]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>n</var> = <b>mcount</b>(<var>A</var>; 1)</code>' = 5
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>msearch</b>(<var>M</var>; <var>x</var>; <var>i</var>; <var>j</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>x</var> - 要查找的值;<br />
                <var>i</var> - 起始行号;<br />
                <var>j</var> - - 起始列号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个向量,包含了矩阵<var>M</var>中第一次出现 <var>x</var>的行号 <var>i</var> 和列号<var>j</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">搜索逐行进行,行内从左至右.如未找到匹配项,则返回一个空向量 [0&ensp;0] .</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|1; 5; 6|1; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>msearch</b>(<var>A</var>; 1; 1; 1)</code>' = [1&ensp;1]<br />
                <code><var>c</var> = <b>msearch</b>(<var>A</var>; 1; 2; 2)</code>' = [3&ensp;1]<br />
                <code><var>d</var> = <b>msearch</b>(<var>A</var>; 4; 1; 1)</code>' = [0&ensp;0]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mfind</b>(<var>M</var>; <var>x</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 矩阵;<br />
                <var>x</var> - the value to search for.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个2行矩阵,包含矩阵<var>M</var> 中所有=<var>x</var>的元素的索引号.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;&nbsp;<span class="hang">输出矩阵第一行包含<var>M</var>中=<var>x</var>的元素的行号,下面一行则是相应元素的列号 . 若无匹配项,则返回一个2×1的0矩阵.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 1; 6|1; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">1</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>mfind</b>(<var>A</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>mfind</b>(<var>A</var>; 5)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>hlookup</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要应用lookup函数的矩阵;<br />
                <var>x</var> - 要搜索的值;<br />
                <var>i</var><sub>1</sub> - 要查找<var>x</var>值的行号;<br />
                <var>i</var><sub>2</sub> - 要返回对应值的行号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个矩阵<var>M</var>第<var>i</var><sub>1</sub>行元素  = <var>x</var>时,该元素所在列对应的第<var>i</var><sub>2</sub>行的元素值(组成的向量).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">数值从左至右搜集.若未找到, 则返回空向量 [] .</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [0; 1; 0; 1|1; 2; 3; 4; 5|6; 7; 8; 9; 10]</code> ' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">4</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>hlookup</b>(<var>A</var>; 0; 1; 3)</code>' = [6&ensp;8&ensp;10]<br />
                <code><var>c</var> = <b>hlookup</b>(<var>A</var>; 2; 1; 3)</code>' = []
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vlookup</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>M</var> - 将要应用lookup函数的矩阵;<br />
                <var>x</var> - 要搜索的值;<br />
                <var>j</var><sub>1</sub> - 要查找<var>x</var>值的列号;<br />
                <var>j</var><sub>2</sub> - 要返回对应值的列号.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个矩阵<var>M</var>第<var>j</var><sub>1</sub>列元素  = <var>x</var>时,该元素所在行对应的第<var>i</var><sub>2</sub>列的元素值(组成的向量).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">数值从上至下搜集.若未找到, 则返回空向量 [].</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4; 1|5; 6|7; 8; 1|9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">10</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>vlookup</b>(<var>A</var>; 0; 3; 1)</code>' = [1&ensp;5&ensp;9]<br />
                <code><var>c</var> = <b>vlookup</b>(<var>A</var>; 1; 3; 2)</code>' = [4&ensp;8]<br />
                <code><var>d</var> = <b>vlookup</b>(<var>A</var>; 2; 3; 1)</code>' = []
            </span>
        </p>

        <p><b>find</b>, <b>hlookup</b> 和 <b>vlookup</b>函数不同后缀表示不同的对比操作符. 可用的后缀列于下表:</p>
        <table class="bordered small">
            <tr><th>后缀</th><th>mfind</th><th>hlookup</th><th>vlookup</th><th>对比操作符</th></tr>
            <tr>
                <td><code>_eq</code></td>
                <td><code><b>mfind_eq</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_eq</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_eq</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>=</code> - 等于</td>
            </tr>
            <tr>
                <td><code>_ne</code></td>
                <td><code><b>mfind_ne</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_ne</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_ne</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>≠</code> - 不等于</td>
            </tr>
            <tr>
                <td><code>_lt</code></td>
                <td><code><b>mfind_lt</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_lt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_lt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&lt;</code> - 小于</td>
            </tr>
            <tr>
                <td><code>_le</code></td>
                <td><code><b>mfind_le</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_le</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_le</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&le;</code> - 小于等于</td>
            </tr>
            <tr>
                <td><code>_gt</code></td>
                <td><code><b>mfind_gt</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_gt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_gt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&gt;</code> - 大于</td>
            </tr>
            <tr>
                <td><code>_ge</code></td>
                <td><code><b>mfind_ge</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_ge</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code>
                <td><code><b>vlookup_ge</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&ge;</code> - 大于等于</td>
            </tr>
        </table>

        <p><b>数学函数</b></p>
        <p>所有标准的标量数学函数也接受矩阵量. 函数将独立地作用于输入矩阵的所有元素,即便对特殊类型矩阵也如此. 结果返回到相应的输出矩阵中. 输出矩阵总是一个一般(矩形)类型矩阵,因此矩阵的原结构不再保留. 示例:</p>
        <p>
            &emsp;&emsp;<code>#rad</code><br />
            &emsp;&emsp;<code><var>M</var> = <b>diagonal</b>(3; <var>π</var>/2)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1.571</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1.571</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1.571</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><b>cos</b>(<var>M</var>)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>
        <p>Calcpad还包含如下一系列专门阵地矩阵的数学函数:</p>

        <p>&emsp;&emsp;<code><b>hprod</b>(<var>A</var>; <var>B</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 第1个矩阵;<br />
                <var>B</var> - 第2个矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(矩阵) 矩阵 <var>A</var> 和 <var>B</var>的Hadamard积.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">两个矩阵必须维数相等. Hadamard (a.k.a. Schur) 积<var>C</var> = <var>A</var>⊙<var>B</var>是一种2个矩阵间对应元素(element-wise)积. 输出矩阵的元素通过以下方程得到:<br /><var>C</var><sub>ij</sub> = <var>A</var><sub>ij</sub> <var>B</var><sub>ij</sub>. 若2个矩阵类型相同,其类型在输出矩阵中得以保留;否则 返回的矩阵为一般类型.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [9; 8|7; 6|5; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>hprod</b>(<var>A</var>; <var>B</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">21</span><span class="td">24</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">25</span><span class="td">24</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fprod</b>(<var>A</var>; <var>B</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 第1个矩阵;<br />
                <var>B</var> - 第2个矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量)  矩阵<var>A</var> 和 <var>B</var>的Frobenius积.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                个矩阵必须维数相等.结果通过对输入矩阵对应的元素对的积的求和得到:<br />
                <span class="eq"><var>p</var> = <span class="dvr"><small><var>m</var></small><span class="nary">&Sigma;</span><small><var>i</var>=&hairsp;1</small></span><span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>j</var>=&hairsp;1</small></span><var>A</var><sub>ij</sub> <var>B</var><sub>ij</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [9; 8|7; 6|5; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>fprod</b>(<var>A</var>; <var>B</var>)</code>' = 119
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>kprod</b>(<var>A</var>; <var>B</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 第1个矩阵;<br />
                <var>B</var> - 第2个矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(矩阵) 矩阵<var>A</var> 和 <var>B</var>的Kronecker积.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">若 <var>A</var> 为 m×n ,而 <var>B</var> 为p×q的 矩阵, 结果为1个 mp×nq 的块矩阵<var>C</var>, 其中每个块通过如下方程得到: [<var>C</var>&hairsp;]<sub>ij</sub> = <var>A</var><sub>ij</sub> <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [5; 6; 7|8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>kprod</b>(<var>A</var>; <var>B</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">7</span><span class="td">10</span><span class="td">12</span><span class="td">14</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td">16</span><span class="td">18</span><span class="td">20</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">15</span><span class="td">18</span><span class="td">21</span><span class="td">20</span><span class="td">24</span><span class="td">28</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">24</span><span class="td">27</span><span class="td">30</span><span class="td">32</span><span class="td">36</span><span class="td">40</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_1</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量)矩阵<var>M</var>的L<sub>1</sub> 范数(Manhattan, a.k.a. taxicab).<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">得到的是所有 L<sub>1</sub> 列向量范数的最大值, 通过下式计算: <span class="eq">||<var>M</var>&hairsp;||<sub>1</sub> = <span class="dvr"><small></small><span style="display: block; position:relative; top:0.4em;">max</span><small>1 &le; <var>j</var> &le; <var>n</var>&ensp;</small></span><span class="dvr"><small><var>m</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>M</var><sub>ij</sub>&hairsp;<b class="b0">|</b></span></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_1</b>(<var>A</var>)</code>' = 18
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm</b>(<var>M</var>)</code> or <code><b>mnorm_2</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 一个m×n矩阵,其中m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示矩阵<var>M</var>的 L<sub>2</sub> (spectral)范数的标量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                通过求矩阵<var>M</var>&hairsp;的奇异值得到:<br />
                <span class="eq">||<var>M</var>&hairsp;||<sub>2</sub> = <var>&sigma;</var><sub>max</sub>&hairsp;(<var>M</var>&hairsp;)</span>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_2</b>(<var>A</var>)</code>' = 16.8481
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_e</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示矩阵<var>M</var>的Frobenius (Euclidean)范数的标量 .<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                与向量的Euclidian范数相似, 假设矩阵通过行串联线性化. 通过计算所有元素的平方和的平方根求得,示例如下:<br />
                <span class="eq">||<var>M</var>&hairsp;||<sub>e</sub> = &emsp;<span class="o2"><span class="r2"></span><span class="dvr"><small><var>m</var></small><span class="nary">&Sigma;</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>j</var>&hairsp;=&hairsp;1</small></span><var>M</var><sub>ij</sub><sup>2</sup></span></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_e</b>(<var>A</var>)</code>' = 16.8819
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_i</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;表示矩阵 <var>M</var>的L<sub>∞</sub> (infinity)范数的标量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">通过下列方程求得所有L<sub>1</sub> 行向量范数的最大值:<br /> <span class="eq">||<var>M</var>&hairsp;||<sub> ∞</sub> = <span class="dvr"><small></small><span style="display: block; position:relative; top:0.4em;">max</span><small>1 &le; <var>i</var> &le; <var>m</var></small>&ensp;</span><span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>j</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>M</var><sub>ij</sub>&hairsp;<b class="b0">|</b></span></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_i</b>(<var>A</var>)</code>' = 24
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_1</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵 <var>M</var> 基于 L<sub>1</sub> 范数的条件数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                通过下列方程式计算:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>1</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>1</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>1</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_1</b>(<var>A</var>)</code>' = 6.4852×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond</b>(<var>M</var>)</code> or <code><b>cond_2</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 一个m×n 矩阵,其中m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵 <var>M</var> 基于 L<sub>2</sub> 范数的条件苏.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                条件数显示矩阵 <var>A</var> 在求解方程 <var>A</var><var><span class=“vec”>⃗</span>x</var> = <var><span class=“vec”>⃗</span>b</var> 或反转矩阵时的灵敏度.数字越高,所得解的准确率越低.理论上,奇异矩阵具有无限的条件数.然而,在浮点环境中,由于浮点误差,可以获得非常大但有限的数字.条件数由以下表达式计算:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>2</sub>(<var>M</var>&hairsp;) = <var>&sigma;</var><sub>max</sub>(<var>M</var>&hairsp;) / <var>&sigma;</var><sub>min</sub>(<var>M</var>&hairsp;)</span><br />
                由于这在计算上很费时,因此可以使用其他函数来代替,从而提供相似的值,但计算成本较低.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_2</b>(<var>A</var>)</code>' = 1.7159×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_e</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵<var>M</var> 基于 Frobenius范数的条件数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                通过下列表达式计算:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>e</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>e</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>e</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_e</b>(<var>A</var>)</code>' = 4.5618×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_i</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵<var>M</var> 基于 L<sub>∞</sub> 范数的条件数 .<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                通过下列方程式求得:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>∞</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>∞</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>∞</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_i</b>(<var>A</var>)</code>' = 8.6469×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>det</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵<var>M</var>的行列式.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">为了评估结果,首先通过 LU 分解将矩阵分解为下三角 (<var>L</var>) 和上三角 (<var>U</var>) 矩阵.然后,行列式以沿 <var>U</var> 矩阵主对角线的元素的乘积获得.从理论上讲,对于奇异矩阵,行列式应该正好为0.但是,不建议在实践中使用此标准.由于浮点舍入误差,它可以返回 “小” 但非零的值.最好改用秩(rank)或条件数(condition number).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>det</b>(<var>A</var>)</code>' = 6.6613×10<sup>-16</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>rank</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 一个m×n矩阵,其中m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量)矩阵<var>M</var>的秩(rank).<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">秩表示矩阵中线性独立的行的数量. 可通过对矩阵进行SVD分解并计非零奇异值的个数得到.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>rank</b>(<var>A</var>)</code>' = 2
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>trace</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 矩阵<var>M</var>的迹(trace ).<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">迹的定义是方阵的主对角线元素的和.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>trace</b>(<var>A</var>)</code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>transp</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(matrix) the transpose of <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">转置矩阵通过将行变成列得到. 如果 <var>M</var> 为对称矩阵, 转置矩阵等于本身, 则返回<var>M</var> 的拷贝.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>transp</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">9</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>adj</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵<var>M</var>的伴随矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">方阵的伴随矩阵为协因数矩阵的转置,可以通过 <var>M</var> 乘以 <var>M</var>&hairsp;的行列式得到:<br /> <b>adj</b>(<var>M</var>&hairsp;) = <var>M</var>&hairsp;<sup>-1</sup> &middot; |<var>M</var>&hairsp;|</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><b>adj</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>det</b>(<var>A</var>)</code>' = 2<br />
                <code><b>inverse</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1.5</span><span class="td">-0.5</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cofactor</b>(<var>A</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>A</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;the cofactor matrix of <var>A</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">协因数/共因子 <var>C</var><sub>ij</sub> 定义为相应的余子式 <var>M</var><sub>ij</sub> 乘以 (-1)<sup><var>i</var> + <var>j</var></sup>.因此通过删除第 <var>i</var> 行和第 <var>j</var> 列获得的协因数 <var>M</var><sub>ij</sub> 等于矩阵的行列式.此外,协因数矩阵等于 伴随矩阵<var>A</var>&hairsp;的转置:<br /><var>C</var> = <b>adj</b>(<var>A</var>&hairsp;)<sup>T</sup></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><b>cofactor</b>([1; 2|3; 4])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigenvals</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 对称阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个包含了矩阵 <var>M</var>的特征值的向量.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">返回的特征值以升序排列. 计算通过利用具有隐式移位的对称 Q&nbsp;&nbsp;&nbsp;L 算法完成.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigenvals</b>(<var>A</var>)</code>' = [0.0188&ensp;15.5&ensp;123.48]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigenvecs</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 对称阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一个列向量为矩阵<var>M</var>的特征向量的新矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">返回特征向量的顺序同相应的特征值, 通过函数 <b>eigenvals</b>(<var>M</var>&hairsp;)获取.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigenvecs</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0.963</span><span class="td">-0.213</span><span class="td">-0.163</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.265</span><span class="td">-0.849</span><span class="td">-0.457</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.0411</span><span class="td">-0.484</span><span class="td">0.874</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigen</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 对称阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">一个 n×(n + 1) 矩阵,其第一列包含特征值, 其余列是矩阵<var>M</var>的特征向量.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">如果同时需要特征值和特征向量,则该函数比分别调用 <b>eigenvals</b>(<var>M</var>&hairsp;) 和 <b>eigenvecs</b>(<var>M</var>&hairsp;) 要高效.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigen</b>(<var>A</var>)</code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0.0188</span><span class="td">0.963</span><span class="td">-0.213</span><span class="td">-0.163</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">15.5</span><span class="td">-0.265</span><span class="td">-0.849</span><span class="td">-0.457</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">123.48</span><span class="td">0.0411</span><span class="td">-0.484</span><span class="td">0.874</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cholesky</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 对称、正-定矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(上三角矩阵)矩阵<var>M</var>的 Cholesky 分解.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">这种分解将矩阵转换为两个三角矩阵的乘积:<var>M</var> = <var>L</var>·<var>L</var>&hairsp;<sup>T</sup>.当前函数仅返回上半部分 - <var>L</var>&hairsp;<sup>T</sup>.Cholesky 分解比同一矩阵的相应 LU 分解更快、更稳定.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>LT</var> = <b>cholesky</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">6</span><span class="td">-8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
                </span> - the 上三角矩阵 <var>L</var><sup>T</sup><br />
                <code><var>L</var> = <b>transp</b>(<var>LT</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-8</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
                </span> - 下三角矩阵 <var>L</var><br />
                <code><var>L</var>*<var>LT</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span> - 检查
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>lu</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(矩阵) 矩阵<var>M</var>的LU分解.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                LU 分解将矩阵分解为两个矩阵的乘积:下三角 <var>L</var> 和上三角 <var>U</var> (<var>M</var> = <var>L</var>·<var>U</var>&hairsp;).它不要求矩阵是对称的.由于 LU 分解不是唯一的,因此有无限数量的解.这里假设沿 <var>L</var> 的主对角线的所有元素都等于 1.该函数返回打包在单个方阵中的矩阵 <var>L</var> 和 <var>U</var>.沿主对角线的元素属于 <var>U</var>,因为已知 <var>L</var> 的元素是 1.该解决方案通过使用带有部分旋转的 Crout 算法来执行.Calcpad 没有构建排列矩阵 <var>P</var>,而是在内部创建了一个向量 <var><span class="vec">⃗</span>ind</var>,其中包含重新排序后的行索引.<br />
                如果您分别需要矩阵 <var>L</var> 和 <var>U</var>,则可以通过组合矩阵的 Hadamard 积通过相应的下/上三角矩阵提取它们.之后,您必须将 <var>L</var> 的对角线元素重置为 1.<br />
                如果 <var>M</var> 的类型是对称矩阵,则返回 LDL<sup>T</sup> 分解而不是 LU.它类似于 Cholesky 分解,但避免了对角线元素的平方根.因此,矩阵不需要是正定矩阵.但是,有必要将对角线元素存储在单独的对角矩阵 <var>D</var> 中.因此,矩阵 <var>M</var> 表示为三个矩阵的乘积:<br /><var>M</var> = <var>L</var>·<var>D</var>·<var>L</var>&hairsp;<sup>T</sup>.它们也被打包在一个方阵中.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>LU</var> = <b>lu</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1.33</span><span class="td">6.33</span><span class="td">40.67</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.333</span><span class="td">-0.0526</span><span class="td">0.474</span><span class="td"></span></span>
                </span> - 组合矩阵<br />
                <code><var>ind</var></code>' = [2&emsp;3&emsp;1]<br />
                <code><var>D</var> = <b>not</b>(<b>identity</b>(3))</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                </span> - 索引轮转向量<br />
                <code><var>L</var> = <b>hprod</b>(<b>mfill</b>(<b>ltriang</b>(3); 1); <var>LU</var>)^<var>D</var></code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1.333</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.3333</span><span class="td">-0.05263</span><span class="td">1</span><span class="td"></span></span>
                </span> - 提取下三角矩阵<br />
                <code><var>U</var> = <b>hprod</b>(<b>mfill</b>(<b>utriang</b>(3); 1); <var>LU</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">6.333</span><span class="td">40.667</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.4737</span><span class="td"></span></span>
                </span> - 提取上三角矩阵<br />
                <code><b>extract_rows</b>(<var>L</var>*<var>U</var>; <b>order</b>(<var>ind</var>))</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span> - 检查
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>qr</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵 <var>M</var>的QR分解(得到的矩阵).<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">顾名思义,该矩阵被分解为正交矩阵 <var>Q</var> 和上三角矩阵 <var>R</var> 的乘积 (<var>M</var> = <var>Q</var>·<var>R</var>&hairsp;).Householder方法用于此目的.该算法很稳定,不需要旋转.两个矩阵都打包在一个 n×2n 块矩形矩阵 [Q,R] 中,并作为结果返回.您可以使用 <b>submatrix</b> 函数对两个矩阵中的每一个进行调用.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>QR</var> = <b>qr</b>(<var>A</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.196</span><span class="td">-0.169</span><span class="td">0.966</span><span class="td">-20.4</span><span class="td">-57.85</span><span class="td">105.31</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.588</span><span class="td">-0.768</span><span class="td">-0.254</span><span class="td">0</span><span class="td">-3.86</span><span class="td">-24.85</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.784</span><span class="td">-0.618</span><span class="td">0.0508</span><span class="td">0</span><span class="td">0</span><span class="td">0.457</span><span class="td"></span></span>
                </span> - 组合QR矩阵<br />
                <code><var>Q</var> = <b>submatrix</b>(<var>QR</var>; 1; 3; 1; 3)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.1961</span><span class="td">-0.1695</span><span class="td">0.9658</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.5883</span><span class="td">-0.7676</span><span class="td">-0.2542</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.7845</span><span class="td">-0.6181</span><span class="td">0.05083</span><span class="td"></span></span>
                </span> - 提取Q矩阵<br />
                <code><var>R</var> = <b>submatrix</b>(<var>QR</var>; 1; 3; 4; 6)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-20.396</span><span class="td">-57.854</span><span class="td">105.314</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">-3.858</span><span class="td">-24.853</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.4575</span><span class="td"></span></span>
                </span> - 提取R矩阵<br />
                <code><var>Q</var>*<var>R</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span> - 检查
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>svd</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> -一个m×n 矩阵, 其中 m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵<var>M</var>的奇异值分解.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">
                该矩阵分解为三个矩阵的乘积:<var>M</var> = <var>U</var>&middot;<var>Σ</var>&middot;<var>V</var>&hairsp;<sup>T</sup>,其中 <var>Σ</var> 是包含 <var>M</var> 奇异值的对角矩阵,<var>U</var> 和 <var>V</var>&hairsp;<sup>T</sup> 是正交矩阵,列分别表示左奇异向量和右奇异向量.结果以单个 m×(2n + 1) 矩阵 [U, Σ, V] 的形式返回,其中 Σ 是包含所有奇异值的单列.它们按降序排序,奇异向量分别重新排序以匹配相应的奇异值.请注意,返回的 <var>V</var>&hairsp;<sup>T</sup> 矩阵已经转置,因此您无需再次转置.<br />
                有时,一些奇异向量可能会变号,因此 <var>U</var>&middot;<var>Σ</var>&middot;<var>V</var>&hairsp;<sup>T</sup> 在乘以得到的矩阵后不会得到矩阵<var>M</var>
                符号不明是大部分 SVD 算法的共性已知问题. 对于对称阵奇异值等于绝对特征值: <var>&sigma;</var><sub>i</sub> = |&hairsp;<var>&lambda;</var><sub>i</sub>|
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>SVD</var> = <b>svd</b>(<var>A</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">0.2127</span><span class="td">-0.9634</span><span class="td">123.477</span><span class="td">-0.163</span><span class="td">-0.4573</span><span class="td">0.8742</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.4573</span><span class="td">0.849</span><span class="td">0.2648</span><span class="td">15.504</span><span class="td">0.2127</span><span class="td">0.849</span><span class="td">0.4838</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.8742</span><span class="td">0.4838</span><span class="td">-0.0411</span><span class="td">0.0188</span><span class="td">-0.9634</span><span class="td">0.2648</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - 组合矩阵<br />
                <code><var>U</var> = <b>submatrix</b>(<var>SVD</var>; 1; 3; 1; 3)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">0.2127</span><span class="td">-0.9634</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.4573</span><span class="td">0.849</span><span class="td">0.2648</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.8742</span><span class="td">0.4838</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - 提取U矩阵<br />
                <code><var>V</var> = <b>submatrix</b>(<var>SVD</var>; 1; 3; 5; 7)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">-0.4573</span><span class="td">0.8742</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.2127</span><span class="td">0.849</span><span class="td">0.4838</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.9634</span><span class="td">0.2648</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - 提取V矩阵<br />
                <code><var>σ</var> = <b>col</b>(<var>SVD</var>; 4)</code>' = <span class="eq">[123.477&nbsp;15.504&nbsp;0.0188]</span> - 提取奇异值<br />
                <code><var>Σ</var> = <b>vec2diag</b>(<var>σ</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">123.477</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">15.504</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.0188</span><span class="td"></span></span>
                </span> - 构成奇异值矩阵
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>inverse</b>(<var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<var>M</var> - 方阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;矩阵<var>M</var>的逆矩阵.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">对于非对称矩阵,通过LU分解来获得逆矩阵;对于对称矩阵,则使用LDL<sup>T</sup>分解.如果矩阵是奇异的,那么它的逆不存在.如果矩阵条件差,结果将因大误差而失真.这在LU分解过程中通过观察零或微小的主元元素来检测.如果检测到这样的元素,将返回适当的错误信息,而不是错误的解.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>inverse</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">49.361</span><span class="td">-13.556</span><span class="td">2.111</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-13.556</span><span class="td">3.778</span><span class="td">-0.5556</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2.111</span><span class="td">-0.5556</span><span class="td">0.1111</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var>*<var>B</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span> - 检查
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>lsolve</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 方程系数方阵;<br />
                <var><span class="vec">⃗</span>b</var> - 右手侧向量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp; 线性方程组 <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var>的解向量 <var><span class="vec">⃗</span>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">计算使用LU分解来处理非对称矩阵,并使用LDL<sup>T</sup>分解来处对理称矩阵.这就是为什么矩阵不需要是正定的.如果<var>A</var>是奇异的或病态的,将返回错误信息.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [8; 6; -4|6; 12; -3|-4; -3; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = [10; 20; 30]</code>' = [10&ensp;20&ensp;30]<br />
                <code><var>x</var> = <b>lsolve</b>(<var>A</var>; <var>b</var>)</code>' = [2.5&ensp;1.667&ensp;5] - 解向量<br />
                <code><var>A</var>*<var>x</var></code>' = [10&ensp;20&ensp;30] - 检查<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>clsolve</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 对称,正-定系数矩阵;<br />
                <var><span class="vec">⃗</span>b</var> - 右手侧向量.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang"> 采用Cholesky分解求线性方程组<var>A</var><var><span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var>得的解向量 <var><span class="vec">⃗</span>x</var> .</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">Cholesky比LU和LDL<sup>T</sup>分解快,因此一旦矩阵为对称和正-定,较之<b>lsolve</b>应优先采用该函数.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>([8; 6; -4|6; 12; -3|-4; -3; 9]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = [10; 20; 30]</code>' = [10&ensp;20&ensp;30]<br />
                <code><var>x</var> = <b>clsolve</b>(<var>A</var>; <var>b</var>)</code>' = [2.5&ensp;1.667&ensp;5]<br />
                <code><var>A</var>*<var>x</var></code>' = [10&ensp;20&ensp;30] - 检查<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>msolve</b>(<var>A</var>; <var>B</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 包含方程系数的方阵;<br />
                <var>B</var> - 右手侧矩阵(right-hand side matrix).
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;一般矩阵方程<var>AX</var> = <var>B</var>的解矩阵<var>X</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">类似于<b>lsolve</b>,该函数的矩阵<var>B</var>列包含多个右侧向量,而X矩阵列代表相应的解向量.通过这种方式,该函数可以并行求解多个线性方程组.矩阵<var>A</var>的LU/LDLT分解仅在开始时进行一次,结果被多次用于回代替换.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [8; 6; -4|6; 12; -3|-4; -3; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>join</b><sub>cols</sub>([10; 20; 30]; [40; 50; 60])</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span><br />
                <code><var>X</var> = <b>msolve</b>(<var>A</var>; <var>B</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">2.5</span><span class="td">8.71</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1.67</span><span class="td">2.67</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">11.43</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var>*<var>X</var></code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span> - 检查<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cmsolve</b>(<var>A</var>; <var>B</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>A</var> - 对称,正-定系数矩阵;<br />
                <var>B</var> - 右手侧矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">使用Cholesky 分解求解一般矩阵方程<var>A</var><var>X</var> = <var>B</var>中的<var>X</var> .</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;<span class="hang">与<b>clsolve</b>相似, 矩阵<var>B</var> 列包含多个右手侧向量(right-hand side vectors)且 矩阵<var>X</var> 列分别表示相应的向量解. 这种情况下,该函数可以同时求解多个线性方程组. 矩阵<var>A</var>的Cholesky 分解尽在开始进行1次且结果在回代时多次重新使用.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>([8; 6; -4|6; 12; -3|-4; -3; 9]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>对称</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>join</b><sub>cols</sub>([10; 20; 30]; [40; 50; 60])</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span><br />
                <code><var>X</var> = <b>msolve</b>(<var>A</var>; <var>B</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">2.5</span><span class="td">8.71</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1.67</span><span class="td">2.67</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">11.43</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var>*<var>X</var></code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span> - 检查<br />
            </span>
        </p>

        <p><b>聚合和插值函数</b></p>
        <p>所有的聚合函数对矩阵也有效. 这些函数的多个变量只能接受1个矩阵, 但可接受一个同时包含标量,向量和矩阵的列表,且顺序随意. 示例:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [0; 2| 4; 8]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 3; 1]</code><br />
            &emsp;&emsp;<code><b>sum</b>(10; <var>A</var>; <var>b</var>; 11)</code>' = 44
        </p>
        <p>当用于一个混合参数列表时,插值函数作用类似. 在这种情况下,矩阵将行连成标量数组. 然后, 插值作用于整个数组. 然而,对矩阵也有一个此类函数, 可对单个矩阵元素进行双重插值. 为此你需要明确3个参数: 前两个必须为标量(插值变量)第三则为矩阵, 示例如下:</p>

        <p>&emsp;&emsp;<code><b>take</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>x</var> - 行号;<br />
                <var>y</var> - 列号; <br />
                <var>M</var> - 矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;(标量) 返回矩阵 <var>M</var> 行号 <var>x</var> 列号 <var>y</var>的元素.<br />
            &emsp;&emsp;&emsp;&emsp;<em>注意</em>:&emsp;&emsp;若 <var>x</var> 和 <var>y</var> 为非整数, 将被舍入到最近的整数.<br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>take</b>(2; 3; <var>A</var>)</code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>line</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>x</var> - 沿行变化的插值变量;<br />
                <var>y</var> - 沿列变化的插值变量;<br />
                <var>M</var> - 矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">(标量) 基于 <var>x</var> 和 <var>y</var>值对<var>M</var>中元素的双重线性插值.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>line</b>(1.5; 2.5; <var>A</var>)</code>' = 7
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>spline</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p>
        <p>
            &emsp;&emsp;&emsp;&emsp;<em>参数</em>:&emsp;&emsp;<span class="hang">
                <var>x</var> - 沿行变化的插值变量;<br />
                <var>y</var> - 沿列变化的插值变量;<br />
                <var>M</var> - 矩阵.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>返回值</em>:&emsp;<span class="hang">(标量值)基于 <var>x</var> 和 <var>y</var>值对<var>M</var>中元素的双重Hermite样条曲线插值.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>示例</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>spline</b>(1.5; 2.5; <var>A</var>)</code>' = 6.625
            </span>
        </p>

        <p>你可以用插值函数来绘制矩阵数据图,如以下示例:</p>
        <p>&emsp;&emsp;<code>$Map{<b>spline</b>(<var>x</var>; <var>y</var>; <var>A</var>) @ <var>x</var> = 1 : <b>n_rows</b>(<var>A</var>) &amp; <var>y</var> = 1 : <b>n_cols</b>(<var>A</var>)}</code></p>
        <p>一份完整的可用的聚合和插值函数的列表在本手册前面已给出(见上文 "表达式/函数").</p>

        <p><b>运算符</b></p>
        <p>所有运算符可用于矩阵运算. 2个矩阵必须维数相同. 计算时元素-元素逐个进行且结果返回到输出矩阵中. 例如:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [0; 1; 2|3; 4; 5]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">5</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>B</var> = [11; 10; 9|8; 7; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">10</span><span class="td">9</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>A</var> + <var>B</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">11</span><span class="td">11</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">11</span><span class="td">11</span><span class="td"></span></span>
            </span>
        </p>
        <p>唯一的例外是乘法运算符"*" ,表示标准矩阵乘法. The element-wise (Hadamard或Schur) 积在 Calcpad中定义为函数: <b>hprod</b>. 矩阵乘法 <var>C</var><sub>m×p</sub> = <var>A</var><sub>m×n</sub> <var>B</var><sub>n×p</sub> 定义如下:每个元素 <var>c</var><sub>i&hairsp;j</sub> 通过 <var>A</var> 的第<var>i</var>行和 <var>B</var>的第 <var>j</var>列的点乘得到:</p>
        <p>&emsp;&emsp;<span class="eq"><var>c</var><sub>ij</sub> = <span class="dvr"><small><var>n</var></small><span class="nary">&Sigma;</span><small><var>k</var>&hairsp;=&hairsp;1</small></span><var>a</var><sub>ik</sub>&hairsp;<var>b</var><sub>kj</sub></span></p>
        <p>示例:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1; 2; 3|4; 5; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>B</var> = [6; 5|4; 3|2; 1]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">5</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>C</var> = <var>A</var>*<var>B</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">14</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">56</span><span class="td">41</span><span class="td"></span></span>
            </span>
        </p>

        <p>对混合的矩阵-向量和向量-矩阵间,所有二元运算符都支持. 这种情况下,向量作为列矩阵处理. 例如:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1; 2; 3|4; 5; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>b</var> = [6; 5; 4]</code><br />
            &emsp;&emsp;<code><var>A</var>*<var>b</var></code>' = [28&ensp;73]
        </p>
        <p>矩阵-标量和标量-矩阵之间的运算符也以元素顺序方式(element-wise manner)执行 . 与指定标量的运算对每个元素分别进行,结果返回到1个矩阵中. 示例:</p>
        <p>
            &emsp;&emsp;<code>[1; 2|3; 4]*5</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">15</span><span class="td">20</span><span class="td"></span></span>
            </span>
        </p>
        <h2 id="TOC_500">报告</h2>
        <p>所有的计算结果都会自动汇总成专业格式的计算报告.您可以打印它或使用 MS Word 打开进行编辑.除了数学表达式,您还可以添加标题、注释、表格和图片.</p>

        <h3 id="TOC_501">标题</h3>
        <p>标题是用双引号 (<b>"</b>) 括起来的文本.它的字体加粗并且比主要文本要大.</p>

        <h3 id="TOC_502">文本/注释</h3>
        <p>注释是用单引号 (<b>'</b>) 括起来的文本.如果它是行中的最后一个符号,您可以省略闭合引号.标题和注释可以包含任何符号,没有限制.它们之外的所有内容都被认为是数学表达式.然而,如果您在注释中放入任何公式,它们将不会被计算或格式化.由于最终的输出是呈现为 Html 文档,您可以在注释中使用 Html 和 CSS 来为您的计算报告提供额外的格式.</p>

        <h3 id="TOC_503">注释中的单位</h3>
        <p>除了使用原生单位,您还可以将所有值都输入为无单位,然后将单位放在注释中.在这种情况下,您将需要在方程中包含所有的单位转换因子.此外,还有一个选项可以为长度单位生成选择框 - <b>m</b>、<b>cm</b> 和 <b>mm</b>.您只需要在注释中插入 <b>%u</b>,无论您想要在哪里显示单位.当程序生成输入表单时(参见下文),它会检查代码中是否存在 <b>%u</b>.如果存在,它会自动在右上角添加一个单位选择组合框.当您从组合框中更改单位时,所有代码中的 <b>%u</b> 都会被填充为新的单位.您可以在下面尝试一下:</p>
        <table border="1" width="550">
            <thead>
                <tr>
                    <th>
                        Code(代码)
                    </th>
                    <th>
                        Output(输出)
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="line-height:200%;">
                        <code>"注释中的单位</code><br />
                        <code>'长度:'l = ?'%u</code><br />
                        <code>'面积:'l = ? %u&lt;sup&gt;2&lt;/sup&gt;</code><br />
                        <code>'体积:'l = ?'%u&lt;sup>3&lt;/sup&gt;</code><br />
                        <code>'缩放系数:'Units</code><br />
                    </td>
                    <td style="line-height:200%;">
                        <select id="Units" name="Units"><option value="m"> m </option><option value="cm"> cm </option><option value="mm"> mm </option></select>
                        <b>注释中的单位</b><br />
                        长度:  <var>l</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><br />
                        面积:  <var>l</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><sup>2</sup><br />
                        体积:  <var>V</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><sup>3</sup><br />
                        缩放系数:  <var id="UnitScale">Units</var>
                    </td>
                </tr>
            </tbody>
        </table>`
        <p>当您运行计算时,“单位”选项框将从输出中消失.只有单位会保留填写.程序还会创建一个变量<var>Units</var>,它将包含从选择的单位到米的转换因子.对于m、mm和cm,它们的值分别为1、100和1000.您可以在计算中使用它进行单位转换.例如,您可以创建一个条件块来显示报告中选择的单位:</p>
        <p>
            &emsp;&emsp;<span class="cond">#if</span> <var>Units</var> ≡ 1<br />
            &emsp;&emsp;&emsp;&emsp;'选择的单位为m<br />
            &emsp;&emsp;<span class="cond">#else if</span> <var>Units</var> ≡ 100<br />
            &emsp;&emsp;&emsp;&emsp;'选择的单位为cm<br />
            &emsp;&emsp;<span class="cond">#else if</span> <var>Units</var> ≡ 1000<br />
            &emsp;&emsp;&emsp;&emsp;'选择的单位为mm<br />
            &emsp;&emsp;<span class="cond">#end if</span>
        </p>

        <h3 id="TOC_504">使用 Html 和 CSS 进行格式化</h3>
        <p>Calcpad可以作为一个专业工程程序的开发平台.如果您不打算这样做,您可以跳过本章节.</p>
        <p><b>Html</b>(超文本标记语言)是一种用于格式化网页的标记语言.您可以更改字体类型、大小和粗细,文字的颜色,插入表格、图片等.这是通过添加特殊的元素,称为“标签”来完成的.每个标签都被尖括号括起来:“&lt;标签&gt;”.有些标签是成对使用的 - 开始标签“&lt;标签&gt;”和结束标签“&lt;/标签&gt;”.内容位于两者之间.例如,如果您想要将一些文本加粗,您可以使用以下标签:&lt;b&gt;<b>加粗文本</b>&lt;/b&gt;.即使您不是专业程序员,您也可以轻松学习一些基本的Html,以在Calcpad中使用:</p>
        <table border="1">
            <thead>
                <tr>
                    <th>
                        Html代码
                    </th>
                    <th>
                        输出
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code><b>&lt;b&gt;</b>粗体文本<b>&lt;/b&gt;</b></code>
                    </td>
                    <td>
                        <b style="color:black;">粗体文本</b>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;i&gt;</b>斜体文本<b>&lt;/i&gt;</b></code>
                    </td>
                    <td>
                        <i style="color:black;">斜体文本</i>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;u&gt;</b>带下划线文本<b>&lt;/u&gt;</b></code>
                    </td>
                    <td>
                        <u style="background:none;">带下划线文本</u>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;span style="color:red;"&gt;</b>红色文本<b>&lt;/span&gt;</b></code>
                    </td>
                    <td>
                        <span style="color:red;">红色文本</span>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>x<b>&lt;sup&gt;</b>上标<b>&lt;/sup&gt;</b></code>
                    </td>
                    <td>
                        <var>x</var>x<sup>上标</sup>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>x<b>&lt;sub&gt;</b>下标<b>&lt;/sub&gt;</b></code>
                    </td>
                    <td>
                        <var>x</var><sub>下标</sub>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;span style="font:16pt Times-New-Roman;"&gt;</b><br />&emsp;Times New Roman, 16pt<br /><b>&lt;/span&gt;</b></code>
                    </td>
                    <td>
                        <span style="font:16pt Times-New-Roman;">Times New Roman, 16pt</span>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>您只能在注释中使用Html标签,但也可以使它们影响表达式.例如:</p>
        <p style="margin-left: 2em;"><code>'&lt;span style="color:red;"&gt; 简单如 ' 2 + 2 '&lt;/span&gt;'</code></p>
        <p>将得到以下输出:</p>
        <p style="margin-left: 2em;"><span style="color:red;"> 简单如 2 + 2 = 4 </span></p>
        <p>我们只是用两个注释将表达式括起来.第一个注释包含了开标签 '<code>&lt;span style="color:red;"&gt;</code>',第二个注释包含了闭标签 <code>'&lt;/span&gt;'</code>.两个标签之间的内容被着为红色.请确保不要忘记引号.否则,程序将尝试解析Html代码作为数学表达式,并返回错误.样式代码:style="color:red" 被称为“内联CSS”(级联样式表),它用于格式化Html文档的外观.您可以从以下链接了解更多关于Html和CSS的内容:</p>
        <p><a href="http://www.w3schools.com/html/">http://www.w3schools.com/html/</a></p>
        <p><a href="http://www.w3schools.com/CSS/">http://www.w3schools.com/CSS/</a></p>
        <p>可以从互联网上找到一些免费的WYSIWYG(所见即所得)Html编辑器使用.</p>

        <h4>内容折叠</h4>
        <p>如果您有一些长而详细的计算,您可以选择将它们折叠在输出中.它们默认情况下是隐藏的,除了第一行,可以用作部分标题.您只需要将折叠部分放在一个带有类名为 "<b>fold</b>" 的 Html "<b>div</b>" 元素中,如下所示:</p>
        <p>
            &emsp;&emsp;<code>'&lt;div class="fold"&gt;</code><br />
            &emsp;&emsp;<code>'&lt;b&gt;标题&lt;/b&gt; (点击展开)</code><br />
            &emsp;&emsp;<code>'折叠的内容</code><br />
            &emsp;&emsp;<code>'&lt;/div&gt;</code>
        </p>
        <p>效果如下:</p>
        <div class="fold">
            <p style="margin-left: 2em;"><b>标题</b> (点击展开)</p>
            <p style="margin-left: 2em;">折叠的内容</p>
        </div>

        <h3 id="TOC_505">图片</h3>
        <p>在将图片插入Calcpad文档之前,您需要已经将其保存为文件.您可以使用一些图像编辑软件创建图片,并将其保存为*.png、*.gif或*.jpg文件.您可以使用一些免费软件,如Paint、Gimp、InkScape、DraftSight等.然后,您可以使用Html插入它.您只需要在所需位置的注释中放入以下文本:</p>
        <p style="margin-left: 2em;"><code>'&lt;img style="float:right" src="c:/Users/Me/Pictures/Picture1.png" alt="Picture1.png"&gt;</code></p>
        <p>当然,您需要将"<b>c:/Users/Me/Pictures/Picture1.png</b>"替换为实际图片的路径.文件可以是本地文件、网络文件或互联网上的文件.即使文件是本地文件,也始终使用正斜杠"<b>/</b>".如果图片位于当前工作表的同一文件夹中,您可以使用相对路径指定如下:"<b>./Picture1.png</b>".文本 <b>style="float:right;"</b> 将图片对齐到右侧,使文本在左侧浮动.否则,图片将成为文本流的一部分,并导致文本分割.作为 <b>style="float:right"</b> 的替代,您可以使用 <b>class="side"</b> 来实现相同的效果.</p>
        <p>您还可以使用工具栏上的<img alt="Image" height="24" src="Images/Image.png">按钮插入图片.您将被提示选择一个文件.当您点击"<b>打开</b>"时,所需的记录将插入到代码的开头.运行计算时,图片将出现在输出窗口中.</p>

        <h2 id="TOC_600">编程</h2>

        <h3 id="TOC_601">输入表单</h3>
        <p>如果您有一个长而复杂的问题,或者您想与他人共享您的解决方案,那么创建一个输入表单是一个好主意.使用Calcpad非常容易实现.只需将需要输入的值替换为问号"<b>?</b>",例如"<var>a</var> = ?".请注意,这样做后,您将无法直接点击<img alt="Play" height="24" src="Images/Play.png">计算结果.您必须先将其编译为输入表单.为此,单击<img alt="Form" height="24" src="Images/Form.png">按钮或按下键盘上的<b>F4</b>.</p>
        <p>代码将被隐藏,表单将被加载到主窗口的全宽"<b>输入</b>"框中.所有的文本和公式都将以Html格式呈现,受到保护,无法修改.除了注释中的问号外,每个"<b>?</b>"符号的出现都将生成一个输入框.准备好使用的输入表单如下所示:</p>
        <p><img alt="Sample3" width="700" src="Images/Sample3.zh.png"></p>
        <p>现在您需要填写输入框并点击<img alt="Play" height="24" src="Images/Play.png">来计算结果.结果将显示在"<b>输出</b>"框中.</p>
        <p><img alt="Sample4" width="700" src="Images/Sample4.zh.png"></p>
        <p>要返回输入模式,请再次点击<img alt="Play" height="24" src="Images/Play.png">以关闭按钮.输入数据将保持自上次输入以来的不变.如果您需要修改源代码,您需要点击<img alt="Form" height="24" src="Images/Form.png">按钮解锁它."<b>代码</b>"框将再次显示在主窗口的左侧.输入数据将附加到问号上.如果您将鼠标悬停在其中一个上面,您将看到相应的值.单击问号以更改它.编辑代码完成后,您可以将其重新编译为输入表单.输入值将填入相应的字段.最后,您可以将文档保存为"<b>*.cpd</b>"文件.当您打开此类文件时,它将直接显示为输入表单模式.与简单的文本文件相比,此格式更方便使用,具有以下优点:</p>
        <ul>
            <li>用户可以清楚地看到应输入哪些参数.您还可以提供图片和附加说明.这对用户来说更容易理解,特别是如果程序是由其他人开发的;</li>
            <li>源代码的其余部分受到保护,除非您有意解锁它.这可以防止不熟悉的用户意外损坏计算公式.</li>
        </ul>
        <p>如果将文档保存为"<b>*.cpdz</b>"文件,则无法再访问源代码.在Calcpad中无法解锁它.此外,没有人可以在外部文本编辑器中编辑文件,因为它是编码的.这样,您可以保护源代码免受未经授权的复制、查看和修改.</p>
        <p>您可以在代码的任何位置放置问号"<b>?</b>",例如:</p>
        <p style="margin-left: 2em;">2 + ?</p>
        <p style="margin-left: 2em;">2 + <input type="text" size="2"></p>
        <p>然后,您可以输入一个值并计算结果.这种方法不推荐用于复杂的问题,因为程序逻辑变得不清晰且难以理解.</p>

        <h4>使用Html和CSS创建高级UI</h4>
        <p>除了简单的输入框外,您可以在工作表中使用一些高级UI元素,例如"<b>select</b>"(组合框)、"<b>radio</b>"按钮和"<b>checkboxes</b>".由于Calcpad的所有输出都被呈现为Html文档,因此您可以使用Html和CSS来实现这一目的.但是,Calcpad仅接受来自文本框的输入.因此,需要将每个其他UI元素映射到某个文本框.这是通过将文本框包含在具有特定<b>id</b>的外部html元素(段落或div)中来执行的.相同的id必须分配为源UI元素的<b>name</b>或<b>data-target</b>属性.然后,源元素值属性的内容将自动填充到目标文本框中.您可以使用以下示例代码:</p>
        <p><b>选择框:</b></p>
        <p>代码:</p>
<pre>
&emsp;&emsp;'选择: &lt;选择名称="<b class="err">target1</b>"&gt;
&emsp;&emsp;'&lt;option value="11;12"&gt;x1; y1&lt;/option&gt;
&emsp;&emsp;'&lt;option value="21;22"&gt;x2; y2&lt;/option&gt;
&emsp;&emsp;'&lt;option value="31;32"&gt;x3; y3&lt;/option&gt;
&emsp;&emsp;'&lt;/select&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target1</b>"&gt; 值:'x = ? {21}','y = ? {22}'&lt;/p&gt;
</pre>
        <p>输出:</p>
        <p>
            &emsp;&emsp;选择: <select name="target1">
                <option value="11;12" id="line-3">x1; y1</option>
                <option value="21;22" id="line-4">x2; y2</option>
                <option value="31;32" id="line-5">x3; y3</option>
            </select><br />&emsp;&emsp;...
        </p>
        <p id="target1">&emsp;&emsp;值: <span class="eq"><var>x</var> = <input type="text" size="2" name="Var" value="21">&#8202;</span> , <span class="eq"><var>y</var> = <input type="text" size="2" name="Var" value="22">&#8202;</span> </p>
        <p><b>点选圈:</b></p>
        <p>代码:</p>
<pre>
&emsp;&emsp;'&lt;p&gt;选择: 
&emsp;&emsp;'&lt;input name="<b class="err">target2</b>" type="radio" id="opt1" value="1"/&gt;
&emsp;&emsp;'&lt;label for="opt1"&gt;option 1&lt;/label&gt;
&emsp;&emsp;'&lt;input name="<b class="err">target2</b>" type="radio" id="opt2" value="2"/&gt;
&emsp;&emsp;'&lt;label for="opt2"&gt;option 2&lt;/label&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target2</b>"&gt;值-'opt = ? {2}'&lt;/p&gt;
</pre>
        <p>输出:</p>
        <p>
            &emsp;&emsp;选择:
            <input name="target2" type="radio" id="opt1" value="1" />
            <label for="opt1">选项 1</label>
            <input name="target2" type="radio" id="opt2" value="2" />
            <label for="opt2">选项 2</label><br />&emsp;&emsp;...
        </p>
        <p id="target2">&emsp;&emsp;<span class="eq"><var>opt</var> = <input type="text" size="2" name="Var" value="2">&#8202;</span> </p>
        <p><b>勾选框:</b></p>
        <p>代码:</p>
<pre>
&emsp;&emsp;'&lt;p&gt;&lt;输入名称="<b class="err">target3</b>" type="checkbox" id="chk1" value="3"/&gt;
&emsp;&emsp;'&lt;label for="chk1"&gt;Checkbox 1&lt;/label&gt;&lt;/p&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target3</b>"&gt;Value -'chk = ? {3}'&lt;/p&gt;
</pre>
        <p>输出:</p>
        <p>
            &emsp;&emsp;<input name="target3" type="checkbox" id="chk1" value="3" />
            <label for="chk1">勾选框1</label><br />&emsp;&emsp;...
        </p>
        <p id="target3">&emsp;&emsp;<span class="eq"><var>chk</var> = <input type="text" size="2" name="Var" value="3">&#8202;</span> </p>
        <p>从第一个示例中可以看出,一个"value"属性可以包含多个值,用分号";"分隔.在这种情况下,您必须在目标段落中提供相应数量的文本框.您可以复制上面的代码,添加任意多的选项,并编写自己的标签和值.您还可以更改名称和ID,但请确保所有源名称与目标ID完全匹配,并且不存在重复的ID.</p>

        <h3 id="TOC_602">输出控制</h3>
        <p>您可以轻松指定代码中哪些部分在输出中可见或隐藏.与条件执行不同,隐藏的代码始终被计算.它只是不显示出来.以下关键字可用于此目的:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Hide</span> - 从当前行后起隐藏报告内容;</li>
            <li><span class="cond">#Pre</span> - 仅在"input(输入)" 模式 (详见下文 ""<a href="#TOC_601">输入表</a>" )显示内容;</li>
            <li><span class="cond">#Post</span> - 尽在"output(输出)"模式下显示并在"input(输入)"模式下隐藏内容;</li>
            <li><span class="cond">#Show</span> - 总是显示内容(覆盖其他所有关键字);</li>
        </ul>
        <p>上述每个关键字都会影响当前行之后的内容,并覆盖前一个关键字.您可以使用它们来隐藏不应该显示的长时间重复的计算.您可以使用<span class="cond">#Pre</span>命令添加一些关于填充输入数据的说明,使用<span class="cond">#Post</span>隐藏数据输入期间的计算算法.</p>
        <p>您还可以按以下方式修改方程的显示:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Val</span> - 仅显示结果的数值;</li>
            <li><span class="cond">#Equ</span> - 同时显示方程式和计算结果(默认);</li>
            <li><span class="cond">#Noc</span> - 仅显示方程式,不显示结果(不计算).</li>
        </ul>
        <p>上述每个关键字都会覆盖其他关键字.您可以使用<span class="cond">#Val</span>创建一个带有值但没有公式的表格,就像在Excel中一样.</p>

        <h3 id="TOC_603">条件执行</h3>
        <p>有时解决方案必须根据一些中间值以不同的方式继续.类似于其他编程语言,Calcpad中也包含了这个功能.它被称为"条件执行块",具有以下一般形式:</p>
        <ul style="list-style-type:none;">
            <li><code><span class="cond">#If</span> <b>条件1</b></code></li>
            <li style="margin-left: 2em;">如果条件1满足将要执行的代码段</li>
            <li><code><span class="cond">#Else If</span> <b>条件2</b></code></li>
            <li style="margin-left: 2em;">如果条件1满足将要执行的代码段</li>
            <li><code><span class="cond">#Else If</span> <b>条件3</b></code></li>
            <li style="margin-left: 2em;">如果条件满足将要执行的代码段</li>
            <li>. . .</li>
            <li><code><span class="cond">#Else</span></code></li>
            <li style="margin-left: 2em;">如果所有条件无一满足将要执行的代码段</li>
            <li><code><span class="cond">#end if</span></code></li>
        </ul>
        <p>简短形式:</p>
        <ul style="list-style-type:none;">
            <li><code><span class="cond">#If</span> <b>条件</b></code></li>
            <li style="margin-left: 2em;">如果条件满足将要执行的代码段</li>
            <li><code><span class="cond">#Else</span></code></li>
            <li style="margin-left: 2em;">如果条件不满足将要执行的代码段</li>
            <li><code><span class="cond">#end if</span></code></li>
        </ul>
        <p>或:</p>
        <ul style="list-style-type:none;">
            <li><code><span class="cond">#If</span> <b>条件</b></code></li>
            <li style="margin-left: 2em;">如果条件满足将要执行的代码段</li>
            <li><code><span class="cond">#end if</span></code></li>
        </ul>
        <p>条件块不仅会影响计算路径,还会影响文本和图像等报告内容."#"符号必须是该行的第一个符号.在"<b>condition</b>"的位置上,您可以放置任何有效的表达式.通常使用比较运算符,如"<span class="cond">#If</span> <var>a</var> &lt; 0",但这不是必须的.如果计算结果为任何非零数字,则假定满足条件.否则,条件不满足.任何绝对值&le; 0.00000001的结果都被认为是零.</p>
        <p>让我们再次看一下我们之前使用的二次方程示例.如果我们输入"<var>c</var> = 5",则判别式将为负数,结果将为<span class="err">NaN</span>.这不是一个很智能的程序结束方式.我们需要做的是检查"<var>D</var> &lt; 0",如果是,则提供一个易于理解的消息.否则,我们必须计算根.我们可以使用条件执行来实现这一点,具体如下:</p>
        <p><img alt="Sample2" width="700" src="Images/Sample2.zh.png"></p>

        <h3 id="TOC_604">迭代块</h3>
        <p>您可以在Calcpad程序中使用简单的迭代.为此,您需要定义一个"<b>repeat-loop</b>"块:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Repeat</span> <var>n</var></li>
            <li style="margin-left: 2em;">重复执行的代码段</li>
            <li><span class="cond">#Loop</span></li>
        </ul>
        <p>符号<var>n</var>代表重复次数.您可以在<var>n</var>中放置一个数字、变量或任何有效的表达式.如果表达式的结果不是整数,则四舍五入为最近的整数.您可以在块内放置<span class="cond">#Break</span>来提前退出重复循环.只有当您将其与条件块相结合时,它才有意义.否则,它将始终在同一行中中断,而不执行任何循环.典型的"重复-中断-循环"看起来像这样:</p>
        <ul style="list-style-type:none;">
            <li><code class="cond">#Repeat</code></li>
            <li style="margin-left: 2em;">重复执行的代码段</li>
            <li style="margin-left: 2em;"><code class="cond">#If</code> 条件</li>
            <li style="margin-left: 4em;"><code class="cond">#Break</code></li>
            <li style="margin-left: 2em;"><code class="cond">#End if</code></li>
            <li style="margin-left: 2em;">其他代码</li>
            <li><code class="cond">#Loop</code></li>
        </ul>
        <p>您可以使用<code class="cond">#Continue</code>代替<code class="cond">#Break</code>.程序将跳过剩余的行,返回到条件块的顶部,并继续下一次迭代.只有当您确定条件将被满足并且循环迟早会中断时,才可以省略重复次数<var>n</var>.无论如何,为了避免无限循环,如果没有其他指定,迭代次数限制为100,000次.</p>
        <p>除了重复计算,您还可以使用循环生成重复的报告内容(如表格行).如果您想隐藏迭代细节,可以使用输出控制指令(参见前一节).例如,您可以使用<span class="cond">#Hide</span>和<span class="cond">#Show</span>语句将"重复-循环"块括起来.</p>

        <h3 id="TOC_605">交互式(逐步)执行</h3>
        <p>您可以创建一个Calcpad工作表,通过在特定行定义"断点"来进行交互式(逐步)执行.这将允许用户查看中间结果,并在需要时输入一些额外的输入数据.有两个特殊的关键字,您可以用于此目的:</p>
        <ul style="list-style-type:none;">
            <li><code class="cond">#Pause</code> - 计算到当前行,显示结果并等待用户恢复;</li>
            <li><code class="cond">#Input</code> - 在当前行呈现输入表单,并等待用户输入数据和恢复.</li>
        </ul>
        <p>当计算过程中止,程序在报告的结尾给出如下提示信息:</p>
        <p>&emsp;&emsp;<span class="err">Paused!</span> 按 <b>F5</b>  <a href="#0" data-text="continue">继续</a> 或 <b>Esc</b>  <a href="#0" data-text="cancel">取消计算</a>.</p>
        <p>您可以通过按下<b>F5</b>、点击链接或再次点击<img alt="Play" height="24" src="Images/Play.png">按钮来恢复执行.在单个工作表中可以设置多个断点.当使用<code class="cond">#Input</code>关键字时,在显示当前输入表单之前,将计算前一节.通过这种方式,计算的阶段会重叠,如下面的示例所示:</p>
        <p><img alt="Interactive" height="360" src="Images/Interactive.png"></p>
        <p>此外,用户可以随时从键盘上按下"<b>Pause/Break</b>"或"<b>Ctrl + Alt + P</b>"来暂停执行.执行将在当前行暂停,就像检测到<code class="cond">#Pause</code>一样.</p>

        <h3 id="TOC_606">模块(包含)</h3>
        <p>Calcpad允许您在工作表中包含来自外部文件的内容.如果您在不同的工作表中重复使用某些代码片段,您可以将其组织成模块,并多次重用.此外,如果您有一个较长的工作表,您可以将其拆分为易于维护的模块.然后,您可以使用以下语句将它们包含到主文件中:</p>
        <p>&emsp;&emsp;<span class="cond">#include</span> <em class="macro">文件名</em></p>
        <p>"<em class="macro">文件名</em>"必须包含到本地文件的完整路径.如果文件与当前文件夹相同,您只需指定文件名即可.</p>
        <p>默认情况下,Calcpad将包含外部模块的全部内容.然而,您可以通过使其成为局部的来防止某些部分被包含.要在模块中开始一个"局部"部分,请添加一个新行,其中包含<span class="cond">#local</span>关键字.要结束一个"局部"部分(或开始一个"全局"部分),请添加一个新行,其中包含<span class="cond">#global</span>关键字.Calcpad支持多级包含.这意味着包含文件可以引用其他文件,依此类推.</p>

        <h3 id="TOC_607">宏和字符串变量</h3>
        <p>宏和字符串变量是在单个文件中组织代码和防止重复的便捷方式.它们可以是单行的,也可以是多行的.与字符串变量不同,宏可以具有参数.您可以使用以下语句来定义它们:</p>
        <p>
            单行字符串变量:<br />
            &emsp;&emsp;<span class="cond">#def</span>
            <em class="macro">variable_name$</em> <span class="o">=</span> <em>内容</em>
        </p>
        <p>
            多行字符串变量:<br />
            &emsp;&emsp;<span class="cond">#def</span> <em class="macro">variable_name$</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>内容行 1</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>内容行 2</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>...</em><br />
            &emsp;&emsp;<span class="cond">#end def</span>
        </p>
        <p>
            单行字符串宏:<br />
            &emsp;<span class="cond">#def</span>
            <em class="macro">macro_name$</em>(<em class="macro">param1$</em><span class="o">;</span> <em class="macro">param2$</em><span class="o">;</span>...) <span class="o">=</span> <em>内容</em>
        </p>
        <p>
            多行字符串宏:<br />
            &emsp;&emsp;<span class="cond">#def</span> <em class="macro">macro_name$</em>(<em class="macro">param1$</em><span class="o">;</span> <em class="macro">param2$</em><span class="o">;</span>...)<br />
            &emsp;&emsp;&emsp;&emsp;<em>内容行 1</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>内容行 2</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>...</em><br />
            &emsp;&emsp;<span class="cond">#end def</span>
        </p>

        <p>字符串变量、宏及其参数的名称可以包含小写和大写的拉丁字母和下划线"_".它们必须以"$"符号开头.内容可以是任何字符串.它不一定是有效的Calcpad表达式,因为在这个阶段它不会被解析器处理.但是,在其中不允许其他的宏/字符串变量定义.您只能插入对先前定义的宏/字符串变量的引用.此外,宏内部不支持输入字段"?".这个功能将在以后的版本中开发.您可以在宏中使用<span class="cond">#include</span>,但前提是所包含的文件不包含其他宏.</p>
        <p>在定义字符串变量之后,您可以在代码的任何地方使用它,只需写入它的名称(以"$"结尾).对于宏也是一样,但您还需要为参数指定值.宏和字符串变量在实际解析之前进行预处理和重写.结果是生成中间(展开)代码.您可以通过在"<b>输出</b>"窗口下方勾选"<b>展开的代码</b>"复选框来查看它.</p>
        <p>如果在宏预处理过程中发生任何错误,将显示展开的代码以及错误信息.错误描述中的行号是指您的初始代码.如果预处理成功完成,则对展开的代码进行解析和计算,就像正常情况下一样.如果在这个阶段检测到错误,它们将显示在输出中.错误描述中的行号是指展开的代码.您可以通过点击行号上的链接转到相应的行.</p>

        <h2 id="TOC_700">结果</h2>
        <p>您可以通过按下<b>F5</b>或单击<img alt="Play" height="24" src="Images/Play.png">按钮来运行解决方案.结果将出现在"<b>输出</b>"框中.您无法编辑输出内容,但可以选择、复制和打印它.为此,您可以使用右侧"<b>输出</b>"框上方的工具栏.您还可以使用上下文菜单中的其他命令.如果您在"<b>输出</b>"框内右键单击,将显示一个弹出菜单,其中包含其他命令.本手册中提供了详细的描述.</p>
        <p>自版本6.5.3以来,您可以使用"☑<b>自动运行</b>"模式.当勾选此选项时,每次更改代码并移动到另一行时,结果都会刷新.如果需要手动同步结果,可以按"<b>Ctrl + Enter</b>".此外,输出窗口将滚动以匹配源代码中的当前位置.您也可以通过双击输入窗口来实现相同的效果.</p>

        <h3 id="TOC_701">替代</h3>
        <p>Calcpad可以在输出中的所有公式中替代变量的值,就在答案之前:</p>
        <p style="margin-left: 2em;"><var>x</var><sub>1</sub> = <span class="dvc"> -<var>b</var> – <span class="root">√</span><span class="ovr"><var>D</var></span><span class="dvl"></span>2·<var>a</var></span> = <span class="dvc"> -3 – <span class="root">√</span><span class="ovr">89</span><span class="dvl"></span>2·4</span> = -1.55</p>
        <p>为此,您需要在程序窗口底部勾选"<b>替代</b>"复选框.这样可以方便地查看和检查结果.当需要由主管、教师等检查计算时,这一点非常重要.这也是与电子表格软件的优势之一,因为实际的公式是隐藏在单元格中的.</p>
        <p>如果您不需要替代,可以取消选中此选项.然后答案将直接遵循计算公式:</p>
        <p style="margin-left: 2em;"><var>x</var><sub>1</sub> = <span class="dvc"> -<var>b</var> – <span class="root">√</span><span class="ovr"><var>D</var></span><span class="dvl"></span>2·<var>a</var></span> = -1.55</p>
        <p>之后,如果将鼠标放在任何变量上,将显示带有相应值的工具提示.</p>


        <h3 id="TOC_702">舍入</h3>
        <p>舍入是由小数点后的数字个数<var>n</var>指定的.它输入到程序窗口底部的"<b>舍入</b>"输入框中.变量<var>n</var>的值可以在"0"和"15"之间.如果输入"0",所有结果将舍入为整数.如果值小于"0"或大于"15",则会采用相应的限制.</p>
        <p>然而,舍入可能会遇到一些潜在的问题.如果结果小于10<sup>-<var>n</var></sup>并且您将其舍入为小数点后<var>n</var>位数,结果将只包含零.因此,Calcpad采用了一些高级规则:如果舍入后输出的有效数字少于<var>n</var>位数,则会扩展到<var>n</var>位有效数字.即使如此,如果数字太小,很难计算小数点后的零的个数.因此,在这种情况下,输出将转换为具有<var>n</var>位数字的浮点格式.当总位数大于2<var>n</var>时,小数部分将被截断.通过这种方式,输出变得更容易阅读,同时至少提供2<var>n</var>位有效数字.您可以在下面看到几个示例,这些示例是针对(<var>n</var> = 3)获得的.</p>
        <ul style="list-style-type:none;">
            <li>0.000001∙<var>π</var> = 3.14E-06</li>
            <li>0.001∙<var>π</var> = 0.00314</li>
            <li>0.1∙<var>π</var> = 0.314</li>
            <li>1∙<var>π</var> = 3.142</li>
            <li>1000∙<var>π</var> = 3141.59</li>
            <li>1000000∙<var>π</var> = 3141593</li>
        </ul>
        <p>舍入仅影响输出中数字的显示方式.在内部,所有数字都以最大可能的精度存储.这就是为什么,如果您打印输出并尝试使用报告中的数字重复计算,可能会得到一些小的差异.这是因为您使用的是舍入后的值而不是实际值.</p>
        <p>您可以使用<code class="cond">#Round</code> <var>n</var>关键字在工作表中覆盖全局舍入,其中<var>n</var>是小数点后的位数(从"0"到"15").</p>

        <h3 id="TOC_703">格式化</h3>
        <p>Calcpad不仅计算公式,还可以根据您的源代码生成专业外观的报告.它使用Html格式化输出.它被广泛认可,可以让您在Web上发布您的计算.您可以选择两种不同的方程格式化样式:"专业"和"内联".专业样式使用分数线、大括号、小括号、根号等.分子和分母显示在上下两行.内联样式使用斜线来显示除法,所有符号都排列在一行中.以下格式化规则适用:</p>
        <ul>
            <li>间隔会自动保持.</li>
            <li>变量以<var>斜体</var>格式显示.</li>
            <li>乘法运算符"*"被替换为"∙".</li>
            <li>指数运算符"^"格式化为上标.</li>
            <li>下划线"_"格式化为下标.</li>
            <li>平方根函数被替换为根号"<span class="root">√</span><span class="ovr">&nbsp;&nbsp;</span>".</li>
        </ul>
        <p>下表中提供了不同情况下的几个格式化示例:</p>
        <table style="margin-left:24px; max-width: 300px;" border="1">
            <thead>
                <tr>
                    <th style="width:50%">Text</th>
                    <th>Html</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>x&emsp;+&emsp;3</code></td>
                    <td><var>x</var> + 3</td>
                </tr>
                <tr>
                    <td><code>x-3</code></td>
                    <td><var>x</var> – 3</td>
                </tr>
                <tr>
                    <td><code>3*x</code></td>
                    <td>3∙<var>x</var></td>
                </tr>
                <tr>
                    <td><code>(x + 1)/3</code></td>
                    <td>(<var>x</var> + 1)/3 or <span class="dvc"><var>x</var> + 1<span class="dvl"></span>3</span></td>
                </tr>
                <tr>
                    <td><code>x+3 * y</code></td>
                    <td><var>x</var> + 3∙<var>y</var></td>
                </tr>
                <tr>
                    <td><code>sqr(x+3)</code></td>
                    <td><span class="root">√</span><span class="ovr"><var>x</var> + 3</span></td>
                </tr>
                <tr>
                    <td><code>x_1^3</code></td>
                    <td><var>x</var><sub>1</sub><sup>3</sup></td>
                </tr>
                <tr>
                    <td><code>sin(x)</code></td>
                    <td><b>sin</b>(<var>x</var>)</td>
                </tr>
            </tbody>
        </table>
        <p>Html格式使报告比相应的纯文本更易于阅读和检查.您还可以在注释中插入其他Html代码,这将影响最终的外观.通过这种方式,您可以使用Calcpad代码构建专业的Web应用程序.为此,您还需要Calcpad的云版本.</p>

        <h3 id="TOC_704">缩放</h3>
        <p>您可以在输出窗口中缩放文本大小.按住"<b>Ctrl</b>"键并旋转鼠标滚轮.向前旋转将放大,向后旋转将缩小.</p>

        <h3 id="TOC_705">保存输出</h3>
        <p>您可以将输出保存为<b>Html</b>文件.与输入文件不同,它无法使用Calcpad进行修改.另一方面,每个人都可以在没有Calcpad的情况下查看和打印您的计算.Html文件可以在任何计算机上使用Web浏览器或类似Word的办公程序打开.</p>
        <p>您可以通过单击输出框上的<img alt="Save" height="24" src="Images/Save.png">按钮来保存文件.然后选择文件名并单击"<b>保存</b>".</p>

        <h3 id="TOC_706">打印</h3>
        <p>您可以通过单击<img alt="PrintPreview" height="24" src="Images/PrintPreview.png">按钮打印输出.通常,在计算后执行打印.单击按钮时,将显示打印预览对话框:</p>
        <p><img alt="Sample5" height="360" src="Images/Sample5.zh.png"></p>
        <p>它允许您设置打印布局和边距.单击<img alt="Page Setup" height="24" src="Images/PageSetup.png">按钮更改纸张大小和类型.最后,按下<img alt="Print" height="24" src="Images/Print.png">按钮.将出现打印机选择对话框.选择首选打印机,然后单击"<b>打印</b>".</p>
        <p><img alt="PrintDialog" height="360" src="Images/PrintDialog.png"></p>
        <p>在Calcpad中打印使用Windows和Edge的内置功能.上面的截图在您的计算机上可能会有所不同,具体取决于您使用的版本.或者,您可以在输出窗口中右键单击,然后从上下文菜单中选择"<b>打印预览…</b>".如果选择"<b>打印</b>",则将跳过预览并直接进行打印.</p>

        <h3 id="TOC_707">复制</h3>
        <p>您可以通过单击输出窗口上的<img alt="Copy" height="24" src="Images/Copy.png">按钮一次复制整个输出.然后,您可以将其粘贴到任何其他程序中.如果目标程序支持Html,例如Word,则将保留格式.否则,内容将作为纯文本粘贴.</p>

        <h3 id="TOC_708">导出到Word</h3>
        <p>您可以通过单击<img alt="Word" height="24" src="Images/Word.png">按钮直接在<b>MS Word</b>中打开结果.它必须安装在计算机上,但不需要预先打开.这种方法比复制粘贴更容易,并提供了一些额外的好处.如果输出是使用专业公式格式选项获得的,Calcpad将使用"<b>*.docx</b>"文件格式进行导出.这是最新版本的<b>MS Word</b>的本机格式,将自动打开.如果您有<b>Open Office</b>或<b>Libre office</b>,将使用相应的程序代替.如果您当前没有安装任何文本编辑器,文件将保存到磁盘,但不会打开.您可以稍后转到相应的文件夹并手动打开它.公式将作为<b>MathType</b>对象导出,并可以在Word中进行修改.但是,可能会丢失部分Html格式.支持图像、表格和大多数常见标签.如果选择了行内公式格式,Calcpad将使用<b>Html</b>文件进行导出.它将保留大部分格式,但公式将成为文档文本的一部分.</p>

        <h3 id="TOC_709">导出到PDF</h3>
        <p>将报告保存为<b>pdf</b>文件是另一种制作计算的纸质副本的好方法.单击<img alt="PDF" height="24" src="Images/Pdf.png">按钮,然后选择文件的名称和位置.程序将输出保存到指定的文件,并使用默认查看器打开它.pdf始终以A4页面大小生成.</p>
        <p>或者,您可以使用pdf打印机.互联网上有很多免费的pdf打印机.只需下载并安装一个即可.安装完成后,打印过程与任何其他打印机并没有太大区别.上面提供了从Calcpad打印的详细说明.</p>

        <h2 id="TOC_800">文件操作</h2>
        <p>在Calcpad中输入的数据可以保存到磁盘并多次重用.支持的文件格式为"<b>*.txt</b>"、"<b>*.cpd</b>"和"<b>*.cpdz</b>".输入表单必须保存为"<b>*.cpd</b>"和"<b>*.cpdz</b>"文件,文本脚本必须保存为"<b>*.txt</b>"文件."<b>*.cpd</b>"和"<b>*.cpdz</b>"文件类型都与Calcpad相关联,并且可以通过双击打开.两种格式之间的主要区别在于"<b>*.cpd</b>"是文本文件,可以进行编辑,而"<b>*.cpdz</b>"是二进制文件,只能被执行.其中的源代码受到保护,防止查看、复制和修改.</p>

        <h3 id="TOC_801">新建</h3>
        <p>单击<img alt="New" height="24" src="Images/New.png">按钮可以开始一个新文件.这将清除文件名和源代码.如果当前文件未保存,将提示您进行保存.</p>
        <p><img alt="PromptSave" height="160" src="Images/PromptSave.zh.png"></p>
        <p>如果您选择"<b>Yes</b>",将出现"<b>文件保存</b>"对话框.输入文件名并单击"<b>保存</b>".这样,您就可以在被清除之前保存您的数据.如果您选择"<b>Cancel</b>",您将中断命令,一切都将保持不变.</p>

        <h3 id="TOC_802">打开</h3>
        <p>您可以使用<img alt="Open" height="24" src="Images/Open.png">按钮打开现有文件.将出现一个文件选择对话框.默认情况下,活动文件扩展名为"*.cpd".如果您要搜索"*.txt"或"*.cpdz"文件,请在对话框底部选择相应的类型.然后找到所需的文件,按"<b>打开</b>"或双击文件.它将被加载到Calcpad中,并且文件名将显示在标题栏中.</p>

        <h3 id="TOC_803">保存</h3>
        <p>您可以点击<img alt="Save" height="24" src="Images/Save.png">按钮来保存当前文件.如果文件尚未保存,将提示您选择路径和名称.否则,它将被重新写入当前位置.</p>

        <h3 id="TOC_804">另存为...</h3>
        <p>如果您需要使用不同的名称保存当前文件,请选择"<b>文件/另存为...</b>"菜单命令.将显示一个文件选择对话框.选择文件路径和名称,然后点击"<b>保存</b>".</p>
        <hr />
        <p>2024.12.08——ChengChu编辑.</p>
    </div>
    <script src="jquery-3.6.3.min.js"></script>
    <script>
        if (window.jQuery) {

            function getTargetId(element) {
                var id = $(element).attr("name");
                if (id != null && id.length > 0)
                    return id;

                return $(element).data("target");
            }

            function getValue(id, source) {
                var value = "";
                var target = $("#" + id + " input");
                var domObj = target.get(0);
                if (domObj == null || domObj.Length == 0) {
                    target = $("#" + id + " .eq u");
                    target.each(function () {
                        value += $(this).text() + ";";
                    });
                    $(source).prop('disabled', true);
                }
                else {
                    target.each(function () {
                        value += $(this).val() + ";";
                    });
                }
                if (value.length > 1) {
                    value = value.slice(0, -1);
                }
                return value;
            }

            function Toggle(button) {
                var list = $("#list" + button.attr("id").substring(6));
                if (list.css("display") == "none") {
                    list.css("display", "list-item");
                    button.html("&minus;");
                }
                else {
                    list.css("display", "none");
                    button.html("+");
                }
            }

            $(document).ready(function () {

                $("#Units").change(function () {
                    $(".Units").text($(this).val());
                });

                $(".exp").click(function () {
                    Toggle($(this));
                });

                $(".fold > :first-child").click(function () {
                    if ($(this).parent().hasClass("fold")) {
                        $(this).parent().removeClass("fold").addClass("unfold");
                    }
                    else {
                        $(this).parent().removeClass("unfold").addClass("fold");
                    }
                });

                $("select").each(function (index) {
                    if ($(this).prop("id") != "Units") {
                        var id = getTargetId(this);
                        if (id != null && id.length > 0) {
                            var value = getValue(id, this);
                            $(this).val(value);
                        }
                    }

                });

                $("select").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            var values = $(this).val().split(";");
                            target.each(function (index) {
                                $(this).val(values[index]);
                            });
                        }
                    }
                });

                $("input:radio, input:checkbox").each(function (index) {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var value = getValue(id, this);
                        $(this).prop("checked", $(this).val() == value);
                    }
                });

                $("input:radio, input:checkbox").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            if ($(this).prop("checked")) {
                                var values = $(this).val().split(";");
                                target.each(function (index) {
                                    $(this).val(values[index]);
                                });
                            }
                            else if ($(this).prop("type") == "checkbox") {
                                target.each(function () {
                                    $(this).val("0");
                                });
                            }
                        }
                    }
                });

                $(".money").each(function () { $(this).text(Number(($(this).text())).toFixed(2)); });

                $(window).scroll(function () {
                    if ($(".menu").is(":visible")) {
                        var scrollTop = $(window).scrollTop();
                        var id;
                        var min = 1e20;
                        $("h2, h3").each(function () {
                            var d = scrollTop - $(this).offset().top + 50;
                            if (d > 0 && Math.abs(d) < min) {
                                console.log(d);
                                min = d;
                                id = $(this).attr("id");
                            }
                        });
                        $(".active").removeClass("active");
                        var element = $("a[href$='#" + id + "']")
                        if (!element.is(":visible")) {
                            $(".exp").html("+");
                            $(".menu li ul").css("display", "none");
                            var b = "#button" + id.substring(4, id.length - 2);
                            Toggle($(b));
                        }
                        element.addClass("active");
                    }
                });
            });
        }
    </script>
</body>
</html>
