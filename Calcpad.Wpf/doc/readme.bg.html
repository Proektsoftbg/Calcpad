<!DOCTYPE html>
<html lang="bg">
<head>
    <title>Calcpad Readme</title>
    <meta charset="UTF-8">
    <style>
        .menu {
            position: fixed;
            left: 780px;
            top: 0;
            font-size: 11pt;
            list-style: none;
            margin: 0;
            line-height: 125%;
        }

        .menu li {
            margin-left: -14px;
        }

            .menu li ul {
                font-size: 11pt;
                list-style: none;
                display: none;
            }

        .active {
            color: black !Important;
            font-weight: bold;
            font-size: 11pt;
        }

        body {
            font-size: 11pt;
            font-family: "Segoe UI";
        }

        .body {
            width: 700px;
            max-width: 85%;
            background: white;
            margin: 12px;
            padding: 12px 24px 12px 30px;
        }

        th {
            background-color: #F0F0F0;
            border: solid 1px #AAAAAA;
            padding: 6px;
        }

        td {
            border: solid 1px #cccccc;
            padding: 6px;
        }

        .small td {
            padding: 3px;
        }

        .nb td {
            border: none;
        }

        .tr td {
            text-align: right;
        }

        p {
            line-height: 150%;
        }

        ul {
            padding-left: 24px;
        }

        li ul {
            padding-left: 12px;
        }

        h1 {
            font-family: "Calibri Light";
            font-weight: normal;
            font-size: 32pt;
            margin: 0;
        }

            h1 img {
                margin-top: -6px;
            }

        li {
            margin: 6px;
        }

        .menu li ul {
            padding-left: 42px;
        }

        var {
            color: #06c;
            font-family: "Times New Roman";
            font-size: 12.5pt
        }

        code {
            background-color: #eef4fa
        }

            code var, code i {
                font-family: inherit;
                font-size: 12pt;
                font-style: normal
            }

        sub var, sup var {
            font-size: 9pt
        }

        .small td, .small th, .small var {
            font-size: 9pt;
        }

        i {
            color: #086;
            font-family: Times New Roman;
            font-style: normal;
            font-size: 11.5pt;
        }

        img {
            vertical-align: middle;
            max-width: 100%;
        }

        u {
            background-color: LightYellow;
        }

        .comment {
            color: green;
        }

        .root {
            font-family: Times New Roman;
            font-size: 14pt;
        }

        .ovr {
            border-top: solid 1px;
            padding-left: 1pt;
            padding-top: -2pt;
        }

        code .ovr {
            padding-top: 2pt;
            font-family: "Consolas";
            font-size: 10pt;
        }

        .dvc {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            line-height: 110%;
            white-space: nowrap;
        }

        .dvl {
            display: block;
            border-bottom: solid 1px black;
        }

        .dvc.down {
            position: relative;
            top: 0.5em;
        }

        .dvc.up {
            position: relative;
            bottom: 0.6em;
        }

        .cond {
            color: magenta;
        }

        .macro {
            color: darkMagenta;
        }

        .err {
            color: red;
        }

        .toc {
            color: #888888;
            text-decoration: none;
            font-size: 10.5pt;
        }

            .toc:hover {
                text-decoration: underline;
                color: black;
            }

        .fold {
            height: 2.4em;
            overflow: hidden;
        }

        .unfold {
            height: auto;
            overflow: auto;
        }

            .fold > :first-child, .unfold > :first-child {
                cursor: pointer;
            }

                .fold > :first-child:hover, .unfold > :first-child:hover {
                    color: #0066bb;
                    text-decoration: underline;
                }

                .fold > :first-child::after {
                    content: " … ▼";
                    font-size: 80%;
                }

                .unfold > :first-child::after {
                    content: " ▲";
                    font-size: 80%;
                }

        #Units {
            float: right;
            margin-top: 12px;
        }

        input[type="text"], select {
            font-size: 11pt;
            padding: 0.15em 0.3em;
            border: 0.5pt solid #CCC;
            border-radius: 0.35em;
            text-align: right;
            box-shadow: 0.06em 0.06em 0.5em #ddd;
            background-color: LightYellow;
        }

        input[type="checkbox"],
        input[type="radio"] {
            --ssf: 1.1;
            zoom: var(--ssf);
            -moz-transform: scale(var(--ssf));
            -webkit-transform: scale(var(--ssf));
            transform: scale(var(--ssf));
            transform-origin: top;
            position: relative;
            bottom: -1pt;
            margin-right: 1pt;
        }

            input[type="checkbox"].post:disabled:not(:checked),
            input[type="checkbox"].post:disabled:not(:checked) + label,
            input[type="radio"].post:disabled:not(:checked),
            input[type="radio"].post:disabled:not(:checked) + label {
                display: none;
            }

        select.post:disabled {
            font-size: 12pt;
            border: none;
            box-shadow: none;
            color: red;
            background: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

            select.post:disabled::-ms-expand {
                display: none;
            }

        input[type="text"]:focus {
            box-shadow: 0.1em 0.1em 1em #ccc;
            color: black;
        }

        .exp {
            display: inline-block;
            height: 13pt;
            line-height: 80%;
            font-size: 12pt;
            font-weight: bold;
            border: solid 1px #cccccc;
            padding: 0 1.5pt 0 1.5pt;
            margin-right: 4pt;
            border-radius: 4pt;
        }

            .exp:hover {
                cursor: pointer;
                box-shadow: #cccccc 0 0 4px;
            }

        sub {
            font-family: Arial Nova;
            font-size: 70%;
            padding-left: 0.5pt;
            padding-right: 0.5pt;
        }

        @media screen and (max-width: 960px) {
            .menu {
                display: none;
            }
        }

        .vec {
            font-family: 'Cambria Math';
            color: black;
            font-style: normal;
            display: inline-block;
            vertical-align: 2pt;
            margin-left: 2pt;
            margin-right: -5pt;
        }

        .hang {
            display: inline-block;
            width: 350pt;
            vertical-align: top;
        }

        .dvs {
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            text-align: left;
            line-height: 110%;
        }

        .dvr {
            display: inline-block;
            vertical-align: middle;
            white-space: nowrap;
            text-align: center;
            line-height: 105%;
        }

        .nary {
            color: #D000D0;
            font-size: 200%;
            font-family: "Segoe UI Light";
            line-height: 80%;
            display: block;
            margin-top: -3pt;
            margin-bottom: 5pt;
        }

        .eq sub {
            font-family: Calibri, 'Gill Sans', 'Gill Sans MT', 'Trebuchet MS', sans-serif;
            font-size: 92%;
            vertical-align: -18%;
        }

        .eq sup {
            display: inline-block;
            margin-left: 1pt;
            margin-top: -2pt;
        }

        .eq small {
            font-family: Calibri, 'Gill Sans', 'Gill Sans MT', 'Trebuchet MS', sans-serif;
            font-size: 70%;
        }

            .eq small var {
                font-family: "Times New Roman", Times, serif;
                font-size: 9pt;
            }

            .eq small i {
                font-family: "Times New Roman", Times, serif;
                font-size: 8pt;
            }

        .nth {
            position: relative;
            bottom: 1pt;
        }

        .eq small.nth {
            font-size: 70%;
        }

        .r0, .r1, .r2, .r3,
        .o0, .o1, .o2, .o3,
        .b1, .b2, .b3,
        .c1, .c2, .c3, .c4,
        .c5, .c6, .c7, .c8 {
            display: inline-block;
        }

        .r0, .r1, .r2, .r3 {
            margin-top: -1.5pt;
            margin-right: 1.5pt;
            vertical-align: top;
            background-repeat: no-repeat;
            background-size: cover;
            background-position: right top;
        }

        .o0, .o1, .o2, .o3 {
            border-top: solid 0.75pt;
            line-height: 130%;
            vertical-align: middle;
            margin-top: 0.75pt;
            padding-top: 1.25pt;
            padding-left: 1pt;
            padding-right: 1pt;
        }

        .r {
            font-size: 130%;
            display: inline-block;
            vertical-align: top;
            margin-left: -9pt;
        }

        .r0 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDEwIDIwIiBoZWlnaHQ9IjE1cHQiIHdpZHRoPSIxMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMCwxMyAyLDEyIDUsMTkgOSwwIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC42cHQ7IHN0cm9rZS1saW5lam9pbjpyb3VuZDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IGZpbGw6bm9uZSIgLz4NCiAgPGxpbmUgeDE9IjIuMiIgeTE9IjEyLjMiIHgyPSI0LjYiIHkyPSIxOC43IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MC44cHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 8pt;
            height: 16pt;
            margin-left: -8pt;
        }

        .r1 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE1IDQwIiBoZWlnaHQ9IjMwcHQiIHdpZHRoPSIxNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMSwyNiAzLDI0IDgsMzggMTQsMCIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjAuNnB0OyBzdHJva2UtbGluZWpvaW46cm91bmQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyBmaWxsOm5vbmUiIC8+DQogIDxsaW5lIHgxPSIzLjIiIHkxPSIyNC40IiB4Mj0iNy42IiB5Mj0iMzcuNiIgc3R5bGU9InN0cm9rZTpibGFjazsgc3Ryb2tlLXdpZHRoOjFwdDsgc3Ryb2tlLWxpbmVjYXA6cm91bmQ7IiAvPg0KPC9zdmc+");
            width: 12pt;
            height: 32pt;
            margin-left: -12pt;
        }

        .r2 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDIwIDYwIiBoZWlnaHQ9IjQ1cHQiIHdpZHRoPSIyMHB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMiwzNyA1LDM0IDExLDU1IDE5LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNS4xIiB5MT0iMzQuNiIgeDI9IjEwLjYiIHkyPSI1NC40IiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 16pt;
            height: 48pt;
            margin-left: -16pt;
        }

        .r3 {
            content: "";
            background-image: url("data: image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI1IDgwIiBoZWlnaHQ9IjYwcHQiIHdpZHRoPSIyNXB4Ij4NCiAgPHBvbHlsaW5lIHBvaW50cz0iMyw1MCA3LDQ2IDE1LDc0IDI0LDAiIHN0eWxlPSJzdHJva2U6YmxhY2s7IHN0cm9rZS13aWR0aDowLjZwdDsgc3Ryb2tlLWxpbmVqb2luOnJvdW5kOyBzdHJva2UtbGluZWNhcDpyb3VuZDsgZmlsbDpub25lIiAvPg0KICA8bGluZSB4MT0iNy4xIiB5MT0iNDYuOCIgeDI9IjE0LjUiIHkyPSI3My4yIiBzdHlsZT0ic3Ryb2tlOmJsYWNrOyBzdHJva2Utd2lkdGg6MS4ycHQ7IHN0cm9rZS1saW5lY2FwOnJvdW5kOyIgLz4NCjwvc3ZnPg==");
            width: 19pt;
            height: 62pt;
            margin-left: -19pt;
        }

        sup.raised {
            vertical-align: top;
        }

        sup .r0, sup .r1, sup .r2, sup .r3 {
            zoom: 0.7;
            -moz-transform: scale(0.7);
            -webkit-transform: scale(0.7);
            transform: scale(0.7);
            transform-origin: top right;
            max-height: none;
        }

        sup .r0 {
            margin-left: -5pt;
        }

        sup .r1 {
            margin-left: -11pt;
        }

        sup .r2 {
            margin-left: -13pt;
        }

        sup .r3 {
            margin-left: -16pt;
        }

        .b1, .b2, .b3, .c1, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            vertical-align: middle;
            font-weight: 100;
            font-stretch: ultra-condensed;
        }

        .b2, .b3, .c2, .c3, .c4, .c5, .c6, .c7, .c8 {
            font-family: "Jost* Hairline";
        }

        .b0, .b1, .c1 {
            font-family: "Jost* Thin";
        }

        .b0 {
            font-size: 120%;
        }

        .b1 {
            font-size: 240%;
            margin-top: -3pt;
        }

        .b2 {
            font-size: 370%;
            margin-top: -5pt;
            margin-left: -3pt;
            margin-right: -3pt;
        }

        .b3 {
            font-size: 520%;
            margin-top: -8pt;
            margin-left: -5pt;
            margin-right: -5pt;
        }

        .c1 {
            font-size: 240%;
            margin-top: -4pt;
        }

        .c2 {
            font-size: 360%;
            margin-top: -6pt;
            margin-left: -2.5pt;
            margin-right: -0.5pt;
        }

        .c3 {
            font-size: 480%;
            margin-top: -8pt;
            margin-left: -3pt;
            margin-right: -1pt;
        }

        .c4 {
            font-size: 600%;
            margin-top: -10pt;
            margin-left: -4pt;
            margin-right: -2pt;
            transform: scaleX(0.9);
        }

        .c5 {
            font-size: 710%;
            margin-top: -11.5pt;
            margin-left: -6pt;
            margin-right: -4pt;
            transform: scaleX(0.8);
        }

        .c6 {
            font-size: 820%;
            margin-top: -13pt;
            margin-left: -7pt;
            margin-right: -5pt;
            transform: scaleX(0.7);
        }

        .c7 {
            font-size: 930%;
            margin-top: -14.5pt;
            margin-left: -8pt;
            margin-right: -6pt;
            transform: scaleX(0.6);
        }

        .c8 {
            font-size: 1040%;
            margin-top: -16pt;
            margin-left: -9pt;
            margin-right: -7pt;
            transform: scaleX(0.5);
        }

        table {
            border-collapse: collapse;
        }

            table.bordered {
                margin-top: 1em;
            }

                table.bordered th {
                    background-color: #F0F0F0;
                    border: solid 1pt #AAAAAA;
                }

                table.bordered td {
                    border: solid 1pt #CCCCCC;
                }

            table.centered td, .matrix .td {
                text-align: center;
            }

            table.data td {
                text-align: right;
            }

                table.data td:first-child {
                    text-align: left;
                    padding-left: 0;
                }

        .matrix {
            display: inine-table;
        }

            .matrix .tr {
                display: table-row;
            }

            .matrix .td {
                padding: 0 2pt 0 2pt;
                min-width: 12pt;
                display: table-cell;
            }

                .matrix .td:first-child,
                .matrix .td:last-child {
                    width: 0.75pt;
                    min-width: 0.75pt;
                    max-width: 0.75pt;
                    padding: 0 1pt 0 1pt;
                }

                .matrix .td:first-child {
                    border-left: solid 1.25pt black;
                }

                .matrix .td:last-child {
                    border-right: solid 1.25pt black;
                }

            .matrix .tr:first-child .td:first-child,
            .matrix .tr:first-child .td:last-child {
                border-top: solid 0.5pt black;
            }

            .matrix .tr:last-child .td:first-child,
            .matrix .tr:last-child .td:last-child {
                border-bottom: solid 0.5pt black;
            }

        .hl {
            background-color: #FFFAE0;
        }

        .hl1 {
            background-color: #FFF8CF;
        }

        .hl2 {
            background-color: #FFEFC0;
        }
    </style>
</head>
<body>
    <ul class="menu">
        <li style="font-size:13pt; font-weight:bold; border-bottom: solid 1px gray; padding-bottom:6px; margin-bottom:6px;">Съдържание</li>
        <li><a class="toc" href="#TOC_101">Относно Calcpad</a></li>
        <li><a class="toc" href="#TOC_102">За кого е предназначена?</a></li>
        <li><a class="toc" href="#TOC_103">Инсталиране</a></li>
        <li><a class="toc" href="#TOC_104">Лицензиране и условия за ползване</a></li>
        <li><a class="toc" href="#TOC_105">Как работи?</a></li>
        <li><a class="toc" href="#TOC_106">Теоретични основи</a></li>
        <li>
            <span class="exp" id="button2">+</span><a class="toc" href="#TOC_200">Писане на текст</a><br>
            <ul id="list2">
                <li><a class="toc" href="#TOC_201">Калкулаторна клавиатура</a></li>
                <li><a class="toc" href="#TOC_202">Придвижване в текста</a></li>
                <li><a class="toc" href="#TOC_203">Маркиране</a></li>
                <li><a class="toc" href="#TOC_204">Изтриване</a></li>
                <li><a class="toc" href="#TOC_205">Копиране</a></li>
                <li><a class="toc" href="#TOC_206">Вмъкване</a></li>
                <li><a class="toc" href="#TOC_207">Отмяна</a></li>
                <li><a class="toc" href="#TOC_208">Възстановяване</a></li>
                <li><a class="toc" href="#TOC_209">Търсене</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button3">+</span><a class="toc" href="#TOC_300">Помощни инструменти</a><br />
            <ul id="list3">
                <li><a class="toc" href="#TOC_301">Синтактично оцветяване</a></li>
                <li><a class="toc" href="#TOC_302">Автоматични отстъпи</a></li>
                <li><a class="toc" href="#TOC_303">Авто-дописване</a></li>
                <li><a class="toc" href="#TOC_304">Съответствие на скобите</a></li>
                <li><a class="toc" href="#TOC_305">Гръцки букви</a></li>
                <li><a class="toc" href="#TOC_306">Редактиране с Notepad++</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button4">+</span><a class="toc" href="#TOC_400">Изрази</a><br>
            <ul id="list4">
                <li><a class="toc" href="#TOC_401">Константи</a></li>
                <li><a class="toc" href="#TOC_402">Променливи</a></li>
                <li><a class="toc" href="#TOC_403">Оператори</a></li>
                <li><a class="toc" href="#TOC_404">Скоби</a></li>
                <li><a class="toc" href="#TOC_405">Функции</a></li>
                <li><a class="toc" href="#TOC_406">Графики</a></li>
                <li><a class="toc" href="#TOC_407">Числени методи</a></li>
                <li><a class="toc" href="#TOC_408">Итеративни процедури</a></li>
                <li><a class="toc" href="#TOC_409">Мерни единици</a></li>
                <li><a class="toc" href="#TOC_410">Вектори</a></li>
                <li><a class="toc" href="#TOC_411">Матрици</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button5">+</span><a class="toc" href="#TOC_500">Записка</a><br>
            <ul id="list5">
                <li><a class="toc" href="#TOC_501">Заглавия</a></li>
                <li><a class="toc" href="#TOC_502">Текст/коментари</a></li>
                <li><a class="toc" href="#TOC_503">Мерни единици в коментари</a></li>
                <li><a class="toc" href="#TOC_504">Форматиране с Html и CSS</a></li>
                <li><a class="toc" href="#TOC_505">Изображения</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button6">+</span><a class="toc" href="#TOC_600">Програмиране</a><br>
            <ul id="list6">
                <li><a class="toc" href="#TOC_601">Формуляри за вход на данни</a></li>
                <li><a class="toc" href="#TOC_602">Контрол на видимостта</a></li>
                <li><a class="toc" href="#TOC_603">Условни разклонения</a></li>
                <li><a class="toc" href="#TOC_604">Блокове за цикли</a></li>
                <li><a class="toc" href="#TOC_605">Интерактивно изпълнение (стъпка-по-стъпка)</a></li>
                <li><a class="toc" href="#TOC_606">Модули (Include)</a></li>
                <li><a class="toc" href="#TOC_607">Макроси и текстови променливи</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button7">+</span><a class="toc" href="#TOC_700">Резултати</a><br>
            <ul id="list7">
                <li><a class="toc" href="#TOC_701">Заместване</a></li>
                <li><a class="toc" href="#TOC_702">Закръгляване</a></li>
                <li><a class="toc" href="#TOC_703">Форматиране</a></li>
                <li><a class="toc" href="#TOC_704">Мащабиране</a></li>
                <li><a class="toc" href="#TOC_705">Запис</a></li>
                <li><a class="toc" href="#TOC_706">Отпечатване</a></li>
                <li><a class="toc" href="#TOC_707">Копиране</a></li>
                <li><a class="toc" href="#TOC_708">Изход към Word</a></li>
                <li><a class="toc" href="#TOC_709">Изход към PDF</a></li>
            </ul>
        </li>
        <li>
            <span class="exp" id="button8">+</span><a class="toc" href="#TOC_800">Файлове</a><br>
            <ul id="list8">
                <li><a class="toc" href="#TOC_801">Нов</a></li>
                <li><a class="toc" href="#TOC_802">Отваряне</a></li>
                <li><a class="toc" href="#TOC_803">Запис</a></li>
                <li><a class="toc" href="#TOC_804">Запис като...</a></li>
            </ul>
        </li>
    </ul>
    <div class="body">
        <ul style="float:right; font-size:9pt; list-style:none;">
            <li><img alt="Logo" src="Images/Logo.png" height="28"><span style="font-size:130%">®</span></li>
            <li>София, бул. Пейо К. Яворов 34-36</li>
            <li>+359 2 423 4455</li>
            <li><a href="mailto:proektsoft.bg@gmail.com">proektsoft.bg@gmail.com</a></li>
        </ul>
        <h1><img alt="Calcpad.png" src="Images/Calcpad.png" height="32"> Calcpad</h1>
        <p style="margin-left:40px; margin-top:6px;">Версия 7.1 Readme!</p>
        <h2 id="TOC_101">Относно Calcpad VM</h2>
        <p>Calcpad е безплатен софтуер за математически и инженерни изчисления. Представлява гъвкав и модерен програмируем калкулатор + генератор на Html документация. Той е  лесен за ползване и предлага богати възможности:</p>
        <ul>
            <li>изчисления с реални и комплексни числа;</li>
            <li>използване на мерни единици в изчисленията (SI, Imperial и USCS);</li>
            <li>вектори и матрици: правоъгълна, симетрична, матрица-стълб, диагонална, горна/долна триъгълна;</li>
            <li>дефиниране на собствени променливи и потребителски мерни единици;</li>
            <li>библиотека от стандартни математически функции;</li>
            <li>
                множество векторни и матрични функции: <ul>
                    <li>за данни: търсене, броене, сортиране, подреждане, справки и др.;</li>
                    <li>агрегатни: минимум, максимум, сума, сума от квадр., ККСК, средно аритметично, произведение, средно геометрично и др.;</li>
                    <li>
                        математически: норми, числа на обусловеност, детерминанта, ранг, следа, транспонирана, адюнгирана и обратна матрица,
                        факторизация (Холецки, ldlt, lu, qr и svd), собствени стойности и вектори, системи линейни уравнения;
                    </li>
                </ul>
            <li>дефиниране на потребителски функции с множество параметри f(x; y; z; …);</li>
            <li>мощни числени методи за намиране на корени на уравнения, екстремуми на функции, числено интегриране и диференциране;</li>
            <li>крайни суми, произведения и итерации;</li>
            <li>изчертаване на графики на функции;</li>
            <li>модули, макроси и текстови променливи;</li>
            <li>контрол на програмния поток чрез условни разклонения и цикли;</li>
            <li>"заглавия" и 'текстови' коментари, заградени в кавички;</li>
            <li>поддръжка на Html и CSS в коментарите за по-богато форматиране;</li>
            <li>вмъкване на изображения, таблици, параметрични SVG чертежи и др.;</li>
            <li>генериране на Html форми за попълване на входни данни;</li>
            <li>автоматично документиране на резултатите в Html записки, готови за отпечатване;</li>
            <li>заместване на стойностите на променливите и интелигентно закръгляване;</li>
            <li>контрол на видимостта на резултатите и сгъване на съдържанието;</li>
            <li>запис на данните в текстов (*.txt, *.cpd) и двоичен (*.cpdz) файлов формат;</li>
            <li>запис на резултатите в (*.html) или (*.docx) файл за Word.</li>
        </ul>
        <p>Софтуерът е разработен с помощта на програмен език C# и последните компютърни технологии. Той разпознава автоматично въведените математически формули, замества стойностите на променливите, изчислява изразите и показва резултатите на екрана. Те са оформени като професионално изглеждаща Html записка, във вид, подходящ за преглед и отпечатване.</p>

        <p style="text-align:center;"><img alt="Math" src="Images/Math.jpg" width="300"></p>
        <p>Референции: Всички тези нови и красиви икони в последните версии са създадени с помощта на платформата <a href="https://icons8.com">icons8.com</a>.</p>

        <h2 id="TOC_102">За кого е предназначен?</h2>
        <p>Софтуерът е подходящ за инженери и други специалисти, които трябва да извършват еднотипни и често повтарящи се изчисления, особено когато резултатите трябва да се представят в официална документация, като например изчислителна записка. Те могат ефективно да автоматизират тези задачи, чрез създаването на мощни и надеждни Calcpad приложения. Платформата може да е полезна и на преподавателите за разработването на интерактивни примери, статии, ръководства, учебници и др. Учащите могат да го използват за решаване на различни задачи, подготовка на домашни, курсови, дипломни работи или дисертации.</p>

        <h2 id="TOC_103">Инсталиране</h2>
        <p>Инсталирането се извършва от автоматизирана инсталираща програма <a href="http://proektsoft.bg/calcpad/calcpad-setup-x64.zip" target="_blank">calcpad-setup-x64.exe</a>. Следвайте инструкциите, които ще видите на всяка стъпка. За да може да ползвате софтуера, трябва да изтеглите и инсталирате <a target="_blank" href="https://dotnet.microsoft.com/en-us/download/dotnet/8.0" target="_blank">Microsoft .NET 8.0</a>. Ако разполагате с по-стара версия на Windows, най-вероятно ще се наложи да го изтеглите и инсталирате.</p>
        <p>Тази версия няма да работи на 32-битови компютри. За целта трябва да инсталирате съответно <br /><a href="http://proektsoft.bg/calcpad/calcpad-setup-x86.zip" target="_blank">calcpad-setup-x86.exe</a> и <a href="http://go.microsoft.com/fwlink/?LinkId=528222" target="_blank">.NET Framework 4.6</a>.</p>

        <h2 id="TOC_104">Лицензиране и условия за ползване</h2>
        <p>Софтуерът е безплатен както за лична, така и за комерсиална употреба при определени условия. Може да инсталирате и разпространявате копия от софтуера без ограничения. Всички подпрограми, разработени с Calcpad са собственост на техните автори. Те могат да се използват също без ограничения, освен посочените от съответните автори.</p>

        <h2 id="TOC_105">Как работи?</h2>
        <p>Софтуерът е бърз и лесен за използване. Следвайте следните прости стъпки:</p>
        <ol>
            <li><strong>Въведете</strong> формулите и текста в прозореца "<b>Код</b>" отляво. Вижте инструкциите по-долу.</li>
            <li>Натиснете <b>F5</b> или бутона <img alt="Play" height="20" src="Images/Play.png"> за да <strong>изчислите</strong> резултатите. Те ще се появят отдясно в прозореца "<strong>Резултати</strong>", като професионално оформена изчислителна <strong>записка</strong>.</li>
            <li>Натиснете <img alt="PrintPreview" height="20" src="Images/PrintPreview.png"> за да <strong>отпечатате</strong> или <img alt="Copy" height="20" src="Images/Copy.png"> за да <strong>копирате</strong> съдържанието на записката. Може също да го <strong>запишете</strong> като Html <img alt="Save" height="20" src="Images/Save.png">, PDF <img alt="PDF" height="20" src="Images/Pdf.png"> или MS Word <img alt="Word" height="20" src="Images/Word.png"> документ.</li>
        </ol>
        <p>Може да ползвате програмата в два отделни режима:</p>
        <ul>
            <li><b>Програмиране</b> - програмния код е достъпен за преглед и редактиране в левия прозорец. След изчисленията, резултатите се показват в десния прозорец. Този режим се прилага най вече при разработване, но ако имате прости и кратки задачи без специално форматиране, може да ги ползвате и по този начин.</li>
            <li><b>Формуляр за входни данни</b> - изходният код е недостъпен, а вместо това, се показва Html формуляр за вход на данни. Той съдържа входни полета за всички параметри, които е необходимо да се въведат за целите на изчисленията. Останалата част от съдържанието е заключена за редактиране. Този режим е подходящ за работа със сложни и често използвани задачи, с богато форматиране. При него, входните параметри се разпознават лесно, а програмният код е защитен от случайно повреждане.</li>
        </ul>
        <p>В режим "<b>Формуляр</b>" трябва първо да попълните входните полета, след което да натиснете бутона <img alt="Play" height="20" src="Images/Play.png"> за да изчислите. Може да създадете формуляр директно от програмния код по много лесен начин. Просто трябва да сложите символа "<b>?</b>" навсякъде, където е необходимо да се попълни стойност. След това запишете задачата като "<b>*.cpd</b>" файл. Допълнителна информация ще намерите по-нататък в настоящото ръководство.</p>

        <h2 id="TOC_106">Теоретични основи</h2>
        <p style="font-style: italic;">(това може и да не го четете)</p>
        <p>Как на практика работи Calcpad? В основата му стои математическо ядро, което отговаря за разпознаването и изчисляването на формулите. Първоначално, програмният код се разглежда като поток от символи. Прави се лексически анализ и се превръща в поток от лексеми (токени). Всяка лексема е представена с нейното съдържание и етикет (мета информация) относно тип и пр.</p>
        <p>След това се проверява дали лексемите се намират в правилната последователност. Целта е да се установи дали изразът е дефиниран математически коректно и може да бъде изчислен. В противен случай, програмата ще генерира съобщение за грешка. Например, изразът "<code>3 + a / 5</code>" е коректен, а изразът "<code>3 a + / 5</code>" не е. За тази цел, стандартно използваната математическа нотация се разглежда като формален език с контекстно свободна граматика. Разпознаването се извършва чрез синтактичен анализ, с помощта на стеков автомат.</p>
        <p>Математическите изрази стандартно се записват в инфиксен формат. Това означава, че всеки оператор е разположен между съответните операнди (например "<code>5*3 + 2</code>"). Проблемът е, че на компютрите им е трудно да "разбират" този вид запис, за разлика от хората. Основните трудности са свързани с необходимостта от отчитането на приоритет и асоциативност на операторите и наличието на скоби. Например, резултатът от горния израз ще бъде "<code>17</code>", докато "<code>5*(3 + 2)</code>" ще даде "<code>25</code>". Ето защо е необходимо изразът да се преобразува в друг вид запис, наречен постфиксен или обратен полски запис (RPN). За компютрите този запис вече е лесно разбираем, но не и за хората. Например, изразът "<code>5*(3 + 2)</code>" се записва в RPN като "<code>5 3 2 + *</code>". Предимството на този формат е, че последователността на операциите е ясно дефинирана и без необходимост от скоби.</p>
        <p>Съществува прост и ефективен алгоритъм за изчисляването на израз, представен в обратен полски запис (RPN). Той се използва в почти всички калкулатори. Освен това, езикът на Calcpad включва и допълнителен набор от елементи и сложна програмна функционалност за обработването на променливи, функции, условни разклонения, цикли, числени методи и др.</p>
        <p>Това е краткото и просто обяснение. Ако имате по-сериозен интерес към тази тема, може да намерите допълнителна информация в специализираната литература, статии и уеб сайтове. Wikipedia е едно добро място за начало:
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Parsing">https://en.wikipedia.org/wiki/Parsing</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Context-free_grammar">https://en.wikipedia.org/wiki/Context-free_grammar</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">https://en.wikipedia.org/wiki/Shunting-yard_algorithm</a></p>
        <p style="margin-left: 2em;"><a target="_blank" href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">https://en.wikipedia.org/wiki/Reverse_Polish_notation</a></p>

        <h2 id="TOC_200">Писане на текст</h2>
        <p>Програмният код се въвежда като текст в прозореца "<b>Код</b>", обикновено с помощта на клавиатурата. Разстоянията между символите и отместването в началото на реда се управляват автоматично от редактора. Може да копирате текст от и към текстовия прозорец или външна програма като например <b>Word</b>. Над прозореца има лента с бутони, които предлагат някои полезни команди за редактиране: Копиране, Вмъкване, Отмяна и др. Възможни са и други начини за добавяне на код в програмата:</p>
        <ul>
            <li>от калкулаторната клавиатура в долната част на екрана;</li>
            <li>от менюто <b>"Вмъкни"</b> в горната част на екрана;</li>
            <li>от помощната информация в десния прозорец. За да вмъкнете елемент, кликнете върху него с мишката.</li>
        </ul>
        <p>Програмният код е логически разделен на редове, които се номерират автоматично. По принцип, всеки израз трябва да е на отделен ред. Възможно е да имате и няколко израза на един ред, но трябва да ги разделите с коментари. Когато приключите с текущия ред, натиснете "<b>Enter</b>" за да преминете на нов ред. В този момент се извършва синтактично проверка и оцветяване на въведения код. При това, различните програмни елементи се показват в различни цветове. Например, коментарите са в зелено, променливите в синьо, съобщенията за грешки - в червено и пр. Всички коментари трябва да са заградени в кавички. Те могат да съдържат както обикновен текст, така и <b>Html</b>. С негова помощ може да добавяте картинки, таблици и по-богато форматиране към изчислителната записка.</p>

        <h3 id="TOC_201">Калкулаторна клавиатура</h3>
        <p><img alt="Keyboard" Width="600" src="Images/Keyboard.bg.png"></p>
        <p>Калкулаторната клавиатура е удобна за работа с таблет или лаптоп, с чувствителен на допир екран. При натискане на бутон от клавиатурата, съответните символи се добавят след текущото място на курсора. Клавиатурата е разделена на четири визуални групи: "<b>Числа</b>", "<b>Оператори</b>", "<b>Функции</b>" и "<b>други</b>". Бутонът "<b>=</b>" не изчислява резултата, както при стандартните калкулатори, а е оператор за присвояване (например "<var>a</var> = 4"). За сравняване на стойности се използва оператора "<b>≡</b>" (например, "<var>a</var> ≡ <var>b</var>" е равносилно на: "<var>a</var> равно ли е на <var>b</var>?"). Бутоните "<b>e</b>", "<b>π</b>" и "<b>g</b>" вмъкват съответните вградени константи <var>e</var> ≈ 2.7183, <var>π</var> ≈ 3.1416 и <var>g</var> ≈ 9.8066.</p>
        <p>Ако калкулаторната клавиатура не ви е необходима в даден момент, може да я скриете от бутона <img alt="Calc" height="20" src="Images/Calc.png"> за да освободите място. Натиснете същия бутон повторно за да я върнете обратно.</p>
        <p>Бутонът "<b style="color:red">C</b>" изтрива предишния символ, а "<b style="color:red">AC</b>" изтрива текущия ред. С двойно кликване на същия бутон може да изтриете цялото съдържание. В случай, че това стане инцидентно, може да възстановите текста с бутона <img alt="Undo" height="20" src="Images/Undo.png">.</p>

        <h3 id="TOC_202">Придвижване в текста</h3>
        <p>Писането и редактирането на текст в Calcpad не се различава особено от която е да е друга програма под Windows. Ако вече имате известен опит с това, може да пропуснете следващите 6 точки и да отидете направо на "<b><a href="#TOC_300">Помощни инструменти</a></b>"</p>
        <p>Може да пишете на произволно място в целия текст. Текущата позиция, където се вмъкват символите се нарича "<b>текстов курсор</b>" (мигаща вертикална черта "<b>|</b>"). Може да смените позицията на курсора, като кликнете с мишката на желаното място в текста или използвате стрелките "← → ↑ ↓" от клавиатурата. Те преместват курсора с по един символ, съответно наляво/надясно или с един ред нагоре/надолу. Ако задържите клавиша "<b>Ctrl</b>", натискането на стрелка ще премести курсора с цяла дума. С клавиша "<b>Home</b>" ще отидете в началото на реда, а със "<b>End</b>" - в края. Ако преди това задържите "<b>Ctrl</b>", вместо това, ще отидете в началото и края на целия текст.</p>

        <h3 id="TOC_203">Маркиране на текст</h3>
        <p>Повечето от командите за редактиране изискват да маркирате предварително част от текста, към която да бъде приложена съответната команда. Маркираният текст обикновено се обозначава със <span style="background-color:LightSkyBlue;">син фон</span> (може и да изглежда различно в зависимост от настройките на конкретния компютър). Може да маркирате текст с помощта на мишката по следният начин: Натиснете левия бутон на мишката в началото на текста, който ще маркирате. Преместете мишката в крайната позиция като държите бутона натиснат. След това може да го пуснете. Като алтернатива, може да кликнете в началото, да натиснете <b>Shift</b> и да кликнете отново в края. Също така, може да използвате и клавиатурата на компютъра. Задръжте <b>Shift</b> и натиснете стрелка или "<b>Home</b>", "<b>End</b>", "<b>PageUp</b>", "<b>PageDown</b>".</p>

        <h3 id="TOC_204">Изтриване на текст</h3>
        <p>Може да изтриете единичен символ, като натиснете клавиша "<b>Delete</b>" ("Del") или "<b>Backspace</b>" ("Bkspc"). Разликата е, че "Delete" изтрива символа след курсора, а "Backspace" - преди курсора. Ако преди това задържите "<b>Ctrl</b>", вместо отделни символи може да триете наведнъж цели думи. Ако е необходимо да изтриете по-голяма част от текста, може да я маркирате предварително и тогава да натиснете "<b>Delete</b>" или "<b>Backspace</b>".</p>

        <h3 id="TOC_205">Копиране</h3>
        <p>Ако имате повтарящи се части от текста, може да ги копирате, вместо да ги набирате повторно. Това става на две стъпки: "Копиране" и "Поставяне". На първата стъпка, маркираният текст се изпраща временно в част от паметта, наречена "<b>Clipboard</b>". На втората стъпка, може да поставите текста от клипборда на друго място. Веднъж копиран, текстът може да бъде поставян многократно на различни места.</p>
        <p>Може да копирате маркирания текст в клипборд-а като натиснете "<b>Ctrl+C</b>" или кликнете бутона <img alt="Copy" height="20" src="Images/Copy.png">.</p>

        <h3 id="TOC_206">Вмъкване</h3>
        <p>Преди да поставите текст от клипборд-а позиционирайте курсора на желаното място. След това натиснете "<b>Ctrl+V</b>" или бутона <img alt="Paste" height="20" src="Images/Paste.png">. Може да копирате текст от Calcpad и да го поставите в други програми и обратно. Например, може да вземете формули от Word, да ги изчислите в Calcpad и да върнете резултатите обратно в Word.</p>

        <h3 id="TOC_207">Отмяна</h3>
        <p>Тази команда отменя резултата от последната команда за редактиране на текста и възстановява предишното положение. Трябва само да натиснете "<b>Ctrl+Z</b>" или бутона <img alt="Undo" height="20" src="Images/Undo.png">. Така може да се връщате последователно до 10 стъпки назад.</p>

        <h3 id="TOC_208">Възстановяване</h3>
        <p>Действието е обратното на предишната команда. Възстановява последната отменена команда за редактиране. Възстановяването трябва да бъде извикано непосредствено преди отмяната. Ако междувременно извършите въвеждане или редактиране на текста, губите възможността за възстановяване. За да стартирате командата, натиснете бутона <img alt="Redo" height="20" src="Images/Redo.png">.</p>

        <h3 id="TOC_209">Търсене</h3>
        <p>Може да търсите даден текстов низ в програмния код и да го замените с друг. Изберете менюто "<b>Редактор/Търсене</b>", кликнете бутона <img alt="Find" height="20" src="Images/Search.png"> или натиснете "<b>Ctrl+F</b>". На екрана ще се покаже диалогът "<b>Търсене и заместване</b>".</p>
        <p><img alt="Find Dialog" width="550" src="Images/FindDialog.bg.png"></p>
        <p>Въвете думата или фразата, която търсите и натиснете "<b>Намери следващ</b>". Програмата започва от текущата позиция и търси следващото съвпадение в избраната посока. Когато намери търсената фраза, маркира съответния текст и спира търсенето. За да потърсите следващото съвпадение, натиснете "<b>Намери следващ</b>" отново. Вместо това, може да използвате и клавиша "<b>F3</b>", дори и след като затворите диалога.</p>
        <p>Ако желаете да замените търсения текст, изберете раздела "<b>Заместване</b>" и попълнете полето "<b>Замени със:</b>". След това, натиснете бутона "<b>Замени</b>". Програмата ще замени текущото съвпадение и ще премине автоматично към следващото. Ако желаете да замените всички съвпадения в кода, натиснете съответния бутон.</p>
        <p>Предвидени са няколко настройки, които казват влияние върху резултатите от търсенето, както следва:</p>
        <ul>
            <li><b>Посока</b>: "Нагоре", "Надолу" and "Всичко". И двете опции "Надолу" и "Всичко" търсят в посока към края на съдържанието. Разликата при "Всичко" е, че когато достигне края на текста, програмата се връща и започва отначало.</li>
            <li><b>В избраното</b>: Тази опция е предназначена само за командата "<b>Замени всичко</b>". Първо трябва да маркирате текста и тогава да извикате диалога "<b>Търсене и заместване</b>". Ако включите опцията "<b>В избраното</b>" след това, всички замени ще бъдат направени само в маркирания текст.</li>
            <li><b>Главни/малки</b> (букви): Когато опцията е включена, програмата ще прави разлика между главни и малки букви. По подразбиране, регистърът на буквите при търсене се пренебрегва.</li>
            <li><b>Цели думи</b>: Когато тази опция е избрана програмата ще търси само последователности, които представляват цели думи.</li>
        </ul>

        <h2 id="TOC_300">Помощни инструменти</h2>
        <h3 id="TOC_301">Синтактично оцветяване</h3>
        <p>Синтактичното оцветяване се изразява в прилагането на различно оцветяване на отделните компоненти на програмния език: функции, променливи, оператори и др. То се стартира във фонов режим, всеки път, когато редктираме текущия ред и отидем на друг. Грешките се оцветяват в червено. Програмата различава недефинирани и дефинирани променливи и функции. Цветовата гама е предефинирана и не може да се променя. Към настоящия момент, Calcpad не поддържа потребителски стилове и теми.</p>

        <h3 id="TOC_302">Автоматични остъпи</h3>
        <p>Отстъпите на отделните редове в кода се управляват автоматично от програмата. Всички редове, които са в условен блок или цикъл получават съответния отстъп навътре. В допълнение, може да въвеждате и интервали в началото на всеки ред. Въпреки, че интервалите също се настройват автоматично, това не засяга водещите интервали в началото на реда.</p>

        <h3 id="TOC_303">Авто-дописване</h3>
        <p>Когато започнете да пишете, програмата показва падащ списък с предложения, които започват с въведените до момента символи. Той съдържа ключови думи, мерни единици, вградени функции, както и всички променливи и функции, дефинирани от потребителя преди текущия ред. Списъкът се филтрира и сортира динамично по време на писане. Текущото предложение от списъка стои винаги маркирано. За да го вмъкнете на текущата позиция, натиснете "<b>Tab</b>". За да изберете някое от другите предложение в списъка, кликнете върху него с мишката. Алтернативно, може да натиснете "<b>долна стрелка</b>", за да се придвижите в списъка и "<b>Enter</b>" за да вмъкнете избрания елемент. Ако списъкът се намира над текущия ред, натиснете "<b>горна стрелка</b>", вместо долна.</p>

        <h3 id="TOC_304">Съответствие на скобите</h3>
        <p>Програмата разпознава и маркира съответните леви и десни скоби по време на писане. Ако поставите курсора непосредствено до дадена скоба, тя се оцветява, заедно със съответната. Ако няма такава, не се оцветява нищо. </p>

        <h3 id="TOC_305">Гръцки букви</h3>
        <p>Може да вмъквате гръцки букви, като кликнете върху съответния символ под прозореца за редактиране на код. Алтернативно, може да въведете еквивалентната буква на латиница, съгласно долната таблица, и да натиснете "<b>Ctrl+G</b>". При повторно натискане, ще конвертирате символа обратно от гръцки на латиница. Тъй като "j"/"J" и "V" остават неизползвани, те са привързани съответно към символите "ø"/"Ø" и "&measuredangle;".</p>
        <table class="bordered">
            <tr><th>Име		 </th><th>гръцки</th><th>латиница</th><th>Гръцки</th><th>Латиница</th></th>
            <tr><td>алфа     </td><td>α</td><td>a</td></td><td>Α</td><td>A</td></tr>
            <tr><td>бета     </td><td>β</td><td>b</td></td><td>Β</td><td>B</td></tr>
            <tr><td>гама     </td><td>γ</td><td>g</td></td><td>Γ</td><td>G</td></tr>
            <tr><td>делта    </td><td>δ</td><td>d</td></td><td>Δ</td><td>D</td></tr>
            <tr><td>епсилон  </td><td>ε</td><td>e</td></td><td>Ε</td><td>E</td></tr>
            <tr><td>зета     </td><td>ζ</td><td>z</td></td><td>Ζ</td><td>Z</td></tr>
            <tr><td>ета      </td><td>η</td><td>h</td></td><td>Η</td><td>H</td></tr>
            <tr><td>тита     </td><td>θ</td><td>q</td></td><td>Θ</td><td>Q</td></tr>
            <tr><td>тита-алт.</td><td>ϑ</td><td>v</td></td><td>&measuredangle;</td><td>V</td></tr>
            <tr><td>йота     </td><td>ι</td><td>i</td></td><td>Ι</td><td>I</td></tr>
            <tr><td>капа     </td><td>κ</td><td>k</td></td><td>Κ</td><td>K</td></tr>
            <tr><td>ламда    </td><td>λ</td><td>l</td></td><td>Λ</td><td>L</td></tr>
            <tr><td>мю       </td><td>μ</td><td>m</td></td><td>Μ</td><td>M</td></tr>
            <tr><td>ни       </td><td>ν</td><td>n</td></td><td>Ν</td><td>N</td></tr>
            <tr><td>кси      </td><td>ξ</td><td>x</td></td><td>Ξ</td><td>X</td></tr>
            <tr><td>омикрон  </td><td>ο</td><td>o</td></td><td>Ο</td><td>O</td></tr>
            <tr><td>пи       </td><td>π</td><td>p</td></td><td>Π</td><td>P</td></tr>
            <tr><td>ро       </td><td>ρ</td><td>r</td></td><td>Ρ</td><td>R</td></tr>
            <tr><td>сигма    </td><td>σ</td><td>s</td></td><td>Σ</td><td>S</td></tr>
            <tr><td>тау      </td><td>τ</td><td>t</td></td><td>Τ</td><td>T</td></tr>
            <tr><td>упсилон  </td><td>υ</td><td>u</td></td><td>Υ</td><td>U</td></tr>
            <tr><td>фи       </td><td>φ</td><td>f</td></td><td>Φ</td><td>F</td></tr>
            <tr><td>чи       </td><td>χ</td><td>c</td></td><td>Χ</td><td>C</td></tr>
            <tr><td>пси      </td><td>ψ</td><td>y</td></td><td>Ψ</td><td>Y</td></tr>
            <tr><td>омега    </td><td>ω</td><td>w</td></td><td>Ω</td><td>W</td></tr>
            <tr><td>фи-диам. </td><td>ø</td><td>j</td></td><td>Ø</td><td>J</td></tr>
        </table>

        <h3 id="TOC_306">Редактиране с Notepad++</h3>
        <p><b>Notepad++</b> е популярна безплатна програма за редактиране на текстови файлове. Тя е с отворен код и може да бъде изтеглена от сайта <a href="https://notepad-plus-plus.org" target="_blank">https://notepad-plus-plus.org</a>. Поддържа синтаксиса на много програмни езици и скриптове. Оцветява ключовите думи, сгъва блокове от изрази и показва затварянето на скобите. Частично е преведена и на български език. Може да я използвате за да редактирате Html файлове. Синтаксисът на <b>Calcpad</b> е дефиниран като файл с настройки, който може да вмъкнете в Notepad++. Това става като стартирате Notepad++, изберете менюто "<b>Language</b>" ("Синтаксис") -> "<b>Define your language</b>" и натиснете бутона "<b>Import…</b>". Намерете папката на <b>Calcpad</b> в <b>Program Files</b> или където е инсталиран и изберете файла <a href="https://calcpad.eu/download/Notepadpp.zip" target="_blank">Calcpad-syntax-for-Notepad++.xml</a>.</p>

        <h2 id="TOC_400">Изрази</h2>
        <p>Calcpad е предназначена най-вече за извършване на изчисления. Затова всичко, което въведете в текстовия прозорец, по подразбиране се счита за аритметичен израз, освен ако не е в кавички. Тогава се счита за коментар. По правило всеки израз трябва да е разположен на нов ред:</p>
        <ul style="list-style: none;">
            <li><code>2 + 3</code></li>
            <li><code>5*(3+1)</code></li>
            <li><code>15/2</code></li>
        </ul>
        <p>Не трябва да завършвате всеки израз с "=" за получите резултата. Това е символът за присвояване и служи за задаване на стойности на променливи, например "<var>a</var> = 2". За изчислите, натиснете <b>F5</b> бутона <img alt="Play" height="20" src="Images/Play.png">. След това, в прозореца с резултати ще може да видите:</p>
        <ul style="list-style: none;">
            <li><code>2 + 3 = 5</code></li>
            <li><code>5∙(3 + 1) = 20</code></li>
            <li><code>15/2 = 7.5</code></li>
        </ul>
        <p>По изключение, може да имате няколко израза на един ред, разделени с коментари:</p>
        <p style="margin-left:24px;">'Дължина - ' <var>a</var> = 3 ' m, Ширина - ' <var>b</var> = 2*<var>a</var> ' m, Височина - ' <var>c</var> = 5 ' m</p>
        <p>Изразите могат да включват константи, променливи, оператори, функции и скоби. Те трябва да са в правилната последователност за да образуват валиден израз. Използва се общоприетата математическа нотация и приоритет на операциите, които се изучават в училище. Подробно описание на отделните елементи, които може да използвате в изрази, е дадено по-долу.</p>
        <p>Може да въвеждате отделни изрази, които да се изчисляват, или да съставите цялостна програма за решаване на задачата. За целта, може последователно да дефинирате параметри, на които да присвоявате стойности. След това, може да ги използвате в други формули, чрез които да изчислите нови параметри и така, до получаване на отговора. Чрез подходяща комбинация от изрази, коментари, схеми и малко Html, може да съставите професионална и прегледна програма-записка. Може да я запишете във файл и да я ползвате многократно. Ето една примерна задача за намиране на корените на квадратно уравнение:</p>
        <p><img alt="Sample1" width="680" src="Images/Sample1.bg.png"></p>

        <h3 id="TOC_401">Константи</h3>
        <h4>Реални</h4>
        <p>Константите могат да бъдат положителни или отрицателни цели числа, или десетични дроби. Те трябва да включват цифрите "<code>0</code>" - "<code>9</code>" и "<code>.</code>" за десетична точка. Може да въведете и обикновена дроб като "<code>3/4</code>", но програмата на практика ще я третира като израз от две константи и оператор "<code>/</code>". Не може да въвеждате числа с плаваща запетая във формат "<code>3.4e+6</code>". Вместо това, може да използвате израза: "<code>3.4*10^6</code>".</p>
        <p>Всички константи и променливи се съхраняват в поле тип double-precision floating point. Те могат да имат стойности от <code>-1.7976931348623157E+308</code> до <code>1.7976931348623157E+308</code>. Най-малкото положително число може да бъде <code>4.94065645841247E-324</code>. По-малки стойности от тази се считат за точно <code>0</code>. Ако получените резултати излизат извън посочените граници, програмата връща съответно "<code><span class="err">-∞</span></code>" и "<code><span class="err">+∞</span></code>". Същото се получава и при деление на нула, а "<code>0/0</code>" = "<code><span class="err">Недефинирано</span></code>".</p>
        <h4>Комплексни</h4>
        <p>Ако включите режим "<b>Комплексни числа</b>", ще може да ги използвате в програмата. Комплексното число представлява наредена двойка <code>(a; b<var>i</var>)</code> , където "<code>a</code>" се нарича реално число, а "<code>b<var>i</var></code>" - имагинерно. Комплексите числа, най-често се записват в алгебрична форма като "<code>&plusmn;a &plusmn; b<var>i</var></code>" (например "<code>2 + 3<var>i</var></code>"). Може да използвате и тригонометрична и експоненциална форма като въведете съответните изрази: "<code><var>r</var>&middot;(<b>cos</b>(<var>&phi;</var>) + 1i&middot;<b>sin</b>(<var>&phi;</var>))</code>" и "<code><var>r</var>&middot;<var>e</var><sup>1i&middot;<var>&phi;</var></sup></code>". Имагинерната единица може да се запише самостоятелно като "<code>1<var>i</var></code>", за да се отличава от променливата "<code><var>i</var></code>". Тя представлява специално число, което се дефинира с израза "<code>(1<var>i</var>)<sup>2</sup> = -1</code>".</p>

        <h3 id="TOC_402">Променливи</h3>
        <p>Променливите се дефинират чрез посочване на име и стойност, например "<code><var>a</var> = 4</code>". Символът "<code><b>=</b></code>" е оператор за присвояване. От лявата му страна трябва да има единствено име на променлива, а от дясната може да стои всякакъв валиден аритметичен израз, например "<code><var>b</var> = <var>a</var> + 4</code>". След като веднъж е дефинирана, променливата може да се използва в други изрази по-нататък. При всяко нейно срещане в процеса на изчисляване, тя ще се замести с нейната стойност. Не може да използвате променлива, преди да е дефинирана. Това ще доведе до грешка. Всяка променлива е валидна от момента на нейното създаване до края на задачата. Ако я дефинирате повторно, новата стойност ще замени старата.</p>
        <p>Имената на променливите могат да съдържат малки и главни букви на латиница "<var>a</var>" - "<var>z</var>", "<var>A</var>" - "<var>Z</var>", гръцки букви "<var>&alpha;</var>" - "<var>&omega;</var>", "<var>&Alpha;</var>" - "<var>&Omega;</var>" и цифри. Прави се разлика между главни и малки букви. Например "<var>a</var>" и "<var>A</var>" са различни променливи. Името не може да започва с цифра. Може да използвате и символа "<code><b>_</b></code>" (долна черта). Първата долна черта се счита за начало на долен индекс. Например "<code>a_1_1</code>" ще бъде форматирано като "<var>a</var><sub>1_1</sub>". В имената на променливите може да вмъквате и запетаи "<code><b>,</b></code>" и други символи: " <b>′</b> ", " <b>″</b> ", " <b>‴</b> ", " <b>⁗</b> ", " <b>ø</b> ", "<b>Ø</b>", " <b>°</b> ", "<b>∡</b>"., например "<code>f′_c,eff</code>". В променливите могат да съхраняват както реални, така и комплексни числа.</p>

        <h3 id="TOC_403">Оператори</h3>
        <p>Програмата поддържа следните оператори:</p>
        <ul>
            <li>
                Аритметични:
                <ul style="list-style-type:none;">
                    <li>"<code><b>!</b></code>" - факториел;</li>
                    <li>"<code><b>^</b></code>" - степенуване;</li>
                    <li>"<code><b>/</b></code>" - деление;</li>
                    <li>"<code><b>÷</b></code>" - деление с дробна черта;</li>
                    <li>"<code><b>\</b></code>" - целочислено деление; </li>
                    <li>"<code><b>⦼</b></code>" - остатък; </li>
                    <li>"<code><b>*</b></code>" - умножение;</li>
                    <li>"<code><b>-</b></code>" - изваждане; </li>
                    <li>"<code><b>+</b></code>" - събиране; </li>
                </ul>
            </li>
            <li>
                Релационни (сравнение):
                <ul style="list-style-type:none;">
                    <li>"<code><b>≡</b></code>" - равно на;</li>
                    <li>"<code><b>≠</b></code>" - различно от;</li>
                    <li>"<code><b>&lt;</b></code>" - по-малко;</li>
                    <li>"<code><b>&gt;</b></code>" - по-голямо;</li>
                    <li>"<code><b>&le;</b></code>" - по-малко или равно;</li>
                    <li>"<code><b>&ge;</b></code>" - по-голямо или равно;</li>
                </ul>
            <li>
                Логически:
                <ul style="list-style-type:none;">
                    <li>"<code><b>∧</b></code>" - логическо "И" (AND);<br />
                    <li>"<code><b>∨</b></code>" - логическо "ИЛИ" (OR);<br />
                    <li>"<code><b style="font-size:80%;">⊕</b></code>" - изключващо "ИЛИ" (XOR);<br />
                </ul>
            </li>
            <li>"<code><b>=</b></code>" - присвояване.</li>
        </ul>

        <h4>"Бързи" клавиши за оператори</h4>
        <p>Символите за изписване на някои от операторите не са налични на стандартните клавиатури. По тази причина, вместо "≡", "≠", "&le;"- and "&ge;", може да използвате съответните еквиваленти от езика C/C++, както следва: "==", "!=", "&lt;=" и "&gt;=". Те ще бъдат автоматично заменени с техните аналози в Calcpad. Съкращението “%%” ще бъде конвертирано до оператора за остатък “⦼”. Това се налага, тъй като символът “%” се използва като мерни единици за "процент". Тъй като избраният символ не е широко разпространен,в записката той се замества с “mod”, например “7 mod 5 = 2”, вместо “7 ⦼ 5 = 2”.</p>

        <h4>Унарни и бинарни операции и оператори</h4>
        <p>Унарни са операциите, които се извършват върху един операнд, а бинарни - върху два операнда. Например, операцията "<code>-a</code>" е унарна, а "<code>a - b</code>" - бинарна. Това се отнася и за съответните оператори. Всички оператори в Calcpad са бинарни, с изключение на оператора "<code><b>!</b></code>" (факториел), който е унарен и "<code><b>-</b></code>" който може да бъде както унарен (отрицателен знак), така и бинарен (изваждане). На свой ред, унарните оператори могат да бъдат префиксни и постфиксни. Префиксните се записват преди операнда, а постфиксните - след него. Операторът "<code><b>-</b></code>" е префиксен, а "<code><b>!</b></code>" - постфиксен.</p>

        <h4>Приоритет на операторите</h4>
        <p>Последователността, в която са изброени операторите по-горе съответства на техния приоритет. Това е реда, в който ще се извършат съответните операции в даден аритметичен израз (освен, ако няма скоби). Тоест, първо ще се извърши степенуване, след това умножение и деление, събиране и изваждане, сравнение, и накрая - присвояване. Всички релационни оператори са с равен приоритет. За да промените последователността на операциите, може да използвате скоби. Например, "<code>5 + 2∙3</code>" прави "<code>11</code>", тъй като умножението е с по-висок приоритет. Ако искате  да извършите първо събирането, напишете "<code>(5 + 2)∙3</code>" и ще получите "<code>7∙3 = 21</code>".</p>

        <h4>Асоциативност</h4>
        <p>Знаем, че когато имаме няколко оператора с равен приоритет, операциите се извършат отляво-надясно. Това свойство се нарича (лява) асоциативност. Например, "<code>3 - 2 + 1</code>" прави "<code>(3 - 2) + 1 = 2</code>", а не "<code>3 - (2 + 1) = 0</code>". Друг добър пример е "<code>2∙3 / 2∙3</code>", което прави "<code>9</code>", а не "<code>1</code>". Всички оператори в Calcpad са ляво асоциативни (операциите се извършват отляво надясно), с изключение на оператора за степенуване.</p>

        <h4>Особености на оператора за степенуване</h4>
        <p>Степенуването по принцип е дясно асоциативна операция и се извършва отдясно-наляво. Тоест, "<code>x^a^b</code>" трябва да се чете като "<code>x<sup>a<sup>b</sup></sup></code>". Много ръчни калкулатори обаче, както и някои електронни таблици като Excel, не работят така. При тях, "<code>x^a^b</code>" се чете като "<code>(x<sup>a</sup>)<sup>b</sup></code>". Ако искате да получите "<code>x<sup>a<sup>b</sup></sup></code>", трябва да поставите скоби: "<code>x^(a^b)</code>". За разлика от Excel обаче, в Calcpad се използват общоприетите правила. Например, ако напишете "<code>4^3^2</code>", ще получите "<code>4<sup>3<sup>2</sup></sup> = 262144</code>", а не "<code>(4<sup>3</sup>)<sup>2</sup> = 4096</code>". Така са направени и повечето математически програми като Wolfram Mathematica, Maple, Mathlab и др.</p>

        <p>Друга особеност има, когато използваме "<code>-</code>" (отрицателен знак), в комбинация със степенуване. В повечето програмни езици, унарните оператори са с приоритет пред бинарните, но този случай е изключение. В математиката, "<code>-2<sup>2</sup></code>" е прието да се чете като "<code>-(2<sup>2</sup>) = -4</code>". Така работи и Calcpad: "<code>-2^2 = -(2<sup>2</sup>) = -4</code>" (както и повечето математически програми). В електронните таблици като Excel обаче, по някаква причина е прието обратното: "<code>-2^2 = (-2)<sup>2</sup> = 4</code>".</p>

        <h4>Релационни изрази</h4>
        <p>Релационните оператори могат да връщат само две стойности: "<code>1</code>" - истина и "<code>0</code>" - неистина. Те могат да участват и в по-сложни изрази. Например, за да получите по-голямото от "<code>a</code>" и "<code>b</code>", може да използвате израза "<code>a*(a &ge; b) + b*(a &lt; b)</code>". Трябва обаче да бъдете внимателни. Например, ако вместо "<code>&lt;</code>" използвате "<code>&le;</code>", при "<code>a</code>" точно равно на "<code>b</code>", ще получите "<code>2∙a</code>". Вместо това, е по-добре да използвате вградената функция "<code>max(a; b)</code>", логически оператори или условно изпълнение (виж по-нататък). Алгебричните оператори са с по-висок приоритет от релационните, като и двата вида се изчисляват преди логическите.</p>

        <h4>Логически изрази</h4>
        <p>Calcpad оперира единствено с числови типове данни и няма специален тип за логически данни. Поради това, подобно на релационните, логическите оператори също използват "<b>1</b>" за "<b>истина</b>" и "<b>0</b>" for "<b>неистина</b>". Всяка стойност, различна от 0 също се приравнява към "<b>истина</b>". В Calcpad може да изграждате логически изрази като използвате логически оператори и/или логически функции (виж по-нататък в настоящото ръководство). Те работят по следния начин:</p>
        <ul style="list-style-type:none;">
            <li>"∧" (and) връща 1 ако и двата операнда са едновременно равни на 1, иначе връща 0;</li>
            <li>"∨" (or) връща 1 ако поне един от операндите е 1 и 0 ако и двата са 0;</li>
            <li>"⊕" (xor) връща 1 ако само един от операторите е равен на 1 и 0 в останалите случаи.</li>
        </ul>
        <p>Резултатите действието на горните оператори са дадени в следните таблици:</p>
        <table width="100%">
            <tr>
                <td style="border:none;">
                    <p><b>And</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x∧y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>0</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>Or</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x∨y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>Xor</b></p>
                    <table width="60%" class="tr">
                        <tr><th>x</th><th>y</th><th>x<span style="font-size:80%">⊕</span>y</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>0</td></tr>
                    </table>
                </td>
            </tr>
        </table>

        <h4>Аритметични изрази с комплексни числа</h4>
        <p>Всички оператори поддържат и комплексни числа, с изключение на тези за целочислено деление "<code>\</code>", остатък "<code>⦼</code>" и сравняване: "<code>&lt;</code>", "<code>&le;</code>", "<code>&gt;</code>", "<code>&ge;</code>". Изчисляването на изрази с комплексни числа се извършва малко по-сложно отколкото се реални. Ето правилата за основните аритметични операции:</p>
        <ul>
            <li>Събиране: <code>(a + b<var>i</var>) + (c + d<var>i</var>) = (a + c) + (b + d)<var>i</var></code>;</li>
            <li>Изваждане: <code>(a + b<var>i</var>) &minus; (c + d<var>i</var>) = (a &minus; c) + (b &minus; d)<var>i</var></code>;</li>
            <li>Умножение: <code>(a + b<var>i</var>)&middot;(c + d<var>i</var>) = (ac &minus; bd) + (bc + ad)<var>i</var>;</li></code>
            <li>Деление: <code>(a + b<var>i</var>)/(c + d<var>i</var>) = (ac + bd)/(c<sup>2</sup> + d<sup>2</sup>) + (bc &minus; ad)/(c<sup>2</sup> + d<sup>2</sup>)<var>i</var></code>;</li>
        </ul>

        <h4>Аритметични изрази с мерни единици</h4>
        <p>Всички оператори могат да се прилагат и към стойности с дименсии, както и към самите мерни единици. Умножението, делението и степенуването на мерни единици са с по-висок приоритет от съответните оператори за бездименсионни стойности. Така, може да образуваме съставни мерни единици чрез аритметични изрази. За повече информация, виж раздел <a href="#TOC_409">Мерни единици</a> по-долу.</p>

        <h3 id="TOC_404">Скоби</h3>
        <p>Скобите служат за две цели: едната е промяна на последователността на операциите, а другата е да заграждат аргументите на функциите. Трябва да използвате означенията "<code><b>(</b></code>", "<code><b>)</b></code>". Програмата следи за спазването на следните правила:</p>
        <ul>
            <li>Първата срещната скоба в израза трябва да е лява;</li>
            <li>Броят на левите и десните скоби трябва да е равен;</li>
            <li>Преди лява скоба трябва да има оператор или име на функция;</li>
            <li>Не може да има дясна скоба след оператор или име на функция;</li>
            <li>След име на функция трябва винаги да има лява скоба.</li>
        </ul>
        <h4>Скоби в резултатите</h4>
        <p>При форматиране на изходните резултати, програмата поставя скобите "умно". Това означава, че скоби, които се дублират или по никакъв начин не променят реда на операциите, се премахват. От друга страна, на определени места се налага да се добавят скоби, въпреки че липсват във изходния код. Това се получава най-често при заместване на стойностите на променливи, които съдържат в себе си отрицателни или комплексни числа. Например:</p>
        <ul>
            <li>Ако "<code><var>a</var> = -2</code>", то "<code><var>a</var><sup>2</sup> = (-2)<sup>2</sup> = 4</code>", а не "<code><var>a</var><sup>2</sup> = -2<sup>2</sup></code>". Във втория случай, обикновено се счита, че минусът е след повдигането в степен и резултатът би трябвало да е -4. Скоби се добавят и при степенуване на комплексно число;</li>
            <li>Ако "<code><var>a</var> = -2</code>", то "<code><var>b</var> = -<var>a</var> = -(-2) = 2</code>", а не "<code><var>b</var> = -<var>a</var> = --2 = 2</code>";</li>
            <li>Скоба се поставя и когато умножаваме или делим на отрицателно число: "<code><var>a</var>&middot;<var>b</var> = -2&middot;(-3) = 6</code>";</li>
            <li>Ако имаме променливи с комплексни стойности, след заместването им също се поставят скоби: "<code><var>a</var>&middot;<var>b</var> = (2 + 3<var>i</var>)&middot;(3 - 2<var>i</var>) = 12 + 5<var>i</var></code>".</li>
        </ul>

        <h3 id="TOC_405">Функции</h3>
        <h4>Библиотечни</h4>
        <p>Calcpad разполага с набор от стандартни библиотечни функции, които може да ползвате директно:</p>
        <ul>
            <li>
                Тригонометрични:<ul style="list-style-type:none;">
                    <li><code><b>sin</b>(<var>x</var>)</code> - синус;</li>
                    <li><code><b>cos</b>(<var>x</var>)</code> - косинус;</li>
                    <li><code><b>tan</b>(<var>x</var>)</code> - тангенс = <code><b>sin</b>(<var>x</var>)/<b>cos</b>(<var>x</var>)</code>, за ∀ <var>x</var> ≠ π/2 + kπ, k=1, 2, 3…;</li>
                    <li><code><b>csc</b>(<var>x</var>)</code> - косеканс = <code>1/<b>sin</b>(<var>x</var>)</code>, за ∀ <var>x</var> ≠  kπ, k=1, 2, 3…;</li>
                    <li><code><b>sec</b>(<var>x</var>)</code> - секанс = <code>1/<b>cos</b>(<var>x</var>)</code>, за ∀ <var>x</var> ≠ π/2 + kπ, k=1, 2, 3…;</li>
                    <li><code><b>cot</b>(<var>x</var>)</code> - котангенс = <code><b>cos</b>(<var>x</var>)/<b>sin</b>(<var>x</var>)</code>, за ∀ <var>x</var> ≠  kπ, k=1, 2, 3…;</li>
                </ul>
            </li>
            <li>
                Хиперболични:<ul style="list-style-type:none;">
                    <li><code><b>sinh</b>(<var>x</var>)</code> - синус хиперболичен = <code>(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>)/2</code>;</li>
                    <li><code><b>cosh</b>(<var>x</var>)</code> - косинус хиперболичен = <code>(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)/2</code>;</li>
                    <li><code><b>tanh</b>(<var>x</var>)</code> - тангенс хиперболичен = <code>(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>)/(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)</code>;</li>
                    <li><code><b>csch</b>(<var>x</var>)</code> - косеканс хиперболичен = <code>1/<b>sinh</b>(<var>x</var>)</code>;</li>
                    <li><code><b>sech</b>(<var>x</var>)</code> - секанс хиперболичен = <code>1/<b>cosh</b>(<var>x</var>)</code>;</li>
                    <li><code><b>coth</b>(<var>x</var>)</code> - котангенс хиперболичен = <code>(e<sup><var>x</var></sup> + e<sup>-<var>x</var></sup>)/(e<sup><var>x</var></sup> - e<sup>-<var>x</var></sup>), за <var>x</var> ≠ 0</code>;</li>
                </ul>
            </li>
            <li>
                Обратни тригонометрични:<ul style="list-style-type:none;">
                    <li><code><b>asin</b>(<var>x</var>)</code> - аркуссинус, дефиниран за -1 &le; <var>x</var> &le; 1;</li>
                    <li><code><b>acos</b>(<var>x</var>)</code> - аркускосинус, дефиниран за -1 &le; <var>x</var> &le; 1;</li>
                    <li><code><b>atan</b>(<var>x</var>)</code> - аркустангенс;</li>
                    <li><code><b>atan2</b>(<var>x</var>; <var>y</var>)</code> - ъгълът, чиито тангенс е отношението на <var>y</var> към <var>x</var>;</li>
                    <li><code><b>acsc</b>(<var>x</var>)</code> - аркускосеканс = <code><b>asin</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>asec</b>(<var>x</var>)</code> - аркуссеканс = <code><b>acos</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>acot</b>(<var>x</var>)</code> - аркускотангенс = <code><b>atan</b>(1/<var>x</var>)</code>;</li>
                </ul>
            </li>
            <li>
                Обратни хиперболични:<ul style="list-style-type:none;">
                    <li><code><b>asinh</b>(<var>x</var>)</code> - аркуссинус хиперболичен = <code><b>ln</b>(<var>x</var> + <span class="root">√</span><span class="ovr"><var>x</var><sup>2</sup> + 1</span>)</code>, дефиниран за -∞ &le; <var>x</var> &le; +∞;</li>
                    <li><code><b>acosh</b>(<var>x</var>)</code> - аркускосинус хиперболичен = <code><b>ln</b>(<var>x</var> + <span class="root">√</span><span class="ovr"><var>x</var> + 1</span>&middot;<span class="root">√</span><span class="ovr"><var>x</var> - 1</span>)</code>, дефиниран за <var>x</var> &ge; 1;</li>
                    <li><code><b>atanh</b>(<var>x</var>)</code> - аркустангенс хиперболичен = <code>1/2&middot;<b>ln</b>[(1 + <var>x</var>)/(1 - <var>x</var>)]</code>, за -1 &lt; <var>x</var> &lt; 1;</li>
                    <li><code><b>acsch</b>(<var>x</var>)</code> - аркускосеканс хиперболичен = <code><b>asinh</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>asech</b>(<var>x</var>)</code> - аркуссеканс хиперболичен = <code><b>acosh</b>(1/<var>x</var>)</code>;</li>
                    <li><code><b>acoth</b>(<var>x</var>)</code> - аркускотангенс хиперболичен = <code>1/2&middot;<b>ln</b>[(<var>x</var> + 1)/(<var>x</var> - 1)]</code>, за |<var>x</var>| &gt; 1;</li>
                </ul>
            </li>
            <li>
                Логаритмични, експоненциални и корени:<ul style="list-style-type:none;">
                    <li><code><b>log</b>(<var>x</var>)</code> - десетичен логаритъм (при основа 10), за ∀ <var>x</var> &gt; 0;</li>
                    <li><code><b>ln</b>(<var>x</var>)</code> - натурален логаритъм (при основа <var>e</var> ≈ 2.7183), за ∀ <var>x</var> &gt; 0;</li>
                    <li><code><b>log_2</b>(<var>x</var>)</code> - двоичен логаритъм (при основа 2), за ∀ <var>x</var> &gt; 0;</li>
                    <li><code><b>exp</b>(<var>x</var>)</code> - експоненциална функция = <var>e</var>&hairsp;ˣ;</li>
                    <li><code><b>sqr</b>(<var>x</var>) или <b>sqrt</b>(<var>x</var>)</code> - корен квадратен (<span class="root">√</span><span class="ovr"><var>x</var></span> ), дефиниран за ∀ <var>x</var> &ge; 0;</li>
                    <li><code><b>cbrt</b>(<var>x</var>)</code> - корен кубичен ( <sup><sup>3</sup></sup><span class="root">√</span><span class="ovr"><var>x</var></span> );</li>
                    <li><code><b>root</b>(<var>x</var>; <var>n</var>)</code> - корен n-ти ( <sup><sup>n</sup></sup><span class="root">√</span><span class="ovr"><var>x</var></span> );</li>
                </ul>
            </li>
            <li>
                Закръгляване:<ul style="list-style-type:none;">
                    <li><code><b>round</b>(<var>x</var>)</code> - закръглява към по-близкото цяло число;</li>
                    <li><code><b>floor</b>(<var>x</var>)</code> - закръглява към по-малкото цяло число;</li>
                    <li><code><b>ceiling</b>(<var>x</var>)</code> - закръглява към по-голямото цяло число;</li>
                    <li><code><b>trunc</b>(<var>x</var>)</code> - закръглява към най-близкото цяло число в посока към нулата;</li>
                </ul>
            </li>
            <li>
                Целочислени:<ul style="list-style-type:none;">
                    <li><code><b>mod</b>(<var>x</var>; <var>y</var>)</code> - остатък от деление;</li>
                    <li><code><b>gcd</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - най-голям общ делител;</li>
                    <li><code><b>lcm</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - най-малко общо кратно;</li>
                </ul>
            </li>
            <li>
                Агрегатни и интерполационни:<ul style="list-style-type:none;">
                    <li><code><b>min</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - минимум на множество стойности;</li>
                    <li><code><b>max</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - максимум на множество стойности;<br </li>
                    <li><code><b>sum</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - сума на множество стойности<code> = <var>x</var> + <var>y</var> + <var>z</var>…</code>;</li>
                    <li><code><b>sumsq</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - сума от квадратите<code> = <var>x</var>² + <var>y</var>² + <var>z</var>²…</code>;</li>
                    <li><code><b>srss</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - корен квадратен от сумата на квадратите<code> = <b>sqrt</b>(<var>x</var>² + <var>y</var>² + <var>z</var>²…)</code>;</li>
                    <li><code><b>average</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - средно аритметично от множество стойности<code> = (<var>x</var> + <var>y</var> + <var>z</var>…)/<var>n</var></code>;</li>
                    <li><code><b>product</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - произведение на множество стойности<code> = <var>x</var>·<var>y</var>·<var>z</var>…</code>;</li>
                    <li><code><b>mean</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - средно геометрично <code> = n-th <b>root</b>(<var>x</var>·<var>y</var>·<var>z</var>…)</code>;</li>
                    <li><code><b>take</b>(<var>n</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - връща n-тия елемент от списъка</li>
                    <li><code><b>line</b>(<var>x</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - линейна интерполация;</li>
                    <li><code><b>spline</b>(<var>x</var>; <var>a</var>; <var>b</var>; <var>c</var>…)</code> - spline интерполация на Ермит;</li>
                </ul>
            </li>
            <li>
                Условни и логически:<ul style="list-style-type:none;">
                    <li><code><b>if</b>(<em>условие</em>; <em>стойност-при-истина</em>; <em>стойност-при-неистина</em>)</code> - условно изчисление. Ако <em>условие</em> е удовлетворено, функцията изчислява първата стойност, ако не е - втората. Условието се счита за удовлетворено, ако изчисления резултат е което и да е число, различно от нула.</li>
                    <li><code><b>switch</b>(&lt;<em>усл1</em>&gt;; &lt;<em>стойност1</em>&gt;; &lt;<em>усл2</em>&gt;; &lt;<em>стойност2</em>&gt;;…; &lt;<em>подразб.</em>&gt;)</code> - избирателно изчисление;</li>
                    <li><code><b>not</b>(<var>x</var>)</code> - логическо отрицание (NOT);</li>
                    <li><code><b>and</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> -  логическо "<b>И</b>" (AND);</li>
                    <li><code><b>or</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - логическо "<b>ИЛИ</b>" (OR);</li>
                    <li><code><b>xor</b>(<var>x</var>; <var>y</var>; <var>z</var>…)</code> - изключващо "<b>ИЛИ</b>" (XOR);</li>
                </ul>
            </li>
            <li>
                Други:<ul style="list-style-type:none;">
                    <li><code><b>sign</b>(<var>x</var>)</code> - знак на число = -1, if <var>x</var> &lt; 0; 1, if <var>x</var> &gt; 0; 0, if <var>x</var> = 0;</li>
                    <li><code><b>abs</b>(<var>x</var>)</code> - абсолютна стойност (модул) |<var>x</var>|;</li>
                    <li><code><b>random</b>(<var>x</var>)</code> - генерира (псевдо) случайно число между 0 и <var>x</var>;</li>
                </ul>
            </li>
            <li>
                Векторни:
                <ul>
                    <li>
                        Създаване и инициализация:<ul style="list-style-type:none;">
                            <li><code><b>vector</b>(<var>n</var>)</code> - създава празен вектор с дължина <var>n</var>;</li>
                            <li><code><b>fill</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>)</code> - запълва вектора <var><span class="vec">⃗</span>v</var> със стойност <var>x</var>;</li>
                            <li><code><b>range</b>(<var>x</var><sub>1</sub>; <var>x</var><sub>n</sub>; <var>s</var>)</code> - създава вектор от стойностите в интервала от <var>x</var><sub>1</sub> до <var>x</var><sub>n</sub> със стъпка <var>s</var>;</li>
                        </ul>
                    </li>
                    <li>
                        Структурни:<ul style="list-style-type:none;">
                            <li><code><b>len</b>(<var><span class="vec">⃗</span>v</var>)</code> - връща дължината на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>size</b>(<var><span class="vec">⃗</span>v</var>)</code> - действителния размер на вектора <var><span class="vec">⃗</span>v</var> (индекса на последния ненулев елемент);</li>
                            <li><code><b>resize</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - задава нова дължина <var>n</var> на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>join</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - създава вектор чрез обединяване на аргументите в списъка - матрици, вектори и скалари;</li>
                            <li><code><b>slice</b>(<var><span class="vec">⃗</span>v</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code>  - връща частта от вектора <var><span class="vec">⃗</span>v</var>, ограничена от индекси <var>i</var><sub>1</sub> и <var>i</var><sub>2</sub>, включително;</li>
                            <li><code><b>first</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - първите <var>n</var> елемента на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>last</b>(<var><span class="vec">⃗</span>v</var>; <var>n</var>)</code> - последните <var>n</var> елемента на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>extract</b>(<var><span class="vec">⃗</span>v</var>; <var><span class="vec">⃗</span>i</var>)</code> - извлича онези елементи от <var><span class="vec">⃗</span>v</var>, чиито индекси се съдържат в <var><span class="vec">⃗</span>i</var>;</li>
                        </ul>
                    </li>
                    <li>
                        Данни:<ul style="list-style-type:none;">
                            <li><code><b>sort</b>(<var><span class="vec">⃗</span>v</var>)</code> - сортира елементите на вектор <var><span class="vec">⃗</span>v</var> във възходящ ред;</li>
                            <li><code><b>rsort</b>(<var><span class="vec">⃗</span>v</var>)</code> - сортира елементите на вектор <var><span class="vec">⃗</span>v</var> в низходящ ред;</li>
                            <li><code><b>order</b>(<var><span class="vec">⃗</span>v</var>)</code> - индексите на вектор <var><span class="vec">⃗</span>v</var>, подредени по възходящия ред на неговите елементи;</li>
                            <li><code><b>revorder</b>(<var><span class="vec">⃗</span>v</var>)</code> - индексите на вектор <var><span class="vec">⃗</span>v</var>, подредени по низходящия ред на неговите елементи;</li>
                            <li><code><b>reverse</b>(<var><span class="vec">⃗</span>v</var>)</code> - нов вектор, съдържащ елементите на <var><span class="vec">⃗</span>v</var> в обратен ред;</li>
                            <li><code><b>count</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - броя на елементите в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са равни на <var>x</var>;</li>
                            <li><code><b>search</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индекса на първия елемент в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, който е равен на <var>x</var>;</li>
                            <li><code><b>find</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> или </li>
                            <li><code><b>find_eq</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са = <var>x</var>;</li>
                            <li><code><b>find_ne</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са ≠ <var>x</var>;</li>
                            <li><code><b>find_lt</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са &lt; <var>x</var>;</li>
                            <li><code><b>find_le</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са &le; <var>x</var>;</li>
                            <li><code><b>find_gt</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са &gt; <var>x</var>;</li>
                            <li><code><b>find_ge</b>(<var><span class="vec">⃗</span>v</var>; <var>x</var>; <var>i</var>)</code> - индексите на всички елементи в <var><span class="vec">⃗</span>v</var> от <var>i</var>-тия нататък, които са &ge; <var>x</var>;</li>
                            <li><code><b>lookup</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> или</li>
                            <li><code><b>lookup_eq</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са = <var>x</var>;</li>
                            <li><code><b>lookup_ne</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са ≠ <var>x</var>;</li>
                            <li><code><b>lookup_lt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са &lt; <var>x</var>;</li>
                            <li><code><b>lookup_le</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са &le; <var>x</var>;</li>
                            <li><code><b>lookup_gt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са &gt; <var>x</var>;</li>
                            <li><code><b>lookup_ge</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code> - всички елементи в <var><span class="vec">⃗</span>a</var>, за които съответните елементи в <var><span class="vec">⃗</span>b</var> са &ge; <var>x</var>;</li>
                        </ul>
                    </li>
                    <li>
                        Математически:<ul style="list-style-type:none;">
                            <li><code><b>norm_1</b>(<var><span class="vec">⃗</span>v</var>)</code> - L1 (Манхатън) норма на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>norm</b>(<var><span class="vec">⃗</span>v</var>)</code> или</li>
                            <li><code><b>norm_2</b>(<var><span class="vec">⃗</span>v</var>)</code> или</li>
                            <li><code><b>norm_e</b>(<var><span class="vec">⃗</span>v</var>)</code> - L2 (Евклидова) норма на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>norm_p</b>(<var><span class="vec">⃗</span>v</var>; <var>p</var>)</code> - Lp норма на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>norm_i</b>(<var><span class="vec">⃗</span>v</var>)</code> - L∞ (безкрайна) норма на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>unit</b>(<var><span class="vec">⃗</span>v</var>)</code> - нормализирания (единичен) вектор <var><span class="vec">⃗</span>v</var> (с L2 норма = 1);</li>
                            <li><code><b>dot</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code> - скаларно произведение на два вектора <var><span class="vec">⃗</span>a</var> и <var><span class="vec">⃗</span>b</var>;</li>
                            <li><code><b>cross</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code> - векторно произведение на два вектора <var><span class="vec">⃗</span>a</var> и <var><span class="vec">⃗</span>b</var> (с дължина 2 или 3);</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                Матрични:<ul>
                    <li>
                        Създаване и инициализация:<ul style="list-style-type:none;">
                            <li><code><b>matrix</b>(<var>m</var>; <var>n</var>)</code> - създава празна матрица с размери <var>m</var>⨯<var>n</var>;</li>
                            <li><code><b>identity</b>(<var>n</var>)</code> - създава единична матрица с размери <var>n</var>⨯<var>n</var>;</li>
                            <li><code><b>diagonal</b>(<var>n</var>; <var>d</var>)</code> - създава диагонална <var>n</var>⨯<var>n</var> матрица и запълва главния диагонал със стойност <var>d</var>;</li>
                            <li><code><b>column</b>(<var>m</var>; <var>c</var>)</code> - създава матрица - стълб с размери <var>m</var>⨯1, запълнена със стойност <var>c</var>;</li>
                            <li><code><b>utriang</b>(<var>n</var>)</code> - създава горна триъгълна матрица с размери <var>n</var>⨯<var>n</var>;</li>
                            <li><code><b>ltriang</b>(<var>n</var>)</code> - създава долна триъгълна матрица с размери <var>n</var>⨯<var>n</var>;</li>
                            <li><code><b>symmetric</b>(<var>n</var>)</code> - създава симетрична матрица с размери <var>n</var>⨯<var>n</var>;</li>
                            <li><code><b>vec2diag</b>(<var><span class="vec">⃗</span>v</var>)</code> - създава диагонална матрица от елементите на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>vec2col</b>(<var><span class="vec">⃗</span>v</var>)</code> - създава матрица-стълб от елементите на вектора <var><span class="vec">⃗</span>v</var>;</li>
                            <li><code><b>join_cols</b>(<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub>…)</code> - създава нова матрица чрез обединяване на вектори в стълбове;</li>
                            <li><code><b>join_rows</b>(<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub>…)</code> - създава нова матрица чрез обединяване на вектори в редове;</li>
                            <li><code><b>augment</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - създава нова матрица чрез присъединяване на матриците <var>A</var><span class="o">,</span> <var>B</var><span class="o">,</span> <var>C</var>… една до друга;</li>
                            <li><code><b>stack</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code> - създава нова матрица чрез присъединяване на матриците <var>A</var><span class="o">,</span> <var>B</var><span class="o">,</span> <var>C</var>… една под друга;</li>
                        </ul>
                    </li>
                    <li>
                        Структурни:<ul style="list-style-type:none;">
                            <li><code><b>n_rows</b>(<var>M</var>)</code> - броя на редовете в матрицата <var>M</var>;</li>
                            <li><code><b>n_cols</b>(<var>M</var>)</code> - броя на стълбовете в матрицата <var>M</var>;</li>
                            <li><code><b>mresize</b>(<var>M</var>; <var>m</var>; <var>n</var>)</code> - задава нови размери <var>m</var> и <var>n</var> на матрицата <var>M</var>;</li>
                            <li><code><b>mfill</b>(<var>M</var>; <var>x</var>)</code> - запълва матрицата <var>M</var> със стойност <var>x</var>;</li>
                            <li><code><b>fill_row</b>(<var>M</var>; <var>i</var>; <var>x</var>)</code> - запълва <var>i</var>-тия ред на матрицата <var>M</var> със стойност <var>x</var>;</li>
                            <li><code><b>fill_col</b>(<var>M</var>; <var>j</var>; <var>x</var>)</code> - запълва <var>i</var>-тия стълб на матрицата <var>M</var> със стойност <var>x</var>;</li>
                            <li><code><b>copy</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code> - копира всички елементи от <var>A</var> в <var>B</var>, започвайки от индекси <var>i</var> и <var>j</var> на <var>B</var>;</li>
                            <li><code><b>add</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code> - добавя всички елементи от <var>A</var> към тези на <var>B</var>, започвайки от индекси <var>i</var> и <var>j</var> на <var>B</var>;</li>
                            <li><code><b>row</b>(<var>M</var>; <var>i</var>)</code> - извлича <var>i</var>-тия ред на матрицата <var>M</var> като вектор;</li>
                            <li><code><b>col</b>(<var>M</var>; <var>j</var>)</code> - извлича <var>j</var>-тия стълб на матрицата <var>M</var> като вектор;</li>
                            <li><code><b>extract_rows</b>(<var>M</var>; <var><span class="vec">⃗</span>i</var>)</code> - извлича онези редове от матрицата <var>M</var>, чиито индекси се съдържат във вектор <var><span class="vec">⃗</span>i</var>;</li>
                            <li><code><b>extract_cols</b>(<var>M</var>; <var><span class="vec">⃗</span>j</var>)</code>  - извлича онези стълбове от матрицата <var>M</var>, чиито индекси се съдържат във вектор <var><span class="vec">⃗</span>j</var>;</li>
                            <li><code><b>diag2vec</b>(<var>M</var>)</code>- извлича диагоналните елементи от матрицата <var>M</var> като вектор;</li>
                            <li><code><b>submatrix</b>(<var>M</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - извлича подматрица на <var>M</var>, ограничена от редове <var>i</var><sub>1</sub> и <var>i</var><sub>2</sub> и стълбове <var>j</var><sub>1</sub> и <var>j</var><sub>2</sub>, вкл.;</li>
                        </ul>
                    </li>
                    <li>
                        Данни:<ul style="list-style-type:none;">
                            <li><code><b>sort_cols</b>(<var>M</var>; <var>i</var>)</code> - сортира стълбовете на <var>M</var> на базата на стойностите в ред <var>i</var> във възходящ ред;</li>
                            <li><code><b>rsort_cols</b>(<var>M</var>; <var>i</var>)</code> - сортира стълбовете на <var>M</var> на базата на стойностите в ред <var>i</var> в низходящ ред;</li>
                            <li><code><b>sort_rows</b>(<var>M</var>; <var>j</var>)</code> - сортира редовете на <var>M</var> на базата на стойностите в стълб <var>j</var> във възходящ ред;</li>
                            <li><code><b>rsort_rows</b>(<var>M</var>; <var>j</var>)</code> - сортира редовете на <var>M</var> на базата на стойностите в стълб <var>j</var> в низходящ ред;</li>
                            <li><code><b>order_cols</b>(<var>M</var>; <var>i</var>)</code> - индексите на стълбовете на <var>M</var>, подредени възходящо по стойностите от ред <var>i</var>;</li>
                            <li><code><b>revorder_cols</b>(<var>M</var>; <var>i</var>)</code> - индексите на стълбовете на <var>M</var>, подредени низходящо по стойностите от ред <var>i</var>;</li>
                            <li><code><b>order_rows</b>(<var>M</var>; <var>j</var>)</code> - индексите на редовете на <var>M</var>, подредени възходящо по стойностите от стълб <var>j</var>;</li>
                            <li><code><b>revorder_rows</b>(<var>M</var>; <var>j</var>)</code> - индексите на редовете на <var>M</var>, подредени низходящо по стойностите от стълб <var>j</var>;</li>
                            <li><code><b>mcount</b>(<var>M</var>; <var>x</var>)</code> - броят на елементите със стойност <var>x</var> в матрицата <var>M</var>;</li>
                            <li><code><b>msearch</b>(<var>M</var>; <var>x</var>; <var>i</var>; <var>j</var>)</code> - вектор с двата индекса на първия елемент със стойност <var>x</var> в матрицата <var>M</var>, започвайки от индекси <var>i</var> и <var>j</var>;<</li>
                            <li><code><b>mfind</b>(<var>M</var>; <var>x</var>)</code> или</li>
                            <li><code><b>mfind_eq</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са = <var>x</var>;</li>
                            <li><code><b>mfind_ne</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са ≠ <var>x</var>;</li>
                            <li><code><b>mfind_lt</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са &lt; <var>x</var>;</li>
                            <li><code><b>mfind_le</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са &le; <var>x</var>;</li>
                            <li><code><b>mfind_gt</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са &gt; <var>x</var>;</li>
                            <li><code><b>mfind_ge</b>(<var>M</var>; <var>x</var>)</code> - индексите на всички елементи в <var>M</var>, които са &ge; <var>x</var>;</li>
                            <li><code><b>hlookup</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> или</li>
                            <li><code><b>hlookup_eq</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са = <var>x</var>;</li>
                            <li><code><b>hlookup_ne</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са ≠ <var>x</var>;</li>
                            <li><code><b>hlookup_lt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са &lt; <var>x</var>;</li>
                            <li><code><b>hlookup_le</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са &le; <var>x</var>;</li>
                            <li><code><b>hlookup_gt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са &gt; <var>x</var>;</li>
                            <li><code><b>hlookup_ge</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code> - стойностите от ред <var>i</var><sub>2</sub> на <var>M</var>, за които съответните елементи от ред <var>i</var><sub>1</sub> са &ge; <var>x</var>;</li>
                            <li><code><b>vlookup</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> или</li>
                            <li><code><b>vlookup_eq</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са = <var>x</var>;</li>
                            <li><code><b>vlookup_ne</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са ≠ <var>x</var>;</li>
                            <li><code><b>vlookup_lt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са &lt; <var>x</var>;</li>
                            <li><code><b>vlookup_le</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са &le; <var>x</var>;</li>
                            <li><code><b>vlookup_gt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са &gt; <var>x</var>;</li>
                            <li><code><b>vlookup_ge</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code> - стойностите от стълб <var>j</var><sub>2</sub> на <var>M</var>, за които съответните елементи от стълб <var>j</var><sub>1</sub> са &ge; <var>x</var>;</li>
                        </ul>
                    </li>
                    <li>
                        Math:<ul style="list-style-type:none;">
                            <li><code><b>hprod</b>(<var>A</var>; <var>B</var>)</code> - произведение на Hadamard на матриците <var>A</var> и <var>B</var>;</li>
                            <li><code><b>fprod</b>(<var>A</var>; <var>B</var>)</code> - произведение на Frobenius на матриците <var>A</var> и <var>B</var>;</li>
                            <li><code><b>kprod</b>(<var>A</var>; <var>B</var>)</code> - произведение на Kronecker на матриците <var>A</var> и <var>B</var>;</li>
                            <li><code><b>mnorm_1</b>(<var>M</var>)</code> - L1 норма на матрицата <var>M</var>;</li>
                            <li><code><b>mnorm</b>(<var>M</var>)</code> или<br />
                            <li><code><b>mnorm_2</b>(<var>M</var>)</code> - L2 норма на матрицата <var>M</var>;</li>
                            <li><code><b>mnorm_e</b>(<var>M</var>)</code> - норма на Frobenius на матрицата <var>M</var>;</li>
                            <li><code><b>mnorm_i</b>(<var>M</var>)</code> - L∞ норма на матрицата <var>M</var>;</li>
                            <li><code><b>cond_1</b>(<var>M</var>)</code> - число на обусловеност на <var>M</var> на база на L1 нормата;</li>
                            <li><code><b>cond</b>(<var>M</var>)</code> или</li>
                            <li><code><b>cond_2</b>(<var>M</var>)</code> - число на обусловеност на <var>M</var> на база на L2 нормата;</li>
                            <li><code><b>cond_e</b>(<var>M</var>)</code> - число на обусловеност на <var>M</var> на база на нормата на Frobenius;</li>
                            <li><code><b>cond_i</b>(<var>M</var>)</code> - число на обусловеност на <var>M</var> на база на L∞ нормата;</li>
                            <li><code><b>det</b>(<var>M</var>)</code> - детерминанта на матрицата <var>M</var>;</li>
                            <li><code><b>rank</b>(<var>M</var>)</code> - ранг на матрицата <var>M</var>;</li>
                            <li><code><b>trace</b>(<var>M</var>)</code> - следа на матрицата <var>M</var>;</li>
                            <li><code><b>transp</b>(<var>M</var>)</code> - транспонираната матрица на <var>M</var>;</li>
                            <li><code><b>adj</b>(<var>M</var>)</code> - адюнгираната матрица на <var>M</var>;</li>
                            <li><code><b>cofactor</b>(<var>M</var>)</code> - кофакторната матрица на <var>M</var>;</li>
                            <li><code><b>eigenvals</b>(<var>M</var>)</code> - собствените стойности на матрицата <var>M</var>;</li>
                            <li><code><b>eigenvecs</b>(<var>M</var>)</code> - собствените вектори на матрицата <var>M</var>;</li>
                            <li><code><b>eigen</b>(<var>M</var>)</code> - собствените стойности и вектори на матрицата <var>M</var>;</li>
                            <li><code><b>cholesky</b>(<var>M</var>)</code> - декомпозиция на Cholesky на симетрична, положително определена матрица <var>M</var>;</li>
                            <li><code><b>lu</b>(<var>M</var>)</code> - LU декомпозиция на матрицата <var>M</var>;</li>
                            <li><code><b>qr</b>(<var>M</var>)</code> - QR декомпозиция на матрицата <var>M</var>;</li>
                            <li><code><b>svd</b>(<var>M</var>)</code> - декомпозиция по особени стойности на матрицата <var>M</var>;</li>
                            <li><code><b>inverse</b>(<var>M</var>)</code> - обратната матрица на <var>M</var>;</li>
                            <li><code><b>lsolve</b>(<var>A</var>; <var>b</var>)</code> - решава системата линейни уравнения <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var> като използва LDL<sup>T</sup> декомпозиция за симетрични матрици и LU декомпозиция за несиметрични;</li>
                            <li><code><b>clsolve</b>(<var>A</var>; <var>b</var>)</code> - решава системата линейни уравнения <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var> със симетрична, положително определена матрица на коефициентите <var>A</var> като използва декомпозиция на Холецки;</li>
                            <li><code><b>msolve</b>(<var>A</var>; <var>B</var>)</code> - решава обобщеното матрично уравнение <var>AX</var> = <var>B</var> като използва LDL<sup>T</sup> декомпозиция за симетрични матрици <var>A</var> и LU декомпозиция за несиметрични;</li>
                            <li><code><b>cmsolve</b>(<var>A</var>; <var>B</var>)</code> - решава системата линейни уравнения <var>AX</var> = <var>B</var> със симетрична, положително определена матрица на коефициентите <var>A</var> като използва декомпозиция на Холецки;</li>
                        </ul>
                    </li>
                    <li>
                        Двойна интерполация:<ul style="list-style-type:none;">
                            <li><code><b>take</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - връща елемента на матрицата <var>M</var> с индекси <var>x</var> и <var>y</var>;</li>
                            <li><code><b>line</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - двойна линейна интерполация от елементите на матрицата <var>M</var> въз основа на стойностите на <var>x</var> и <var>y</var>;</li>
                            <li><code><b>spline</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code> - двойна spline интерполация на Ермит от елементите на матрицата <var>M</var> на база на стойностите на <var>x</var> и <var>y</var>.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        </ul></li></ul>
        <p>Аргументите на функциите трябва да за заградени със скоби. Те могат да бъдат константа, променлива или израз. Ако аргументите са повече от един, те се разделят с точка и запетая ";". Когато аргументите излизат извън дефиниционната област, получения резултат е "<span class="err">Недефинирано</span>". Изключение от това правят "<b>cot</b>(0)" и "<b>coth</b>(0)", които връщат "<span class="err">+∞</span>".</p>
        <p>Аргументите на тригонометричните функции могат да бъдат в <b>градуси</b>, <b>радиани</b> или <b>гради</b>. Може да ги задавате по няколко начина:
        <p>1. От съответните радио бутони над прозореца с резултати "<b>&#128280; D</b>", "<b>&#128280; R</b>" и "<b>&#128280; G</b>".</p>
        <p>2. Чрез ключови думи в самата записка. Трябва да вмъкнете отделен ред със съдържание, съответно <span class="cond">#deg</span> за <b>градуси</b>, <span class="cond">#rad</span> за <b>радиани</b> и <span class="cond">#gra</span> за <b>гради</b>. Това се отразява на всички изрази след съответния ред. Настройките, направени по този начин в кода са меродавни спрямо тези от радио бутоните.</p>
        <p>3. Чрез добавяне на мерни единици към самите стойности на ъглите: <i>deg</i>, <i>°</i>, <i>′</i>, <i>″</i>, <i>rad</i>, <i>grad</i>, <i>rev</i> (виж "Мерни единици" по-нататък). Последните се приемат за меродавни пред всички останали настройки.</p>
        <p>Всички функции са дефинирани и в комплексната си форма и могат да се ползват с комплексни числа, с изключение на функциите <b>mod</b>(<var>x</var>; <var>y</var>), <b>gcd</b>(<var>x</var>; <var>y</var>), <b>lcm</b>(<var>x</var>; <var>y</var>), <code><b>min</b>(<var>x</var>; <var>y</var>)</code> и <code><b>max</b>(<var>x</var>; <var>y</var>)</code>. Функциите за закръгляване се отразяват едновременно на реалната и имагинерната част на комплексното число. Може да използвате и няколко функции, предназначени специално за обработка на комплексни числа: </p>
        <ul style="list-style-type:none;">
            <li><code><b>re</b>(a + b<var>i</var>)</code> - реална част от числото, <code><b>re</b>(a + b<var>i</var>) = a</code>;</li>
            <li><code><b>im</b>(a + b<var>i</var>)</code> - имагинерна част от числото, като реално число, <code><b>im</b>(a + b<var>i</var>) = b</code>;</li>
            <li><code><b>abs</b>(a + b<var>i</var>)</code> - модул на комплексното число <code>= <b>sqrt</b>(a<sup>2</sup> + b<sup>2</sup>)</code>;</li>
            <li><code><b>phase</b>(<var>x</var>)</code> - фаза на комплексното число (аргумент) <code>= <b>atan2</b>(a; b)</code>.</li>
        </ul>
        <p>Всяка функция връща като резултат една единствена стойност. Това важи дори и за многозначните функции. Останалите значения, могат да бъдат добавени в хода на решението чрез допълнителен код.</p>
        </ul>
        <p>Логическите функции приемат числени стойности и връщат “<b>0</b>” за “<b>неистина</b>” и “<b>1</b>” за “<b>истина</b>”. Резултатите за два два аргумента (един за “<b>not</b>”) са дадени в следните таблици:</p>
        <table width="100%">
            <tr>
                <td style="border:none; vertical-align:top;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th style="width:60%">not(x)</th></tr>
                        <tr><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">and(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>0</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">or(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <table width="90%" class="tr">
                        <tr><th>x</th><th>y</th><th style="width:50%">xor(x; y)</th></tr>
                        <tr><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td></tr>
                        <tr><td>1</td><td>1</td><td>0</td></tr>
                    </table>
                </td>
            </tr>
        </table>
        <p>Всяка стойност, различна от 0, се третира като 1 (истина). Аргументите на многопараметричните функции се изчисляват последователно отляво-надясно, съгласно горните таблици. Първоначално се започва с първите два. Полученият резултат се комбинира със следващия аргумент отдясно и т.н.</p>
        <p>Закръгляването на кратните на половин стойности с <b>round</b>() става към по-голямото по абсолютна стойност съседно цяло число (по-отдалеченото от нула). Функцията <b>floor</b>() закръглява към по-малкото цяло число в посока -∞, а <b>ceiling</b>() - към по-голямото в посока +∞. За разлика от <b>floor</b>(), <b>trunc</b>() закръглява към по-близкото до нулата съседно цяло число. Това е равносилно на директното отрязване на дробната част, откъдето идва и името на функцията. В таблицата по-долу са дадени някои примери за закръгляване на положителни и отрицателни числа:</p>
        <table width="70%">
            <tr>
                <td style="border:none;">
                    <p><b>Положителни</b></p>
                    <table width="90%" class="tr">
                        <tr><th>Функция</th><th style="width:30%">x</th><th>Резултат</th></tr>
                        <tr><th>round(x)</th><td>4.5</td><td>5</td></tr>
                        <tr><th>floor(x)</th><td>4.8</td><td>4</td></tr>
                        <tr><th>ceiling(x)</th><td>4.2</td><td>5</td></tr>
                        <tr><th>trunc(x)</th><td>4.8</td><td>4</td></tr>
                    </table>
                </td>
                <td style="border:none;">
                    <p><b>Отрицателни</b></p>
                    <table width="90%" class="tr">
                        <tr><th>Функция</th><th style="width:30%">x</th><th>Резултат</th></tr>
                        <tr><th>round(x)</th><td>-4.5</td><td>-5</td></tr>
                        <tr><th>floor(x)</th><td>-4.8</td><td>-5</td></tr>
                        <tr><th>ceiling(x)</th><td>-4.2</td><td>-4</td></tr>
                        <tr><th>trunc(x)</th><td>-4.8</td><td>-4</td></tr>
                    </table>
                </td>
            </tr>
        </table>
        <p>Закръгляването на комплексни числа се отразява както на реалната, така и на имагинерната част.</p>

        <h4>Потребителски функции</h4>
        <p>Може да дефинирате и свои собствени функции, които да използвате по-нататък по същия начин, както и библиотечните. Потребителските функции може да имат неограничен брой аргументи. Те се посочват след името на функцията, заградени в скоби "<b>(</b>…<b>)</b>" и  с точка и запетая "<b>;</b>" за разделител. Дефинирането на функция става със следния запис: <code>"<b>f</b>(<var>x</var>; <var>y</var>; <var>z</var>;…) = <b>израз</b>"</code>, където "<b>f</b>" е името на функцията, а "<b>x</b>", "<b>y</b>" и "<b>z</b>" са аргументите. От дясната страна може да поставите всякакъв валиден израз, съдържащ, константи, променливи, оператори, и дори други функции, като например:</p>
        <ul style="list-style-type:none;">
            <li><code><b>f</b>(<var>x</var>) = <var>x</var>^2 + 2*x*<b>sin</b>(<var>x</var>)</code></li>
            <li><code><b>g</b>(<var>x</var>; <var>y</var>) = <b>f</b>(<var>x</var>)/(<var>y</var> - 4)</code></li>
        </ul>
        <p>След като една функция е дефинирана, може да я използвате по-нататък в други изрази, като обръщение към функцията. За целта, трябва  да напишете името на функцията и да посочите в скоби стойности за аргументите, например: <code><var>b</var> = <b>g</b>(<var>a</var> + 2; 3) + 3</code>. За имената на функциите важат същите правила, както за имената на променливите. Като стойност на аргумент, може да посочите всякакъв валиден израз. Цикълът на живот на една функция е от мястото на нейното дефиниране, до края на записката. Ако след това обаче дефинирате  нова функция със същото име, тя ще замести старата. Не може да предефинирате библиотечни функции, например <code><b>sin</b>(<var>x</var>) = <var>x</var>^2</code>. Програмата ще върне съобщение за грешка.</p>

        <p>Аргументите на функциите са специален вид "вътрешни" (или "локални") променливи и не е необходимо да ги дефинирате предварително. Ако  използвате глобални променливи в тялото на функцията, те трябва да са дефинирани преди първото и извикване. Може да имате и глобална променлива със същото име като някой от аргументите. Когато функцията се изчислява, ще се използва стойността, подадена на локалния аргумент, а не записаната в глобалната променлива. При това, самата глобална променлива няма да бъде презаписана, а ще запази първоначалната си стойност. Например:</p>
        <ul style="list-style-type:none;">
            <li>Ако дефинирате променлива "<var>x</var> = 4"</li>
            <li>и функция "<b>f</b>(<var>x</var>) = <var>x</var><sup>2</sup>".</li>
            <li>Когато извикате "<b>f</b>(2)", тя ще се изчисли като <var>x</var><sup>2</sup> = 2<sup>2</sup> = 4, защото локалният аргумент е <var>x</var> = 2</li>
            <li>Ако след това извикате "<var>x</var><sup>2</sup>", ще върне стойност <var>x</var><sup>2</sup> = 4<sup>2</sup> = 16, защото глобалния <var>x</var> остава 4.</li>
        </ul>
        <p>Потребителските функции могат да работят както с реални, така и с комплексни числа.</p>

        <h3 id="TOC_406">Графики на функции</h3>
        <p>Calcpad включва и няколко команди със специално предназначение, като например за графики и числени методи. Имената им започват с "$" за да се различават от стандартните функции. Параметрите им се заграждат с фигурни скоби "{" и "}". Такава е и командата за построяване на графика. Тя има следният формат:</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Plot</span>{<b>y</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>, където:</p>
        <ul style="list-style-type:none;">
            <li><b>у</b>(<var>x</var>) - функцията, чиято графика трябва да се изчертае. Вместо <b>у</b>(<var>x</var>) може да поставите всякакъв валиден израз. Той ще се използва за изчисляването на стойностите по ординатата;</li>
            <li><var>x</var> - името на променливата, която съответства на абсцисата. Тук трябва да стои единствено име на променлива. Не е задължително тя да бъде декларирана предварително;</li>
            <li><var>a</var> и <var>b</var> - границите, в които да се изменя променливата <var>x</var> и в които съответно ще бъде изчертана и самата графика. На мястото на <var>a</var> и <var>b</var> може да поставите числа, променливи или какъвто и да е валиден израз.</li>
        </ul>
        <p>Например, ако въведете: <code><span class="cond">$Plot</span>{<var>x</var>^2 - 5*<var>x</var> + 3 &#64; x = -1:6}</code>, ще получите следния резултат:</p>
        <p style="text-align:center;"><img width="450" src="Images/Plot.png" alt="Plot.png"></p>
        <p>Горната команда чертае графиката на една функция с един параметър. Има обаче и други формати, които може да използвате:</p>
        <p style="margin-left: 2em;">
            <code><span class="cond">$Plot</span>{<b>x</b>(<var>t</var>)|<b>y</b>(<var>t</var>) &#64; <var>t</var> = <var>a</var> : <var>b</var>}</code> - параметрична графика: и двете координати са функция на трети параметър;<br />
            <code><span class="cond">$Plot</span>{<b>y</b><sub>1</sub>(<var>x</var>) &amp; <b>y</b><sub>2</sub>(<var>x</var>) &amp;  … &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code> - паралелни графики: няколко функции едновременно на една и съща диаграма;<br />
            <code><span class="cond">$Plot</span>{<b>x</b><sub>1</sub>(<var>t</var>)|<b>y</b><sub>1</sub>(<var>t</var>) &amp; <b>x</b><sub>2</sub>(<var>t</var>)|<b>y</b><sub>2</sub>(<var>t</var>) &amp; … &#64; <var>t</var> = <var>a</var> : <var>b</var>}</code> - паралелни, параметрични;<br />
            <code><span class="cond">$Map</span>{<b>z</b>(<var>x</var>; <var>y</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var> &amp; <var>y</var> = <var>c</var> : <var>d</var>}</code> - чертае изохроми в план на 3D функцията <b>z</b>(<var>x</var>; <var>y</var>).
        </p>
        <p>Изразът <span class="cond">$Plot</span>{…} трябва да е първи и единствен на реда. Преди него, може да имате само празни символи: интервали или табулации. Не се допускат дори и коментари. В противен случай, програмата ще генерира грешка. Всякакъв текст след затварящата скоба <b>"}"</b> ще бъде игнориран. Поддържа се изчертаване на графики само с реални числа. Може да се работи и в режим "Комплексни числа", стига да се използват само реални аргументи и функцията да връща винаги реален резултат.
        <p>Може да посочвате и размера на чертожната зона в пиксели (px), като преди това дефинирате следните служебни променливи: <var>PlotWidth</var> за ширина и <var>PlotHeight</var> - за височина. Стойностите по подразбиране са <var>PlotWidth</var> = 500 and <var>PlotHeight</var> = 300.</p>
        <p>Функцията <span class="cond">$Map</span>{…} може да работи с различни цветови палитри. Изберете предпочитаната опция от падащия списък "<b>Палитра</b>" в долната част на екрана. Ако включите опцията "<b>Преливка</b>", цветовете ще преливат плавно един в друг. В противен случай, ще се изчертават като отделни, ясно разграничени цветни ивици. Може да добавите и 3D ефекти към графиката, като включите опцията "<b>Светлосенки</b>". От падащия списък, може да изберете и посоката на падане на светлината.</p>
        <p>
            По-долу са дадени примери за различните формати на командата за чертане на графики:
            <img style="float:right;" width="300" src="Images/Plot-Rose.png" alt="Plot-Rose.png"><br /><br />
        </p>
        <h4>Параметрична</h4>
        <p>Уравнение:</p>
        <p style="margin-left: 2em;">
            <code><b>r</b>(<var>θ</var>) = <b>cos</b>(5/2*<var>θ</var>)</code><br />
            <code><span class="cond">$Plot</span>{<b>r</b>(<var>θ</var>)*<b>cos</b>(<var>θ</var>)|<b>r</b>(<var>θ</var>)*<b>sin</b>(<var>θ</var>) &#64; <var>θ</var> = 0:6*π}</code>
        </p>
        <p>Резултат: графика на "роза".</p>
        <br /><br /><br /><br />
        <p><img style="float:right;" width="300" src="Images/Plot-Leaf.png" alt="Plot-Leaf.png"><br /></p>
        <h4>Паралелни</h4>
        <p>Уравнение:</p>
        <p style="margin-left: 2em;">
            <code><b>y</b><sub>1</sub>(<var>θ</var>) = <b>cos</b>(<var>θ</var>) - <b>sin</b>(<var>θ</var>)</code><br />
            <code><b>y</b><sub>2</sub>(<var>θ</var>) = <b>cos</b>(<var>θ</var>) + <b>sin</b>(<var>θ</var>)</code><br />
            <code><span class="cond">$Plot</span>{<b>cos</b>(<var>θ</var>) & <b>y</b><sub>1</sub>(<var>θ</var>) & <b>y</b><sub>2</sub>(<var>θ</var>) &#64; <var>θ</var> = 0:<var>π</var>}</code>
        </p>
        <p>Резултат: "листо", оформено от графиките на няколко тригонометрични функии.</p>
        <br />
        <p><img style="float:right;" width="300" src="Images/Plot-Fermat.png" alt="Plot-Fermat.png"><br /></p>
        <h4>Паралелни параметрични</h4>
        <p>Уравнение:</p>
        <p style="margin-left: 2em;">
            <code><b>x</b>(<var>θ</var>) = <b>sqr</b>(<var>θ</var>)*<b>cos</b>(<var>θ</var>)</code><br />
            <code><b>y</b>(<var>θ</var>) = <b>sqr</b>(<var>θ</var>)*<b>sin</b>(<var>θ</var>)</code><br />
            <code><span class="cond">$Plot</span>{<b>x</b>(<var>θ</var>)|<b>y</b>(<var>θ</var>) & -<b>x</b>(<var>θ</var>)|-<b>y</b>(<var>θ</var>) &#64; <var>θ</var> = 0:3*<var>π</var>}</code>
        </p>
        <p>Резултат: двойна спирала на Ферма.</p>
        <br /><br /><br />
        <p><img style="float:right;" width="300" class="plot side" src="Images/Map-Wave.png" alt="Plot-Wave.png"></p>
        <h4>Цветни изохроми</h4>
        <p>Уравнение:</p>
        <p style="margin-left: 2em;"><code><b>f</b>(<var>x</var>; <var>y</var>) = <b>cos</b>(<var>x</var>/3) + <b>sin</b>(<var>y</var>) - <b>sin</b>(<var>x</var>)*<b>cos</b>(<var>y</var>/4)</code></p>
        <p style="margin-left: 2em;"><code><span class="cond">$Map</span>{<b>f</b>(<var>x</var>; <var>y</var>) &#64; <var>x</var> = -15 : 15 & <var>y</var> = -15 : 15}</code></p>
        <p>Резултат: 2D вълнообразна повърхнина.</p>
        <br /><br /><br />

        <h3 id="TOC_407">Числени методи</h3>
        <p>Calcpad притежава вграден "<b>Solver</b>" модул, който може да решава и по-сложни задачи, с помощта на числени методи. Той може да работи само с реални числа, но не и с комплексни. Включени са следните команди:</p>

        <h4>Корени на уравнение</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Root</span>{<b>f</b>(<var>x</var>) = const &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p style="margin-left: 2em;"><code><span class="cond">$Root</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Намира корен на уравнението "<b>f</b>(<var>x</var>) = const". Ако "const" е равно на нула, може да пропуснете "= const" и да приложите втория запис. Тази процедура използва специално разработен за целта <a href="https://iopscience.iop.org/article/10.1088/1757-899X/1276/1/012010">хибриден числен метод</a>, на принципа на вложените интервали (свиващи изображения). Той представлява комбинация от метода на разполовяването с този на Андерсън-Бьорк. На всяка итерация, първоначалният интервал се свива постепенно около корена, докато дължината му не стане по-малка от предварително избрана константа - точност на решението.</p>
        <p>За целта, е необходимо функцията "<b>f</b>(<var>x</var>) - const" да има противоположни знаци в краищата на интервала. Съгласно теоремата на Болцано, ако функцията е и непрекъсната, то съществува поне един корен на уравнението в в интервала [<var>a</var>, <var>b</var>]. Алгоритмите с вложени интервали гарантирано ще намерят апроксимация на корена след краен брой итерации. Ако не съществува корен в разглеждания интервал, програмата ще изпише съобщение за грешка.</p>
        <p style="text-align:center;"><img style="height:130pt;" src="Images/Root.png" alt="Root.png"></p>
        <p>С този метод, може да решавате само уравнения, при които функцията пресича правата "<var>y</var> = const". Когато функцията "<b>f</b>(<var>x</var>) - const" е изцяло положителна или отрицателна и допира правата в точка от едната страна, не може да използвате метод с вложени интервали.</p>
        <p>Ако в началния интервал има няколко корена, програмата ще върне само един от тях. В тези случаи е по-добре първо да изчертаете графиката на функцията и да видите приблизително как са разпределени корените. След това, разделете началния интервал на няколко подинтервала, всеки от които съдържа точно един корен. Накрая, извикайте няколкократно функцията за всеки подинтервал и ще получите всеки един корен поотделно. В някои случаи, този процес може да се автоматизира, особено ако се комбинира с функциите за намиране на минимум и максимум, описани по-нататък.</p>

        <h4>Нестрого търсене на корен</h4>
        <p>Както споменахме по-горе, ако функцията е непрекъсната в дадения интервал и има различни знаци в краищата му, то според теоремата на Болцано, задължително в интервала съществува поне един корен на уравнението. Ако функцията е прекъсната точно в точката, където пресича абсцисата, това реално не е корен и командата <span class="cond">$Root</span> ще изпише съобщение за грешка. Понякога обаче е полезно да намерим мястото, където графиката на функцията пресича абсцисата, дори и реално да не е решение на уравнението. Това може да направите с помощта на следната команда:</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Find</span>{<b>f</b>(<var>x</var>) = const &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>

        <h4>Минимум на функция</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Inf</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Намира минималната стойност на функцията <b>f</b>(<var>x</var>) в зададения интервал [<var>a</var>, <var>b</var>]. За целта се използва методът на златното сечение. Ако функцията има точно един локален минимум, командата ще намери неговата стойност. В противен случай, ще върне по-малката от стойностите в краищата на интервала. Ако в разглеждания интервал има няколко локални минимума, командата ще намери един от тях, но не задължително най-малкия. В такива случаи е добре интервалът да се раздели на подинтервали. Стойността на <var>x</var>, която съответства на намерения минимум, се записва в променлива <var>x</var><sub>inf</sub>. Ако вместо <var>x</var> се използва друго име за локалната променлива, стойността при минимума се получава чрез добавяне на "_inf" в края на съответното име.</p>

        <h4>Максимум на функция</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Sup</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Работи по същия начин, както предишната команда, само че намира максималната стойност на функцията. Стойността на <var>x</var>, която съответства на намерения максимум се записва в променлива с име <var>x</var><sub>sup</sub>.</p>

        <h4>Числено интегриране</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$саa</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Намира стойността на определения интеграл на функцията <b>f</b>(<var>x</var>) в зададения интервал [<var>a</var>, <var>b</var>]. За целта се използва адаптивна квадратура на Гаус-Лобато-Кронрод (<a target="_blank" href="https://www.researchgate.net/publication/226706221_Adaptive_Quadrature-Revisited">Gander & Gautschi</a>, 2000).</p>
        <p style="margin-left: 2em;"><code><span class="cond">$Integral</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Командата е подобна на горната, но използва Tanh-Sinh квадратура (<a target="_blank" href="https://ems.press/content/serial-article-files/2719">Takahashi & Mori</a>, 1974), със следващи подобрения от <a target="_blank" href="https://www.ingentaconnect.com/content/tandf/jew/2016/00000030/00000003/art00001;jsessionid=55mdimh9e060a.x-ic-live-03">Michashki & Mosig</a> (2016) и <a target="_blank" href="https://www.genivia.com/files/qthsh.pdf">Van Engelen</a> (2022). Процедурата в Calcpad е подобрена допълнително, чрез предварителното изчисляване и кеширане на абсцисите и теглата. Този алгоритъм превъзхожда значително командата <code class="cond">$саa</code>, но е приложим само за <b>непрекъснати</b> и <b>гладки</b> функции. Ако функцията не удовлетворява горните условия, <b>не трябва</b> да се използва командата <code class="cond">$Integral</code> директно. Тогава има две възможности:</p>
        <ol>
            <li>Да разделите интервала [<var>a</var>, <var>b</var>] на по-малки части, като използвате точките на прекъсване, да приложите метода за всяка част поотделно и да съберете получените резултати;</li>
            <li>Ако не може да определите предварително точките на прекъсване, използвайте командата <code class="cond">$саa</code>.</li>
        </ol>

        <h4>Числено диференциране</h4>
        <p style="margin-left: 2em;"><code><span class="cond">$Slope</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var>}</code></p>
        <p>Намира стойността на първата производна на функцията <b>f</b>(<var>x</var>) в точка <var>x</var> = <var>a</var>. Производната представлява наклона на допирателната към графиката на функцията в съответната точка. Използва се симетрична крайна разлика с екстраполация на Ричардсън.</p>

        <h4>Общи предпоставки</h4>
        <p>За разлика от командите за графики на функции, командите за числени методи могат да участват в изрази. Това е защото връщат стойност, която може да участва в по-нататъшни изчисления. Например, може да запазите резултата в променлива, както е направено в следния пример:</p>
        <p style="margin-left: 2em;"><code><var>y</var><sub>min</sub> = <span class="cond">$Inf</span>{<b>f</b>(<var>x</var>) &#64; <var>x</var> = <var>a</var> : <var>b</var>}</code></p>
        <p>Аналогично на стандартните потребителски функции, променливата "<var>x</var>" е локална за командата и ако има глобална със същото име, нейната стойност ще остане непроменена след изчислението.</p>

        <h3 id="TOC_408">Итерационни процедури</h3>
        <p>Calcpad включва и няколко процедури за итерационни изчисления. За разлика от числените методи обаче, те могат да работят и с комплексни числа.</p>

        <h4>Крайна сума</h4>
        <p style="margin-left: 2em;"><span class="cond">$Sum</span>{ <b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</p>
        <p>Събира стойностите на <b>f</b>(<var>k</var>) за всички цели числа <var>k</var> между <var>a</var> и <var>b</var>. Стойностите на <var>k</var> може само да нарастват, поради което условието <var>a</var> &lt; <var>b</var> трябва винаги да бъде удовлетворено. На мястото на <b>f</b>(<var>k</var>) може да сложите всякакъв валиден израз, който зависи от <var>k</var>. В противен случай, процедурата ще сумира една и съща стойност <var>k</var> пъти. Така например, може да изчислявате стойностите на константи с помощта на редове. От този вид е и формулата на Лайбниц за изчисляване на &pi;:</p>
        <p style="margin-left: 2em;">4*<span class="cond">$Sum</span> { (-1)<sup><var>k</var> + 1</sup>/(2*<var>k</var> - 1) &#64; <var>k</var> = 1 : 1000 } = 3.1406</p>
        <p>Може също да използвате редове за дефиниране на функции. Разбира се, тези редове не могат да бъдат безкрайни. Трябва да изберете необходимия брой итерации така, че да получите резултатите с достатъчна точност. За да дефинирате функции чрез редове на Фурие, може да използвате следния запис:</p>
        <p style="margin-left: 2em;">f(x) = <var>a</var><sub>0</sub>/2 + <span class="cond">$Sum</span> { a(<var>k</var>)*cos(<var>k</var>*<var>x</var>*π/<var>l</var>) &#64; <var>k</var> = 1 : <var>n</var> } + <span class="cond">$Sum</span> { b(<var>k</var>)*sin(<var>k</var>*<var>x</var>*π/<var>l</var>) &#64; <var>k</var> = 1 : <var>n</var> }</p>
        <p>Като пример, може да вземем права линия със следното уравнение: f(<var>x</var>) = <var>x</var>/(2*<var>l</var>) в интервала (0; 2*<var>l</var>). Интеграционните константи са <var>a</var>(<var>k</var>) = 0 и <var>b</var>(<var>k</var>) = -1/(<var>k</var>*π). Ако построим графиката на апроксимацията за <var>n</var> = 5, ще получим следния резултат:</p>
        <p style="text-align:center;"><img alt="Fourier" src="Images/Fourier.png" width="500"></p>

        <h4>Произведение</h4>
        <p style="margin-left: 2em;"><span class="cond">$Product</span> { <b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var>}</p>
        <p>Работи подобно на "<b>Сума</b>", с тази разлика, че умножава отделните членове на редицата, вместо да ги събира. Например, може да използвате тази процедура за да дефинирате функция за изчисляване на факториел:</p>
        <p style="margin-left: 2em;"><b>F</b>(<var>n</var>) = <span class="cond">$Product</span> {<var>k</var> &#64; <var>k</var> = 1 : <var>n</var>}</p>
        <p>По-нататък, с нейна помощ,  може да изчислите и биномните коефициенти: <b>C</b>(<var>n</var>; <var>k</var>) = <b>F</b>(<var>n</var>)/(<b>F</b>(<var>k</var>)*<b>F</b>(<var>n</var> - <var>k</var>)). Много по-ефективно е обаче да напишете отделна функция, която да ги изчислява без използването на три факториела:</p>
        <p style="margin-left: 2em;"><span class="cond">$Product</span>{ (<var>i</var> + <var>n</var> - <var>k</var>)/<var>i</var> &#64; <var>i</var> = <var>1</var> : <var>k</var>}</p>
        <p>Освен, че ще е по-бързо, няма да настъпи препълване отгоре при големи стойности на <var>n</var>.</p>

        <h4>Проста итерация</h4>
        <p style="margin-left: 2em;"><span class="cond">$Repeat</span> { <b>f</b>(<var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var> }</p>
        <p>Това е едноредова итерационна процедура, от общ вид, която последователно изчислява <b>f</b>(<var>k</var>). Може да се използва и вместо горните процедури за сума и произведение, но е по-неефективна. Има обаче и по-сложни изрази, които могат да се изчислят само с този тип итерация. Обикновено това има смисъл когато записваме резултата от всяка итерация в променлива, която да се използва в следващата итерация. Поради това, за практическо приложение е по-подходящ следният запис:</p>
        <p style="margin-left: 2em;"><span class="cond">$Repeat</span> { <var>x</var> = <b>f</b>(<var>x</var>; <var>k</var>) &#64; <var>k</var> = <var>a</var> : <var>b</var> }</p>
        <p>Например, може да използвате тази процедура за да изчислите множеството на Mandelbrot в един ред:
        <p style="margin-left: 2em;"><b>f</b>(<var>z</var>; <var>c</var>) = <span class="cond">$Repeat</span> { <var>z</var> = <var>z</var>^2 + <var>c</var> &#64; <var>i</var> = 1 : 100 }</p>
        <p>Не забравяйте да включите режима за комплексни числа. След това, може да построите и графика на множеството:
        <p style="margin-left: 2em;"><span class="cond">$Map</span> { <b>abs</b>(<b>f</b>(0; <var>x</var> + 1i*<var>y</var>)) &#64; <var>x</var> = -1.5 : 0.5 & <var>y</var> = -1 : 1 }</p>
        <p style="text-align:center;"><img alt="Mandelbrot" src="Images/Mandelbrot.png" width="500"></p>

        <h3 id="TOC_409">Мерни единици</h3>
        <p>Calcpad поддържа и изчисляване на изрази с мерни единици. В настоящата версия са включени единици както от метричната система: SI и съвместими, така и неметрични: US и Imperial. Те се подчиняват на няколко прости правила:</p>
        <p>Има само 7 базови мерни единици, които съответстват на седемте основни физични величини:</p>
        <ul>
            <li>маса - килограм (<i>kg</i>)</li>
            <li>дължина - метър (<i>m</i>)</li>
            <li>време - секунда (<i>s</i>)</li>
            <li>електрически ток - Ампер (<i>A</i>)</li>
            <li>температура - градус (<i>°C</i>)</li>
            <li>количество вещество - мол (<i>mol</i>)</li>
            <li>интензитет на светлината - кандела (<i>cd</i>)</li>
        </ul>
        <p>Всички останали мерни единици са производни на горните. Те се получават чрез съответните физични закони. Например, сила = маса&middot;ускорение и съответно, единицата за сила Нютон се дефинира като <i>N</i> = <i>kg</i>&middot;<i>m</i>/<i>s</i><sup>2</sup>. Чрез добавянето на представки пред имената, пък се получават кратни мерни единици, например: <i>kN</i> = 10<sup>3</sup><i>N</i>, <i>MN</i> = 10<sup>6</sup><i>N</i> и т.н. Това е направено предварително и програмата има вградена библиотека от мерни единици, готови за употреба.</p>
        <p>В допълнение, има и някои "бездименсионни" единици като проценти, промили и за измерване на ъгли (градуси, радиани и др.), които не включват физични дименсии. Специално за ъгли обаче е добавена осма, нефизична дименсия, за да могат да съществуват отделно от процентите/промилите, без да се съкращават или конвертират към тях, когато се смесят в един и същ израз.</p>
        <p>Може да добавяте мерни единици след всяка една стойност в програмния код, например: 15<i>kg</i>. Оттук нататък, те ще бъдат отчетени в изчисленията. Те могат да участват в аритметични изрази, при което Calcpad ще извърши автоматично преобразуване и изравняване на дименсиите. Например, долният израз ще бъде изчислен по следния начин:</p>
        <p style="margin-left: 2em;">1.23<i>m</i> + 35<i>cm</i> + 12<i>mm</i> = 1.59<i>m</i> (а не: 1.23 + 35 + 12 = 48.23)</p>
        <p>Ако не е посочено друго, резултатът ще се преобразува към първите срещнати единици в израза. Ако искате да получите резултата в избрани от вас мерни единици, в края на израза добавете вертикална черта "|" и предпочитаните мерни единици:</p>
        <p style="margin-left: 2em;">1.23<i>m</i> + 35<i>cm</i> + 12<i>mm</i>|<i>cm</i></p>
        <p>Резултатът от горния израз ще бъде 159.2<i>cm</i>. Ако искате да използвате програмата само за преобразуване на мерни единици, просто напишете изходните и отправните единици, разделени с вертикална черта:</p>
        <p style="margin-left: 2em;"><i>mm</i>|<i>cm</i> или 10<i>m</i>/<i>s</i>|<i>km</i>/<i>h</i>.</p>
        <p>Calcpad проверява автоматично съвместимостта на мерните единици в изразите. Ако те са несъвместими като например <i>m</i> и <i>s</i>, не може да ги сравнявате, събирате, изваждате и конвертирате (например 6<i>m</i> + 2<i>s</i>). Може обаче да ги умножавате и делите:</p>
        <p style="margin-left: 2em;">6<i>m</i>/2<i>s</i> = 3<i>m</i>/<i>s</i>.</p>
        <p>Аргументите на библиотечните тригонометрични, хиперболични, логаритмични и експоненциални функции трябва по дефиниция да са бездименсионни. Може обаче да използвате единици в потребителски функции, ако имат физически смисъл. Може да присвоявате стойности с мерни единици и на променливите. Ако посочите желаните единици в дефиницията на променлива или функция, те ще се запомнят за постоянно. Оттук нататък, съответната стойност по подразбиране  ще се замества винаги в посочените единици. В примера по-долу, скоростта е получена от разделянето на <i>m</i>/<i>s</i>, но е преобразувана и съхранена като <i>km</i>/<i>h</i>:</p>
        <table border="1">
            <thead>
                <tr>
                    <th>
                        Програмен код
                    </th>
                    <th>
                        Резултат
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="line-height:180%;">
                        <code>'Разстояние -'<var>s</var>_1 = 50<i>m</i></code><br />
                        <code>'Време -'<var>t</var>_1 = 2<i>s</i></code><br />
                        <code>'Скорост -'<var>V</var> = <var>s</var>_1/<var>t</var>_1|<i>km</i>/<i>h</i></code><br />
                        <code>'Какво разстояние ще изминете за'<var>t</var>_2 = 5<i>s</i>'?</code><br />
                        <code><var>s</var>	_2 = <var>V</var>*<var>t</var>_2|<i>m</i></code>
                    </td>
                    <td style="line-height:150%;">
                        Разстояние - <var>s</var><sub>1</sub> = 50<i>m</i><br />
                        Време - <var>t</var><sub>1</sub> = 2<i>s</i><br />
                        Скорост - <var>V</var> = <var>s</var><sub>1</sub>/<var>t</var><sub>1</sub> = 50<i>m</i>/2<i>s</i> = 90<i>km</i>/<i>h</i><<br />
                        Какво разстояние ще изминете за <var>t</var><sub>2</sub> = 5<i>s</i> ? <br />
                        <var>s</var><sub>2</sub> = <var>V</var>·<var>t</var><sub>2</sub> = 90<i>km</i>/<i>h</i>·5<i>s</i> = 125<i>m</i>
                    </td>
                </tr>
            </tbody>
        </table>
        <h4>Предефинирани</h4>
        <p>Пълният списък на вградените мерни единици, които може да използвате в Calcpad, е даден по долу, както следва:</p>
        <p>Бездименсионни:</p>
        <ul>
            <li>
                Части:
                <i title="процент">%</i>,
                <i title="промил">‰</i>,
                <i title="десетохилядна">‱</i>,
                <i title="стохилядна">pcm</i>,
                <i title="милионна">ppm</i>,
                <i title="билионна">ppb</i>,
                <i title="трилионна">ppt</i>,
                <i title="квадрилионна">ppq</i>;
            </li>
            <li>
                ъгли:
                <i title="градуси">°</i>,
                <i title="минути">′</i>,
                <i title="секунди">″</i>,
                <i title="градуси">deg</i>,
                <i title="радиани">rad</i>,
                <i title="гради">grad</i>,
                <i title="обороти">rev</i>;
            </li>
        </ul>
        <p>Метрични единици (SI и съвместими):</p>
        <ul>
            <li>
                Маса:
                <i title="грам">g</i>,
                <i title="хектограм">hg</i>,
                <i title="килограм">kg</i>,
                <i title="тон">t</i>,
                <i title="килотон">kt</i>,
                <i title="мегатон">Mt</i>,
                <i title="гигатон">Gt</i>,
                <i title="дециграм">dg</i>,
                <i title="сантиграм">cg</i>,
                <i title="милиграм">mg</i>,
                <i title="микрограм">μg</i>,
                <i title="нанограм">ng</i>,
                <i title="пикограм">pg</i>,
                <i title="Далтон">Da</i>,
                <i title="Далтон (алт.)">u</i>;
            </li>
            <li>
                Дължина:
                <i title="метър">m</i>,
                <i title="километър">km</i>,
                <i title="дециметър">dm</i>,
                <i title="сантиметър">cm</i>,
                <i title="милиметър">mm</i>,
                <i title="микрометър">μm</i>,
                <i title="нанометър">nm</i>,
                <i title="пикометър">pm</i>,
                <i title="астрономическа единица">AU</i>,
                <i title="светлинна година">ly</i>;
            </li>
            <li>
                Време:
                <i title="секунда">s</i>,
                <i title="милисекунда">ms</i>,
                <i title="микросекунда">μs</i>,
                <i title="наносекунда">ns</i>,
                <i title="пикосекунда">ps</i>,
                <i title="минута">min</i>,
                <i title="час">h</i>,
                <i title="ден">d</i>,
                <i title="седмица">w</i>,
                <i title="Година">y</i>;
            </li>
            <li>
                Честота:
                <i title="Херц">Hz</i>,
                <i title="килохерц">kHz</i>,
                <i title="мегахерц">MHz</i>,
                <i title="гигахерц">GHz</i>,
                <i title="терахерц">THz</i>,
                <i title="милихерц">mHz</i>,
                <i title="микрохерц">μHz</i>,
                <i title="нанохерц">nHz</i>,
                <i title="пикохерц">pHz</i>,
                <i title="оборота в минута">rpm</i>;
            </li>
            <li>
                Скорост:
                <i title="километра в час">kmh</i>;
            </li>
            <li>
                Електрически поток:
                <i title="Ампер">A</i>,
                <i title="килоампер">kA</i>,
                <i title="мегаампер">MA</i>,
                <i title="гигаампер">GA</i>,
                <i title="тераампер">TA</i>,
                <i title="милиампер">mA</i>,
                <i title="микроампер">μA</i>,
                <i title="наноампер">nA</i>,
                <i title="пикоампер">pA</i>;
            </li>
            <li>
                Температура:
                <i title="градус Целзий">°C</i>,
                <i title="разлика в градуси Целзий">Δ°C</i>,
                <i title="Келвин">K</i>;
            </li>
            <li>
                Количество вещество:
                <i title="мол">mol</i>;
            </li>
            <li>
                Интензитет на светлината:
                <i title="кандела">cd</i>;
            </li>
            <li>
                Площ:
                <i title="ар">a</i>,
                <i title="декар">daa</i>,
                <i title="хектар">ha</i>;
            </li>
            <li>
                Обем:
                <i title="литър">L</i>,
                <i title="декалитър">daL</i>,
                <i title="хектолитър">hL</i>,
                <i title="децилитър">dL</i>,
                <i title="сантилитър">cL</i>,
                <i title="милилитър">mL</i>,
                <i title="микролитър">μL</i>,
                <i title="нанолитър">nL</i>,
                <i title="пиколитър">pL</i>;
            </li>
            <li>
                Сила:
                <i title="dyne">dyn</i>
                <i title="Нютон">N</i>,
                <i title="деканютон">daN</i>,
                <i title="хектонютон">hN</i>,
                <i title="килонютон">kN</i>,
                <i title="меганютон">MN</i>,
                <i title="гиганютон">GN</i>,
                <i title="теранютон">TN</i>,
                <i title="грам-сила">gf</i>,
                <i title="килограм-сила">kgf</i>,
                <i title="тон-сила">tf</i>;
            </li>
            <li>
                Момент:
                <i title="Нютон-метър">Nm</i>,
                <i title="килонютон-метър">kNm</i>;
            </li>
            <li>
                Налягане:
                <i title="Паскал">Pa</i>,
                <i title="декапаскал">daPa</i>,
                <i title="hectпаскал">hPa</i>,
                <i title="килопаскал">kPa</i>,
                <i title="мегапаскал">MPa</i>,
                <i title="гигапаскал">GPa</i>,
                <i title="терапаскал">TPa</i>,
                <i title="деципаскал">dPa</i>,
                <i title="сантипаскал">cPa</i>,
                <i title="милипаскал">mPa</i>,
                <i title="микропаскал">μPa</i>,
                <i title="нанопаскал">nPa</i>,
                <i title="пикопаскал">pPa</i>,
                <br />&emsp;&emsp;&emsp;&emsp;&nbsp;
                <i title="бар">bar</i>,
                <i title="милибар">mbar</i>,
                <i title="микробар">μbar</i>,
                <i title="атмосфера">atm</i>,
                <i title="техническа атмосфера">at</i>,
                <i title="Тор">Torr</i>,
                <i title="милиметра живачен стълб">mmHg</i>;
            </li>
            <li>
                Вискозитет:
                <i title="Поаз">P</i>,
                <i title="сантипоаз">cP</i>,
                <i title="Стокс">St</i>,
                <i title="сантистокс">cSt</i>;
            </li>
            <li>
                Енергия/работа:
                <i title="Джаул">J</i>,
                <i title="килоджаул">kJ</i>,
                <i title="мегаджаул">MJ</i>,
                <i title="гигаджаул">GJ</i>,
                <i title="тераджаул">TJ</i>,
                <i title="милиджаул">mJ</i>,
                <i title="микроджаул">μJ</i>,
                <i title="наноджаул">nJ</i>,
                <i title="пикоджаул">pJ</i>,
                <br />&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="Ват-час">Wh</i>,
                <i title="киловат-час">kWh</i>,
                <i title="мегават-час">MWh</i>,
                <i title="гигават-час">GWh</i>,
                <i title="терават-час">TWh</i>,
                <i title="миливат-час">mWh</i>,
                <i title="микроват-час">μWh</i>,
                <i title="нановат-час">nWh</i>,
                <i title="пиковат-час">pWh</i>,
                <br />&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="електронволт">eV</i>,
                <i title="килоелектронволт">keV</i>,
                <i title="мегаелектронволт">MeV</i>,
                <i title="гигаелектронволт">GeV</i>,
                <i title="тераелектронволт">TeV</i>,
                <i title="пентаелектронволт">PeV</i>,
                <i title="екзаелектронволт">EeV</i>,
                <i title="калория">cal</i>,
                <i title="килокалория">kcal</i>,
                <i title="ерг">erg</i>;
            </li>
            <li>
                Мощност:
                <i title="Ват">W</i>,
                <i title="киловат">kW</i>,
                <i title="мегават">MW</i>,
                <i title="гигават">GW</i>,
                <i title="терават">TW</i>,
                <i title="миливат">mW</i>,
                <i title="микроват">μW</i>,
                <i title="нановат">nW</i>,
                <i title="пиковат">pW</i>,
                <i title="конска сила (метрична)">hpM</i>,
                <i title="конска сила (метрична)">ks</i>,
                <br />&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="Волт-Ампер">VA</i>,
                <i title="киловолт-Ампер">kVA</i>,
                <i title="мегаволт-Ампер">MVA</i>,
                <i title="гигаволт-Ампер">GVA</i>,
                <i title="тераволт-Ампер">TVA</i>,
                <i title="миливолт-Ампер">mVA</i>,
                <i title="микроволт-Ампер">μVA</i>,
                <i title="нановолт-Ампер">nVA</i>,
                <i title="пиковолт-Ампер">pVA</i>,
                <br />&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="Волт-Ампер (реактивна)">VAR</i>,
                <i title="киловолт-Ампер (реактивна)">kVAR</i>,
                <i title="мегаволт-Ампер (реактивна)">MVAR</i>,
                <i title="гигаволт-Ампер (реактивна)">GVAR</i>,
                <i title="тераволт-Ампер (реактивна)">TVAR</i>,
                <i title="миливолт-Ампер (реактивна)">mVAR</i>,
                <i title="микроволт-Ампер (реактивна)">μVAR</i>,
                <i title="нановолт-Ампер (реактивна)">nVAR</i>,
                <i title="пиковолт-Ампер(реактивна) ">pVAR</i>;
            </li>
            <li>
                Електрически заряд:
                <i title="Кулон">C</i>,
                <i title="килокулон">kC</i>,
                <i title="мегакулон">MC</i>,
                <i title="гигакулон">GC</i>,
                <i title="теракулон">TC</i>,
                <i title="миликулон">mC</i>,
                <i title="микрокулон">μC</i>,
                <i title="нанокулон">nC</i>,
                <i title="пикокулон">pC</i>,
                <i title="ампер-час">Ah</i>,
                <i title="милиампер-час">mAh</i>;
            </li>
            <li>
                Напрежение:
                <i title="Волт">V</i>,
                <i title="киловолт">kV</i>,
                <i title="мегаволт">MV</i>,
                <i title="гигаволт">GV</i>,
                <i title="тераволт">TV</i>,
                <i title="миливолт">mV</i>,
                <i title="микроволт">μV</i>,
                <i title="нановолт">nV</i>,
                <i title="пиковолт">pV</i>;
            </li>
            <li>
                Капацитет:
                <i title="Фарад">F</i>,
                <i title="килофарад">kF</i>,
                <i title="мегафарад">MF</i>,
                <i title="гигафарад">GF</i>,
                <i title="терафарад">TF</i>,
                <i title="милифарад">mF</i>,
                <i title="микрофарад">μF</i>,
                <i title="нанофарад">nF</i>,
                <i title="пикофарад">pF</i>;
            </li>
            <li>
                Съпротивление:
                <i title="Ом">Ω</i>,
                <i title="килоом">kΩ</i>,
                <i title="мегаом">MΩ</i>,
                <i title="гигаом">GΩ</i>,
                <i title="тераом">TΩ</i>,
                <i title="милиом">mΩ</i>,
                <i title="микроом">μΩ</i>,
                <i title="наноом">nΩ</i>,
                <i title="пикоом">pΩ</i>;
            </li>
            <li>
                Проводимост:
                <i title="Сименс">S</i>,
                <i title="килосименс">kS</i>,
                <i title="мегасименс">MS</i>,
                <i title="гигасименс">GS</i>,
                <i title="терасименс">TS</i>,
                <i title="милисименс">mS</i>,
                <i title="микросименс">μS</i>,
                <i title="наносименс">nS</i>,
                <i title="пикосименс">pS</i>,
                <i title="мо">℧</i>,
                <i title="киломо">k℧</i>,
                <i title="мегамо">M℧</i>,
                <i title="гигамо">G℧</i>,
                <i title="терамо">T℧</i>,
                <i title="милимо">m℧</i>,
                <i title="микромо">μ℧</i>,
                <i title="наномо">n℧</i>,
                <i title="пикомо">p℧</i>;
            </li>
            <li>
                Магнитен поток:
                <i title="Вебер">Wb </i>,
                <i title="киловебер">kWb</i>,
                <i title="мегавебер">MWb</i>,
                <i title="гигавебер">GWb</i>,
                <i title="теравебер">TWb</i>,
                <i title="миливебер">mWb</i>,
                <i title="микровебер">μWb</i>,
                <i title="нановебер">nWb</i>,
                <i title="пиковебер">pWb</i>;
            </li>
            <li>
                Плътност на потока:
                <i title="Тесла">T</i>,
                <i title="килотесла">kT</i>,
                <i title="мегатесла">MT</i>,
                <i title="гигатесла">GT</i>,
                <i title="тератесла">TT</i>,
                <i title="милитесла">mT</i>,
                <i title="микротесла">μT</i>,
                <i title="нанотесла">nT</i>,
                <i title="пикотесла">pT</i>;
            </li>
            <li>
                Индукция:
                <i title="Хенри">H</i>,
                <i title="килохенри">kH</i>,
                <i title="мегахенри">MH</i>,
                <i title="гигахенри">GH</i>,
                <i title="терахенри">TH</i>,
                <i title="милихенри">mH</i>,
                <i title="микрохенри">μH</i>,
                <i title="нанохенри">nH</i>,
                <i title="пикохенри">pH</i>;
            </li>
            <li>
                Светлинен поток:
                <i title="лумен">lm</i>;
            </li>
            <li>
                Осветеност:
                <i title="лукс">lx</i>;
            </li>
            <li>
                Радиоактивност:
                <i title="Бекерел">Bq</i>,
                <i title="килобекерел">kBq</i>,
                <i title="мегабекерел">MBq</i>,
                <i title="гигабекерел">GBq</i>,
                <i title="терабекерел">TBq</i>,
                <i title="милибекерел">mBq</i>,
                <i title="микробекерел">μBq</i>,
                <i title="нанобекерел">nBq</i>,
                <i title="пикобекерел">pBq</i>,
                <i title="Кюри">Ci</i>,
                <i title="Ръдърфорд">Rd</i>;
            </li>
            <li>
                Погълната доза:
                <i title="Грей">Gy</i>,
                <i title="килогрей">kGy</i>,
                <i title="мегагрей">MGy</i>,
                <i title="гигагрей">GGy</i>,
                <i title="терагрей">TGy</i>,
                <i title="милигрей">mGy</i>,
                <i title="микрогрей">μGy</i>,
                <i title="наногрей">nGy</i>,
                <i title="пикогрей">pGy</i>;
            </li>
            <li>
                Еквивалентна доза:
                <i title="Сиверт">Sv</i>,
                <i title="килосиверт">kSv</i>,
                <i title="мегасиверт">MSv</i>,
                <i title="гигасиверт">GSv</i>,
                <i title="терасиверт">TSv</i>,
                <i title="милисиверт">mSv</i>,
                <i title="микросиверт">μSv</i>,
                <i title="наносиверт">nSv</i>,
                <i title="пикосиверт">pSv</i>;
            </li>
            <li>
                Активност на катализатор:
                <i title="катал">kat</i>;
            </li>
        </ul>
        <p>Неметрични единици (Imperial/US):</p>
        <ul>
            <li>
                Маса:
                <i title="grain">gr</i>,
                <i title="drachm">dr</i>,
                <i title="ounce">oz</i>,
                <i title="pound">lb</i> (или
                <i title="pound-mass">lbm</i>,
                <i title="pound-mass (alt)">lb</i><sub>_m</sub>),
                <i title="kilopound-mass">kipm</i> (или
                <i title="kilopound-mass (alt)">kip</i><sub>_m</sub>),
                <i title="stone">st</i>,
                <i title="quarter">qr</i>, <br />&emsp;&emsp;&ensp;
                <i title="hundredweight">cwt</i> (или
                <i title="hundredweight (UK)">cwt</i><sub>_UK</sub>,
                <i title="hundredweight (US)">cwt</i><sub>_US</sub>),
                <i title="ton">ton</i> (или
                <i title="ton (UK)">ton</i><sub>_UK</sub>,
                <i title="ton (US)">ton</i><sub>_US</sub>),
                <i title="slug">slug</i>;
            </li>
            <li>
                Дължина:
                <i title="thou">th</i>,
                <i title="inch">in</i>,
                <i title="foot">ft</i>,
                <i title="yard">yd</i>,
                <i title="chain">ch</i>,
                <i title="furlong">fur</i>,
                <i title="mile">mi</i>,
                <i title="fathom">ftm</i> (или
                <i title="fathom (UK)">ftm</i><sub>_UK</sub>,
                <i title="fathom (US)">ftm</i><sub>_US</sub>),
                <br />&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="cable">cable</i> (или
                <i title="cable (UK)">cable</i><sub>_UK</sub>,
                <i title="cable (US)">cable</i><sub>_US</sub>),
                <i title="nautical mile">nmi</i>,
                <i title="link">li</i>,
                <i title="rod">rod</i>,
                <i title="pole">pole</i>,
                <i title="perch">perch</i>,
                <i title="league">lea</i>;
            </li>
            <li>
                Скорост:
                <i title="miles per hour">mph</i>,
                <i title="knots">knot</i>;
            </li>
            <li>
                Температура:
                <i title="degrees Fahrenheit">°F</i>,
                <i title="difference in °F">Δ°F</i>,
                <i title="degrees Rankine">°R</i>;
            </li>
            <li>
                Площ:
                <i title="rood">rood</i>,
                <i title="acre">ac</i>;
            </li>
            <li>
                Обем, течност:
                <i title="fluid ounce">fl_oz</i>,
                <i title="gill">gi</i>,
                <i title="pint">pt</i>,
                <i title="quart">qt</i>,
                <i title="gallon">gal</i>,
                <i title="barrel">bbl</i>, или:
                <br />&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="fluid ounce (UK)">fl_oz</i><sub>_UK</sub>,
                <i title="gill (UK)">gi</i><sub>_UK</sub>,
                <i title="pint (fluid, UK)">pt</i><sub>_UK</sub>,
                <i title="quart (fluid, UK)">qt</i><sub>_UK</sub>,
                <i title="gallon (fluid, UK)">gal</i><sub>_UK</sub>,
                <i title="barrel (fluid, UK)">bbl</i><sub>_UK</sub>,
                <br />&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;
                <i title="fluid ounce (US)">fl_oz</i><sub>_US</sub>,
                <i title="gill (US)">gi</i><sub>_US</sub>,
                <i title="pint (fluid, US)">pt</i><sub>_US</sub>,
                <i title="quart (fluid, US)">qt</i><sub>_US</sub>,
                <i title="gallon (fluid, US)">gal</i><sub>_US</sub>,
                <i title="barrel (fluid, US)">bbl</i><sub>_US</sub>;
            </li>
            <li>
                Обем, сух:
                (US) <i title="pint (dry, US)">pt</i><sub>_dry</sub>,
                (US) <i title="quart (dry, US)">qt</i><sub>_dry</sub>,
                (US) <i title="gallon (dry, US)">gal</i><sub>_dry</sub>,
                (US) <i title="barrel (dry, US)">bbl</i><sub>_dry</sub>,
                <br />&emsp;&emsp;&emsp;&emsp;&emsp;
                <i title="peck">pk</i> (или
                <i title="peck (UK)">pk</i><sub>_UK</sub>,
                <i title="peck (US)">pk</i><sub>_US</sub>),
                <i title="bushel">bu</i> (или
                <i title="bushel (UK)">bu</i><sub>_UK</sub>,
                <i title="bushel (US)">bu</i><sub>_US</sub>);
            </li>
            <li>
                Сила:
                <i title="ounce-force">ozf</i> (или
                <i title="ounce-force (alt)">oz</i><sub>_f</sub>),
                <i title="pound-force">lbf</i> (или
                <i title="pound-force (alt)">lb</i><sub>_f</sub>),
                <i title="kilopound">kip</i> (или
                <i title="kilopound-force">kipf</i>,
                <i title="kilopound-force (alt)">kip</i><sub>_f</sub>),
                <i title="ton-force">tonf</i> (или
                <i title="ton-force">ton</i><sub>_f</sub>),
                <i title="poundal">pdl</i>;
            </li>
            <li>
                Налягане:
                <i title="ounce-force per sq. inch">osi</i>,
                <i title="ounce-force per sq. foot">osf</i>
                <i title="pound-force per sq. inch">psi</i>,
                <i title="pound-force per sq. foot">psf</i>,
                <i title="kilopound-force per sq. inch">ksi</i>,
                <i title="kilopound-force per sq. foot">ksf</i>,
                <i title="ton-force per sq. inch">tsi</i>,
                <i title="ton-force per sq. foot">tsf</i>,
                <i title="inches of mercury (conventional)">inHg</i>;
            </li>
            <li>
                Енергия/работа:
                <i title="British Thermal Unit">BTU</i>,
                <i title="therm">therm</i>,
                <i title="therm">therm</i><sub>_UK</sub>,
                <i title="therm">therm</i><sub>_US</sub>,
                <i title="quad">quad</i>;
            </li>
            <li>
                Мощност:
                <i title="horsepower">hp</i>,
                <i title="horsepower (electrical)">hpE</i>,
                <i title="horsepower (boiler)">hpS</i>.
            </li>
        </ul>
        <p>Мерните единици за ъгли се използват от тригонометричните функции и са меродавни пред всички останали настройки. Обратните тригонометрични функции по подразбиране връщат бездименсионни стойности. Ако искате да връщат резултата в текущите мерни единици за ъгли, трябва да дефинирате променливата: <var>ReturnAngleUnits</var> = 1.</p>

        <p>Буквени литерали, разположени непосредствено след числа се разпознават автоматично като мерни единици, например "2<i>m</i>". Самостоятелни буквени литерали, като например "<i>N</i>*<i>m</i>", могат да бъдат както мерни единици, така и променливи, в зависимост от случая. Правилата, които се прилагат са следните: Ако литералът не е деклариран като променлива преди това, се разпознава като мерна единица. В противен случай, се разпознава като променлива, дори и когато съществува мерна единица със същото име. Ако сложите точка "." непосредствено преди литерала, той се разпознава като мерна единица, дори и ако съществува променлива със същото име, например: ".<i>N</i>*.<i>m</i>".</p>

        <h4>Потребителски мерни единици</h4>
        <p>В Calcpad можете да дефинирате и собствени мерни единици, след което да ги използвате по-нататък в кода, подобно на останалите. Дефинирането на мерни единици е подобно на това на променливите, с тази разлика, че трябва да сложите точка "." преди името:</p>
        <p>&emsp;&emsp;<code>.<i>Име</i> = израз</code></p>
        <p>Имената могат да съдържат някои символи за валута като: €, £, ₤, ¥, ¢, ₽, ₹, ₩, ₪. Ако искате да създадете производна на други мерни единици, отдясно на равенството може да въведете израз, който съдържа операции с числа и мерни единици. Може да дефинирате и бездименсионни единици, като валута  (USD, EUR, €, ₤) или информация (bit, byte, KiB, и пр.) като за първата въведете "= 1", а за останалите - съответните коефициенти за преобразуване. Например:</p>
        <p>
            <code>
                &emsp;&emsp;.<i>bit</i> = 1<br />
                &emsp;&emsp;.<i>byte</i> = 8*<i>bit</i><br />
                &emsp;&emsp;.<i>KiB</i> = 1024*<i>byte</i><br />
                &emsp;&emsp;...
            </code>
        </p>
        <p>Потребителските бездименсионни мерни единици са разположени в специален (девети) нефизичен дименсионен слой. Така, те не се съкращават или конвертират към останалите бездименсионни единици като проценти и ъгли. Ако имате обаче два или повече вида потребителски мерни единици в един файл, те ще съществуват в един и същ слой. Поради това, когато участват в общи изрази, те ще се съкращават и конвертират помежду си. Ако това поведение не е желано, то тяхното смесване трябва да се избягва.</p>

        <h3 id="TOC_410">Вектори</h3>
        <p><b>Вътрешно представяне и видове</b></p>
        <p>В Calcpad има два вида вектори: стандартни (малки) и големи. Векторите могат да съдържат само реални числа с мерни единици. Комплексни вектори не се поддържат в тази версия. Един вектор може да съдържа различни типове мерни единици, дори и да са несъвместими. Някои векторни функции или оператори обаче могат да върнат грешка за несъвместимост между мерните единици на отделните елементи.</p>
        <p>Векторите с дължина, по-голяма от 100, се създават като "големи". Външно те се държат точно като стандартните вектори, така че за крайния потребител няма разлика. Вътрешно обаче те работят по съвсем различен начин. Структурата на голям вектор е показана на фигурата по-долу:</p>
        <p><img width="500" src="Images/Vector.png"></p>
        <p>Векторът се дефинира с пълната си "математическа" дължина, но първоначално за него не се заделя памет. Тази дължина може да бъде прочетена чрез функцията <b>len</b>(<var><span class="vec">⃗</span>v</var>). Най-големият индекс на ненулев елемент определя вътрешния размер на вектора. Връща се от функцията <b>size</b>(<var><span class="vec">⃗</span>v</var>). Тъй като се знае, че останалите елементи са нула, Calcpad не трябва да ги съхранява в паметта. Вместо това, при опит за достъп до такъв елемент, той връща директно нула.</p>
        <p>Това позволява на софтуера да работи ефективно с вектори, които не са изцяло запълнени. Такива вектори се срещат често в инженерството, като например товарния вектор в анализите по крайните елементи. Calcpad обаче запазва малко повече памет над размера, който се нарича "капацитет". Това е така, защото преоразмеряването на вектор е скъпа операция от изчислителна гледна точка. Тъй като обикновено присвояваме елементи в цикъл, по този начин избягваме преоразмеряването на вектора на всяка итерация.</p>

        <p><b>Дефиниране</b></p>
        <p>Може да дефинирате вектори с помощта на следния синтаксис:</p>
        <p>&emsp;&emsp;<var><span class="vec">⃗</span>a</var> = [<var>a</var><sub>1</sub>; <var>a</var><sub>2</sub>; <var>a</var><sub>3</sub>; … ;<var>a</var><sub>i</sub>; … ;<var>a</var><sub>n</sub>]</p>
        <p>Стойностите на отделните елементи могат да бъдат задавани чрез изрази, съдържащи променливи, оператори, функции и пр. Например:</p>
        <p>&emsp;&emsp;<code><var>a</var> = [cos(0); 2; 3; 2*2; 6 - 1]</code>' = [1&ensp;2&ensp;3&ensp;4&ensp;5].</p>
        <p>Списъкът може да включва също и други вектори. Тeхните елементи ще бъдат вмъкнати в последователността от стойности на съответното място, както следва:</p>
        <p>&emsp;&emsp;<code><var>b</var> = [0; <var>a</var>; 6; 7; 8]</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5&ensp;6&ensp;7&ensp;8].</p>
        <p>Ако включите матрици, те ще бъдат линеализирани до вектори, чрез присъединяване на всички редове, един след друг. Може да дефинирате вектори и като функции, които при извикване да ги създават динамично, в зависимост от определени входни параметри. Например:</p>
        <p>
            &emsp;&emsp;<code><var>a</var>(<var>x</var>) = [1; <var>x</var>; <var>x</var>^2; <var>x</var>^3; <var>x</var>^4]</code><br />
            &emsp;&emsp;<code><var>a</var>(2)</code>' =  [1&ensp;2&ensp;4&ensp;8&ensp;16]
        </p>
        <p>Друг начин да дефинирате вектори, освен чрез квадратни скоби, е като използвате функции за създаване, както следва:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = <b>vector</b>(5)</code>' = [0&ensp;0&ensp;0&ensp;0&ensp;0] - създава празен вектор с 5 елемента;<br />
            &emsp;&emsp;<code><b>fill</b>(<var>a</var>; 5)</code>' = [5&ensp;5&ensp;5&ensp;5&ensp;5] - запълва вектора със стойност 5;<br />
            &emsp;&emsp;<code><var>a</var> = <b>range</b>(0; 10; 2)</code>' = [0&ensp;2&ensp;4&ensp;6&ensp;8&ensp;10] - създава вектор от редица от стойности, започваща от 0 до 10 със стъпка 2.
        </p>
        <p><b>Индексиране</b></p>
        <p>Осъществяването на достъп до отделните елементи на даден вектор за четене и запис става чрез индексиране. Първо трябва да посочите името на вектора, след това точка "." и накрая стойността на индекса. Първият елемент на вектор има индекс едно. Индексът може да бъде зададен като число, единична променлива или израз. В последния случай изразът трябва да бъде ограден със скоби. Например:
        <p>
            &emsp;&emsp;<code><var>a</var> = [2; 4; 6; 8; 10]</code><br />
            &emsp;&emsp;<code><var>a</var>.2</code>' = 4<br />
            &emsp;&emsp;<code><var>k</var> = 3', '<var>a</var>.<var>k</var></code>' = <var><span class="vec">⃗</span>a</var><sub>3</sub> = 6<br />
            &emsp;&emsp;<code><var>a</var>.(2*<var>k</var> - 1)</code>' = <var><span class="vec">⃗</span>a</var><sub>5</sub> = 10
        </p>
        <p>
            Ако стойността на индекса е по-малка от 1 или по-голяма от дължината на вектора <b>len</b>(<var><span class="vec">⃗</span>a</var>), програмата връща грешка: <span class="err">Индексът е извън границите</span>. Можете да използвате индексиране и за да инициализирате вектори в цикли (блокови или едноредови). За тази цел трябва да включите брояча на цикъла в индекса. Например:
        </p>
        <p>
            &emsp;&emsp;<code><var>a</var> = <b>vector</b>(6)','<var>b</var> = <b>vector</b>(6)</code><br />
            &emsp;&emsp;<code>'Блоков цикъл</code><br />
            &emsp;&emsp;<code>#for <var>k</var> = 1 : <b>len</b>(<var>a</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code><var>a</var>.<var>k</var> = <var>k</var>^2</code><br />
            &emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>'Едноредов цикъл</code><br />
            &emsp;&emsp;<code>$Repeat{<var>b</var>.<var>k</var> = <var>a</var>.(<var>k</var> - 1) @ <var>k</var> = 2 : <b>len</b>(<var>b</var>)}</code><br />
        </p>
        <p>Горният код ще създаде следните два вектора:</p>
        <p>
            &emsp;&emsp;<var><span class="vec">⃗</span>a</var> = [1&ensp;4&ensp;9&ensp;16&ensp;25&ensp;36] и<br />
            &emsp;&emsp;<var><span class="vec">⃗</span>b</var> = [0&ensp;1&ensp;4&ensp;9&ensp;16&ensp;25].
        </p>

        <p><b>Структурни функции</b></p>
        <p>Включват всички функции, които четат или променят структурата на вектора. Това означава, че резултатът не зависи от съдържанието, т.е. от стойностите на елементите. Следните функции са налични за ползване в Calcpad:</p>

        <p>&emsp;&emsp;<code><b>len</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) дължината на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Представлява пълната дължина на вектора (по отношение на броя елементи).<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>len</b>([1; 0; 2; 3])</code>' = 4
        </p>

        <p>&emsp;&emsp;<code><b>size</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) вътрешния размер на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако <var><span class="vec">⃗</span>a</var> е голям вектор, връща индекса на последния ненулев елемент, иначе - връща дължината на вектора.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>a</var> = <b>vector</b>(200)<br />
                    <var>a</var>.35 = 1<br /><b>len</b>(<var>a</var>)
                </code>' = 200<br />
                <code><b>size</b>(<var>a</var>)</code>' = 35<br />
                <code><b>size</b>([1; 2; 3; 0; 0])</code>' = 5
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>resize</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>n</var> - (естествено число) новата дължина на вектора <var><span class="vec">⃗</span>a</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;преоразмерения вектор <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Задава нова дължина <var>n</var> на вектора <var><span class="vec">⃗</span>a</var> чрез редактиране на вектора на място и като резултат връща референция към същия вектор.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>a</var> = [1; 2; 3; 4; 5]<br />
                    <var>b</var> = <b>resize</b>(<var>a</var>; <var>3</var>)
                </code>' = [1&ensp;2&ensp;3]<br />
                <code><var>a</var></code>' = [1&ensp;2&ensp;3]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>; <var>c</var>…)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;списък от матрици, вектори и скалари.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;нов вектор, получен чрез присъединяване на аргументите от списъка.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Списъкът може да съдържа неограничен брой аргументи от различен тип, в произволен ред. Матриците първо се линеаризират по редове и техните елементи се включват в общата последователност, заедно с векторите, всеки на своето място.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = [1; 2|3; 4]<br />
                    <var>b</var> = [7; 8; 9]<br />
                    <var>c</var> = <b>join</b>(0; <var>A</var>; 5; 6; <var>b</var>)
                </code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5&ensp;6&ensp;7&ensp;8&ensp;9]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>slice</b>(<var><span class="vec">⃗</span>a</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>i</var><sub>1</sub> - (естествено число) начален индекс;<br />
                <var>i</var><sub>2</sub> - (естествено число) краен индекс.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">нов вектор, съдържащ частта от вектора <var><span class="vec">⃗</span>a</var>, ограничена от индексите <var>i</var><sub>1</sub> и <var>i </var><sub>2</sub>, включително.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Не е задължително <var>i</var><sub>1</sub> &le; <var>i</var><sub>2</sub>. Ако даден индекс е по-голям от дължината на вектора, тогава  се връщат всички останали елементи до края.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>slice</b>([1; 2; 3; 4; 5; 6; 7; 8]; 3; 7)</code>' = [3&ensp;4&ensp;5&ensp;6&ensp;7]<br />
                <code><b>slice</b>([1; 2; 3; 4; 5; 6; 7; 8]; 6; 10)</code>' = [6&ensp;7&ensp;8]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>first</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>
                    <span class="vec">⃗</span>a
                </var> - вектор;<br />
                <var>n</var> - (естествено число) броя на елементите.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ първите <var>n</var> елемента от <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако <var>n</var> е по-голямо от дължината на <var><span class="vec">⃗</span>a</var>, тогава се връщат всички елементи. За разлика от <b>resize</b> оригиналният вектор не се променя.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>first</b>([0; 1; 2; 3; 4; 5]; 3)</code>' = [0&ensp;1&ensp;2]<br />
                <code><b>first</b>([0; 1; 2; 3; 4; 5]; 10)</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>last</b>(<var><span class="vec">⃗</span>a</var>; <var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>n</var> - (естествено число) броя на елементите.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ последните <var>n</var> елемента от <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Ако <var>n</var> е по-голямо от дължината на <var><span class="vec">⃗</span>a</var>, тогава се връщат всички елементи.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>last</b>([0; 1; 2; 3; 4; 5]; 3)</code>' = [3&ensp;4&ensp;5]<br />
                <code><b>last</b>([0; 1; 2; 3; 4; 5]; 10)</code>' = [0&ensp;1&ensp;2&ensp;3&ensp;4&ensp;5]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектора, от който ще се извличат елементите;<br />
                <var><span class="vec">⃗</span>i</var> - вектор с индексите на елементите, които трябва да бъдат извлечени от <var><span class="vec">⃗</span>a</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор с извлечените елементи от <var><span class="vec">⃗</span>a</var>, чиито индекси са дадени в <var><span class="vec">⃗</span>i </var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Всички индекси в <var><span class="vec">⃗</span>i</var> трябва да бъдат естествени числа. Ако индексът е по-голям от дължината на вектора <var><span class="vec">⃗</span>a</var>,  се връща грешка „<span class="err">Индексът е извън границите</span>".</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>a</var> = [0; 1; 2; 3; 4; 5; 6]</code><br />
                <code><b>extract</b>(<var>a</var>; [2; 4; 6])</code>' = [1&ensp;3&ensp;5]
            </span>
        </p>

        <p><b>Функции за данни</b></p>
        <p>Този вид функции третират съдържанието на векторите като числови данни. Те са свързани основно със сортиране, подреждане, търсене и броене. За разлика от структурните функции, резултатът зависи от стойностите на елементите. Можете да използвате следните функции:</p>

        <p>&emsp;&emsp;<code><b>sort</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - входен вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ елементите на <var><span class="vec">⃗</span>a</var>, сортирани във възходящ ред.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Оригиналното съдържание на <var><span class="vec">⃗</span>a</var> не се променя.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>a</var> = [4; 0; 2; 3; -1; 1]<br /><var>b</var> = <b>sort</b>(<var>a</var>)</code>' = [-1&ensp;0&ensp;1&ensp;2&ensp;3&ensp;4]<br />
                <code><var>a</var></code>' = [4&ensp;0&ensp;2&ensp;3&ensp;-1&ensp;1]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>rsort</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - входен вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ елементите на <var><span class="vec">⃗</span>a</var>, сортирани в низходящ ред.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Подобно на <b>sort</b>, оригиналното съдържание на <var><span class="vec">⃗</span>a</var> остава непроменено.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>rsort</b>([4; 0; 2; 3; -1; 1])</code>' = 4&ensp;3&ensp;2&ensp;1&ensp;0&ensp;-1]
        </p>

        <p>&emsp;&emsp;<code><b>order</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - входен вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор с индекси, подредени по възходящия ред на елементите на <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Всеки индекс в изходния вектор <var><span class="vec">⃗</span>i</var> показва кой елемент в <var><span class="vec">⃗</span>a</var> трябва да се постави на текущата позиция, за да се получи сортирана последователност. Можете да направите това, като извикате <b>extract</b>&hairsp;(&hairsp;<var><span class="vec">⃗</span>a</var>; <var><span class="vec ">⃗</span>i</var> ).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>a</var> = [4; 0; 2; 3; -1; 1]<br />
                    <var>i</var> = <b>order</b>(<var>a</var>)
                </code>' = [5&ensp;2&ensp;6&ensp;3&ensp;4&ensp;1]<br />
                <code><var>b</var> = <b>extract</b>(<var>a</var>; <var>i</var>)</code>' = [-1&ensp;0&ensp;1&ensp;2&ensp;3&ensp;4]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>revorder</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - входен вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор с индекси, подредени по низходящия ред на елементите на <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Прилагат се същите съображения като за функцията <b>order</b>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>revorder</b>([4; 0; 2; 3; -1; 1])</code>' = [1&ensp;4&ensp;3&ensp;6&ensp;2&ensp;5]
        </p>

        <p>&emsp;&emsp;<code><b>reverse</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - входен вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ елементите на <var><span class="vec">⃗</span>a</var> в обратен ред.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Оригиналното съдържание на <var><span class="vec">⃗</span>a</var> остава непроменено.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>reverse</b>([1; 2; 3; 4; 5])</code>' = [5&ensp;4&ensp;3&ensp;2&ensp;1]
        </p>

        <p>&emsp;&emsp;<code><b>count</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>x</var> - (скалар) стойността, която трябва да се преброи;<br />
                <var>i</var> - (естествено число) начален индекс.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) броя на елементите в <var><span class="vec">⃗</span>a</var> от <var>i</var>-тия нататък, които са равни на <var>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Ако <var>i</var> е по-голямо от дължината на <var><span class="vec">⃗</span>a</var>, тогава като резултат се връща нула.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>count</b>([0; 1; 2; 1; 4; 1]; 1; 4)</code>' = 2
        </p>

        <p>&emsp;&emsp;<code><b>search</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>x</var> - (скалар) търсената стойност;<br />
                <var>i</var> - (естествено число) начален индекс, от който да започне търсенето.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) индекса на първия елемент в <var><span class="vec">⃗</span>a</var> от <var>i</var>-тия нататък, който е равен на <var>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако <var>i</var> е по-голямо от дължината на <var><span class="vec">⃗</span>a</var> или стойността не е намерена, се връща нула.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang"><code><b>search</b>([0; 1; 2; 1; 4; 1]; 1; 3)</code>' = 4<br /><code><b>search</b>([0; 1; 2; 1; 4; 1]; 1; 7)</code>' = 0</span>
        </p>

        <p>&emsp;&emsp;<code><b>find</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектор;<br />
                <var>x</var> - (скалар) търсената стойност;<br />
                <var>i</var> - (естествено число) начален индекс.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор с индексите на всички елементи в <var><span class="vec">⃗</span>a</var> от <var>i</var>-тия нататък, които са равни на <var>x</var></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако <var>i</var> е по-голямо от дължината на <var><span class="vec">⃗</span>a</var> или стойността не е намерена, връща празен вектор [] (с нулева дължина).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang"><code><b>find</b>([0; 1; 2; 1; 4; 1]; 1; 2)</code>' = [2&ensp;4&ensp;6]<br /><code><b>find</b>([0; 1; 2; 1; 4; 1]; 3; 2)</code>' = []</span>
        </p>

        <p>&emsp;&emsp;<code><b>lookup</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var><span class="vec">⃗</span>a</var> - вектора, в който ще се извършва търсенето;<br />
                <var><span class="vec">⃗</span>b</var> - вектора, от който се връщат стойностите;<br />
                <var>x</var> - (скалар) търсената стойност.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор с онези елементи в <var><span class="vec">⃗</span>b</var>, за който съответните елементи в<br /><var><span class="vec">⃗ </span>a</var> са равни на <var>x</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">ако търсената стойност не бъде намерена, връща празен вектор [] (с нулева дължина)</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang"><code><var>a</var> = [0; 1; 0; 0; 1; 1]<br /><var>b</var> = [1; 2; 3; 4; 5; 6]<br /><b>lookup</b>(<var>a</var>; <var>b</var>; 0)</code>' =  [1&ensp;3&ensp;4]<br /><code><b>lookup</b>(<var>a</var>; <var>b</var>; 2)</code>' = []</span>
        </p>

        <p>Функциите <b>find</b> и <b>lookup</b> имат варианти с наставки. Различните наставки се отнасят до различни оператори за сравнение. Те заместват равенството в оригиналните функции, докато останалото поведение остава непроменено. Възможните наставки са дадени в таблицата по-долу:</p>
        <table class="bordered">
            <tr><th>наставка</th><th>find</th><th>lookup</th><th>оператор за сравнение</th></tr>
            <tr><td><code>_eq</code></td><td><code><b>find_eq</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_eq</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>=</code> - равно</td></tr>
            <tr><td><code>_ne</code></td><td><code><b>find_ne</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_ne</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>≠</code> - различно</td></tr>
            <tr><td><code>_lt</code></td><td><code><b>find_lt</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_lt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&lt;</code> - по-малко</td></tr>
            <tr><td><code>_le</code></td><td><code><b>find_le</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_le</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&le;</code> - по-малко или равно</td></tr>
            <tr><td><code>_gt</code></td><td><code><b>find_gt</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_gt</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&gt;</code> - по-голямо</td></tr>
            <tr><td><code>_ge</code></td><td><code><b>find_ge</b>(<var><span class="vec">⃗</span>a</var>; <var>x</var>; <var>i</var>)</code></td><td><code><b>lookup_ge</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>; <var>x</var>)</code></td><td><code>&ge;</code> - по-голямо или равно</td></tr>
        </table>

        <p><b>Математически функции</b></p>
        <p>Всички стандартни скаларни математически функции приемат също и векторни аргументи. Функцията се прилага поотделно към всеки елемент от входящия вектор и резултатите се връщат в съответния изходен вектор. Например:</p>
        <p>&emsp;&emsp;<code><b>sin</b>([0; 30; 45; 90])</code>' = [0&ensp;0,5&ensp;0,707&ensp;1]</p>
        <p>Calcpad също включва няколко математически функции, които са специфични за вектори:</p>

        <p>&emsp;&emsp;<code><b>norm_p</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>p</sub> нормата на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;L<sub>p</sub> нормата се получава по формулата: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub><var>p</var></sub> = <span class="b1">(</span><span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b><sup><var>p</var></sup><span class="b1">)</span><sup class="raised">1/<var>p</var></sup></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>norm_p</b>([1; 2; 3]; 3)</code>' = 3.3019
        </p>

        <p>&emsp;&emsp;<code><b>norm_1</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>1</sub> нормата на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;L<sub>1</sub> нормата се получава по формулата: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>1</sub> = <span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>norm_1</b>([-1; 2; 3])</code>' = 6
        </p>

        <p>&emsp;&emsp;<code><b>norm</b>(<var><span class="vec">⃗</span>a</var>)</code> or <code><b>norm_2</b>(<var><span class="vec">⃗</span>a</var>)</code> or <code><b>norm_e</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>2</sub> (Евклидовата) норма на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;L<sub>2</sub> нормата се получава по формулата: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>2</sub> = &emsp;<span class="o2"><span class="r2"></span><span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><var>a</var><sub><var>i</var></sub><sup>2</sup></span></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>norm_2</b>([1; 2; 3])</code>' = 3.7417
        </p>

        <p>&emsp;&emsp;<code><b>norm_i</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>∞</sub> (безкрайност) нормата на вектора <var><span class="vec">⃗</span>a</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;L<sub>∞</sub> нормата се получава по формулата: <span class="eq">||<var><span class="vec">⃗</span>a</var>||<sub>∞</sub> = max <b class="b0">|</b>&hairsp;<var>a</var><sub>i</sub>&hairsp;<b class="b0">|</b></span>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>norm_i</b>([1; 2; 3]; 3)</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>unit</b>(<var><span class="vec">⃗</span>a</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var> - вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;нормализираният (единичен) вектор <var><span class="vec">⃗</span>a</var> (с L<sub>2</sub> норма ||<var><span class="vec">⃗</span>a</var>||<sub>2</sub> = 1).<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Елементите на нормализирания вектор <var><span class="vec">⃗</span>u</var> се изчисляват от израза:<br /><var>u</var><sub><var>i</var></sub> = <var>a</var><sub><var>i</var></sub> / ||<var>a</var>||<sub>2</sub></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>unit</b>([1; 2; 3])</code>' = [0.26726&ensp;0.53452&ensp;0.80178]
        </p>

        <p>&emsp;&emsp;<code><b>dot</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var>, <var><span class="vec">⃗</span>b</var> - вектори.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) скаларното произведение на двата вектора <var><span class="vec">⃗</span>a</var>&hairsp;&middot;<var><span class="vec">⃗</span>b</var>;<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Скаларното произведение се получава от израза: <span class="eq"><var><span class="vec">⃗</span>a</var>&hairsp;&middot;<var><span class="vec">⃗</span>b</var> = <span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span> <var>a</var><sub><var>i</var></sub>&hairsp;&middot;<var>b</var><sub><var>i</var></sub></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>a</var> = [1; 2; 4]<br />
                    <var>b</var> = [5; 3; 1]<br />
                    <b>dot</b>(<var>a</var>; <var>b</var>)
                </code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cross</b>(<var><span class="vec">⃗</span>a</var>; <var><span class="vec">⃗</span>b</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>a</var>, <var><span class="vec">⃗</span>b</var> - вектори.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(вектор) векторното произведение <var><span class="vec">⃗</span>c</var> = <var><span class="vec">⃗</span>a</var> &times; <var><span class="vec">⃗</span>b</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Тази функция е дефинирана само за вектори с дължини 2 или 3. Елементите на резултантния вектор <var><span class="vec">⃗</span>c</var> се изчисляват, както следва:<br />
                <var>c</var><sub>1</sub> = <var>a</var><sub>2</sub>&hairsp;<var>b</var><sub>3</sub> &minus;  <var>a</var><sub>3</sub>&hairsp;<var>b</var><sub>2</sub><br />
                <var>c</var><sub>2</sub> = <var>a</var><sub>3</sub>&hairsp;<var>b</var><sub>1</sub> &minus;  <var>a</var><sub>1</sub>&hairsp;<var>b</var><sub>3</sub><br />
                <var>c</var><sub>3</sub> = <var>a</var><sub>1</sub>&hairsp;<var>b</var><sub>2</sub> &minus;  <var>a</var><sub>2</sub>&hairsp;<var>b</var><sub>1</sub><br />
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>a</var> = [1; 2; 4]<br />
                    <var>b</var> = [5; 3; 1]<br />
                    <b>cross</b>(<var>a</var>; <var>b</var>)
                </code>' = [-10&ensp;19&ensp;-7]
            </span>
        </p>

        <p><b>Агрегатни и интерполационни функции</b></p>
        <p>Всички агрегатни функции могат да работят с вектори. Тъй като те са многопараметрични, всяка от тях може да приема както единичен вектор, така и списък от скалари, вектори и матрици, смесени в произволен ред. В този случай, елементите на всички аргументи се обединяват в общ масив от скалари, последователно отляво надясно. Например:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [0; 2; 6]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 3; 1]</code><br />
            &emsp;&emsp;<code><b>sum</b>(10; <var>a</var>; <var>b</var>; 11)</code>' = 38
        </p>
        <p>Интерполационните функции имат подобно поведение, но първият аргумент трябва да е скалар, представляващ интерполационния параметър. Например:</p>
        &emsp;&emsp;<code><b>take</b>(3; <var>a</var>)</code>' = 6<br />
        &emsp;&emsp;<code><b>line</b>(1.5; <var>a</var>)</code>' = 1<br />
        &emsp;&emsp;<code><b>spline</b>(1.5; <var>a</var>)</code>' = 0.8125<br />
        <p>Подобно на агрегатните, интерполационните функции също приемат списъци от смесени аргументи, както следва:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [1; 2; 3]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 6; 7; 8]</code><br />
            &emsp;&emsp;<code><b>take</b>(7; <var>a</var>; 4;  <var>b</var>; 9; 10)</code>' = 7
        </p>
        <p>Върнатата стойност е всъщност третият елемент във вектора <var><span class="vec">⃗</span>b</var>, но има индекс 7 в крайната последователност. Пълен списък на наличните агрегатни и интерполационни функции е даден по-горе в настоящото ръководство (виж „Изрази/Функции“).</p>

        <p><b>Оператори</b></p>
        <p>Всички оператори могат да работят и с векторни операнди. Операциите се изпълняват поелементно и резултатите се връщат в изходен вектор. Това важи и за оператора за умножение. Например:</p>
        <p>&emsp;&emsp;<code>[2; 4; 5]*[2; 3; 4]</code>' = [4&ensp;12&ensp;20]</p>
        <p>Ако дължините на двата вектора са различни, по-късият вектор се допълва с нули до дължината на по-дългия. Скаларните и векторните произведения в Calcpad са реализирани като функции (виж по-горе). Всички двоични оператори се поддържат за векторно-скаларни и скаларно-векторни операнди по аналогичен начин. Например:</p>
        <p>&emsp;&emsp;<code>[2; 4; 5]*2</code>' = [4&ensp;8&ensp;10]</p>

        <h3 id="TOC_411">Матрици</h3>
        <p><b>Вътрешно представяне и видове</b></p>
        <p>Calcpad включва различни видове матрици: общи (правоъгълни) и специални (матрици-стълбове, симетрични, диагонални, горни и  долни триъгълни). Вътрешно всеки тип е реализиран по различен начин, като се възползва от специфичната структура за по-добра ефективност. Външно всички те имат аналогично поведение, с изключение на отделни случаи.</p>
        <p>Всеки тип матрица е реализиран като масив от вектори, както е показано на фигурата по-долу. Векторите обикновено представляват редове на матриците, с изключение на диагоналните и стълбовите матрици.</p>
        <p><img width="800" src="Images/Matrices.png"></p>
        <p>Calcpad използва големи вектори, за да съхранява стойностите на матриците. Така че не се налага да заделя памет за допълнителните нулеви елементи в частично запълнени (лентови) матрици. Операторът за индексиране за всеки тип е вътрешно предефиниран, така че да върне директно нула, когато се опитаме да прочетем стойност извън структурата на матрицата или ширината на лентата.</p>
        <table>
            <tr><td>a) диагонална матрица -  	 </td><td>M[i, j] = d[i], if i = j и 0, if i ≠ j;</td></tr>
            <tr><td>b) матрица-стълб - 			 </td><td>M[i, j] = c[i], if j = 1, иначе – грешка;</td></tr>
            <tr><td>c) горна триъгълна матрица - </td><td>M[i, j] = r<sub>i</sub>[j – i + 1], if j ≥ i, иначе – 0;</td></tr>
            <tr><td>d) долна триъгълна матрица - </td><td>M[i, j] = r<sub>i</sub>[j], if j ≤ i, иначе – 0;</td></tr>
            <tr><td>e) матрица-ред - 			 </td><td>M[i, j] = r[j], if i = 1, иначе – грешка;</td></tr>
            <tr><td>f) симетрична матрица -		 </td><td>M[i, j] = r<sub>i</sub>[j – i + 1], if i ≥ j, иначе = r<sub>i</sub> [i – j + 1];</td></tr>
            <tr><td>g) правоъгълна матрица -  	 </td><td>M[i, j] = r<sub>i</sub>[j];</td></tr>
        </table>
        <p>Ако се опитаме да запишем ненулева стойност извън структурата на матрицата, ще получим грешка „Индексът е извън границите“. Например, не можете да присвоите ненулева стойност на елемент извън главния диагонал на диагонален тип матрица.</p>

        <p><b>Дефиниране</b></p>
        <p>Подобно на векторите, можете да дефинирате матрици, като използвате синтаксиса с "квадратни скоби". Отделните редове трябва да са разделени с вертикална черта " | ", както следва:</p>
        <p><var>A</var><sub>m⨯n</sub> = [<var>a</var><sub>1,1</sub>; <var>a</var><sub>1,2</sub>; … ; <var>a</var><sub>1,n</sub> | <var>a</var><sub>2,1</sub>; <var>a</var><sub>2,2</sub>; … ; <var>a</var><sub>2,n</sub> | … | <var>a</var><sub>m,1</sub>; <var>a</var><sub>m,2</sub>; … ; <var>a</var><sub>m,n</sub>]</p>
        <p>По този начин можете да създавате само общи (правоъгълни) типове матрици. За специалните типове трябва да използвате съответните функции за създаване, както е описано по-нататък в настоящото ръководство. Ако имате редове с различни дължини, за брой на стълбовете <var>n</var> се приема за максималният брой елементи в един ред. Липсващите елементи в другите редове се допълват с нули. Например:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1|2; 3|4; 5; 6|7; 8]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>
        <p>За дефинирането на матричните елементи може да използвате изрази, които да съдържат променливи, оператори, функции, вектори, други матрици и пр. Например, следният код ще създаде матрица от три реда, като за всеки ред приложи различен израз върху единичен вектор:</p>
        <p>
            &emsp;&emsp;<code><var>a</var> = [1; 2; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = [<var>a</var>|2*<var>a</var> + 1|3*<var>a</var> + 2]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">9</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">8</span><span class="td">14</span><span class="td"></span></span>
            </span>
        </p>
        <p>Също както при векторите, матриците могат да се дефинират чрез функции, които да ги създават динамично при поискване. Следващата функция ще генерира 4×4 матрица на Вандермонд от вектор, съдържащ елементите за първия стълб:</p><p>
            &emsp;&emsp;<code><var>A</var>(<var>x</var>) = <b>transp</b>([<var>x</var>^0|<var>x</var>|<var>x</var>^2|<var>x</var>^3|<var>x</var>^4])</code><br />
            &emsp;&emsp;<code><var>x</var> = [1; 2; 3; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = <var>A</var>(<var>x</var>)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td">8</span><span class="td">16</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">9</span><span class="td">27</span><span class="td">81</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">16</span><span class="td">64</span><span class="td">256</span><span class="td"></span></span>
            </span>
        </p>
        <p><b>Индексиране</b></p>
        <p>Достъпът до отделните елементи на матрицата за четене и запис на стойности се извършва чрез индексиране. Подобно на векторите, това става чрез точковия оператор ".", но тук трябва да посочите два индекса, както следва:</p>
        <p>
            &emsp;&emsp;<code><var>A</var>.(<var>i</var>; <var>j</var>)</code>, където:<br />
            &emsp;&emsp;&emsp;&emsp;<code><var>i</var></code> - индексът на реда, на който е разположен елемента,<br />
            &emsp;&emsp;&emsp;&emsp;<code><var>j</var></code> - индексът на стълба.
        </p>
        <p>Индексите трябва да бъдат заградени със скоби и разделени с точка и запетая. Номерирането на редовете и стълбовете започва от единица. За матрицата на Вандермонд от горния пример:</p>
        <p>&emsp;&emsp;<code><var>A</var>.(3; 2)</code>' = 3.</p>
        <p>Можете да използвате изрази в скобите, с които да изчислите индексите на място:<p>
        <p>
            &emsp;&emsp;<code><var>i</var> = 2', '<var>j</var> = 3</code><br />
            &emsp;&emsp;<code><var>A</var>.(2*<var>i</var> - 1; <var>j</var> + 1)</code>' <var>A</var><sub>3, 4</sub> = 27.
        </p>
        <p>По този начин можете да итерирате върху матричните елементи в цикъл като включите броячите на цикъла в съответните индекси. За целта може да използвате както вградени, така и блокови цикли. Кодът по-долу създава матрица на Вандермонд от вектор <var><span class="vec">⃗</span>x</var> с посочения брой стълбове (6):</p>
        <p>
            &emsp;&emsp;<code><var>x</var> = [1; 2; 3; 4]</code><br />
            &emsp;&emsp;<code><var>A</var> = <b>matrix</b>(len(<var>x</var>); 7)</code><br />
            &emsp;&emsp;<code>#hide</code><br />
            &emsp;&emsp;<code>#for <var>i</var> = 1 : <b>n_rows</b>(<var>A</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code>#for <var>j</var> = 1 : <b>n_cols</b>(<var>A</var>)</code><br />
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code><var>A</var>.(<var>i</var>; <var>j</var>) = <var>x</var>.<var>i</var>^(<var>j</var> - 1)</code><br />
            &emsp;&emsp;&emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>#loop</code><br />
            &emsp;&emsp;<code>#show</code><br />
            &emsp;&emsp;<code><var>A</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">4</span><span class="td">8</span><span class="td">16</span><span class="td">32</span><span class="td">64</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">9</span><span class="td">27</span><span class="td">81</span><span class="td">243</span><span class="td">729</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">16</span><span class="td">64</span><span class="td">256</span><span class="td">1024</span><span class="td">4096</span><span class="td"></span></span>
            </span>
        </p>
        <p>Едноредовият еквивалент на горния цикъл е следният:</p>
        <p>&emsp;&emsp;<code>$Repeat{$Repeat{<var>A</var>.(<var>i</var>; <var>j</var>) = <var>x</var>.<var>i</var>^(<var>j</var> - 1) @ <var>j</var> = 1 : <b>n_cols</b>(<var>A</var>)} @ <var>i</var> = 1 : <b>n_rows</b>(<var>A</var>)}</code></p>

        <p><b>Функции за създаване и инициализация</b></p>
        <p>Синтаксисът с "квадратни скоби" е много мощен и гъвкав за създаване на малки матрици с фиксирани размери. Той обаче има и доста ограничения. Например, с него не може да се създават специални типове матрици, както и не може да се указват размерите на матрицата. Ето защо Calcpad включва и различни функции за създаване на матрици, както следва:</p>

        <p>&emsp;&emsp;<code><b>matrix</b>(<var>m</var>; <var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>m</var> - (естествено число) брой редове;<br />
                <var>n</var> - (естествено число) брой стълбове.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;празна правоъгълна матрица с размери m⨯n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang"><var>m</var> и <var>n</var> трябва да са между 1 и 1 000 000. Това важи и за всички други видове матрици по-долу.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>matrix</b>(3; 4)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>identity</b>(<var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>n</var> - брой редове/стълбове.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;единична матрица с размери n⨯n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Представлява диагонална матрица, запълнена с единици по главния диагонал.<br />Тази функция е еквивалентна на <b>diagonal</b>&hairsp;(&hairsp;<var>n</var>&hairsp;; 1).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>identity</b>(3)</code>' =<span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>diagonal</b>(<var>n</var>; <var>d</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>n</var> - брой редове/стълбове;<br />
                <var>d</var> - стойност по главния диагонал.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;n⨯n диагонална матрица, запълнена със стойност <var>d</var> по главния диагонал.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Вътрешно е различна и е по-ефективна от n⨯n симетрична матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>diagonal</b>(3; 2)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">2</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>column</b>(<var>m</var>; <var>c</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>m</var> - брой редове;<br />
                <var>c</var> - стойността, с която да бъде запълнена матрицата.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;m⨯1 матрица-стълб, запълнена със стойност <var>c</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Вътрешно е различна и е по-ефективна от mx1 правоъгълна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>column</b>(3; 2)</code>' =<span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>utriang</b>(<var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>n</var> - брой редове/стълбове.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;празна горна триъгълна матрица с размери n⨯n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Тя е вътрешно различна и по-ефективна от обща n⨯n матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>U</var> = <b>utriang</b>(3)</code><br />
                <code><b>mfill</b>(<var>U</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>ltriang</b>(<var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>n</var> - брой редове/стълбове.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;празна долна триъгълна матрица с размери n⨯n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Тя е вътрешно различна и по-ефективна от обща n⨯n матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>L</var> = <b>ltriang</b>(3)</code><br />
                <code><b>mfill</b>(<var>L</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>symmetric</b>(<var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>n</var> - брой редове/стълбове.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;празна n⨯n симетрична матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Тя е вътрешно различна и по-ефективна от обща n⨯n матрица. В паметта се съjoin_cols
                хранява само запълнената част от горната дясна страна, образувайки профилна структура. Ако промените стойност от която и да е страна на главния диагонал, се променя и съответната стойност от другата страна, така че симетрията на матрицата се запазва.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = <b>symmetric</b>(4)</code><br />
                <code><var>A</var>.(1; 1) = 5', '<var>A</var>.(1; 2) = 4</code><br />
                <code><var>A</var>.(2; 2) = 3', '<var>A</var>.(2; 3) = 2</code><br />
                <code><var>A</var>.(4; 2) = 1', '<var>A</var>.(4; 4) = 1</code><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">3</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vec2diag</b>(<var><span class="vec">⃗</span>v</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>v</var> - вектор, съдържащ диагоналните елементи.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;диагонална матрица от елементите на вектора <var><span class="vec">⃗</span>v</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Размерът на матрицата е равен на броя елементи на <var><span class="vec">⃗</span>v</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>vec2diag</b>([1; 2; 3]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vec2col</b>(<var><span class="vec">⃗</span>v</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>v</var> - вектор, съдържащ елементите на матрицата-стълб.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрица-стълб от елементите на вектора <var><span class="vec">⃗</span>v</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Броят на редовете на матрицата е равен на размера на <var><span class="vec">⃗</span>v</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>vec2col</b>([1; 2; 3]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td"></span></span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join_cols</b>(<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub> …)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>c</var><sub>1</sub>; <var><span class="vec">⃗</span>c</var><sub>2</sub>; <var><span class="vec">⃗</span>c</var><sub>3</sub> … - вектори.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">нова правоъгълна матрица, получена чрез присъединяване на векторите в стълбове.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Можете да зададете произволен брой входни вектори с различни дължини. Броят на редовете е равен на дължината на най-големия вектор. Останалите стълбове се допълват с нули. Векторите се съединяват последователно отляво-надясно.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>join_cols</b>([1]; [4; 5; 6]; [7; 8]; [10; 11; 12]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">7</span><span class="td">10</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">8</span><span class="td">11</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">6</span><span class="td">0</span><span class="td">12</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>join_rows</b>(<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub> …)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var><span class="vec">⃗</span>r</var><sub>1</sub>; <var><span class="vec">⃗</span>r</var><sub>2</sub>; <var><span class="vec">⃗</span>r</var><sub>3</sub> … - вектори.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;нова правоъгълна матрица, чиито редове са дадените вектори.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Може да имате произволен брой входни вектори с различни дължини. Броят на стълбовете е равен на максималната дължина на вектор. Останалите редове се допълват с нули. Аргументите се прочитат отляво надясно и се подреждат в редове отгоре надолу.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>join_rows</b>([1; 2; 3; 4]; [6; 7; 8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>augment</b>(<var>A</var>; <var>B</var>; <var>C</var>…)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>A</var>, <var>B</var>, <var>C</var> … - матрици.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">правоъгълна матрица, получена чрез присъединяване на входните матрици една до друга хоризонтално.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Може да зададете произволен брой входни матрици с различен брой редове. Меродавен е най-големият брой, а по-малките матрици се допълват с нули. Матриците се съединяват последователно отляво надясно. Ако аргументите съдържат вектори, те се третират като стълбове.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code><br />
                <code><var>B</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code><br />
                <code><var>c</var> = [10; 11; 12; 13]</code><br />
                <code><var>D</var> = <b>augment</b>(<var>A</var>; <var>B</var>; <var>c</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">10</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">11</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">12</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">13</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>stack</b>(<var>A</var>; <var>B</var>; <var>C</var>…)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>A</var>, <var>B</var>, <var>C</var> … - матрици.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">правоъгълна матрица, получена чрез подреждане на входните матрици една под друга.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Можете да зададете произволен брой входни матрици с различен брой стълбове. Най-големият брой е меродавен, а по-малките матрици се допълват с нули. Матриците се съединяват последователно отгоре надолу. Ако аргументите съдържат вектори, те се третират като стълбове.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code><br />
                <code><var>B</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code><br />
                <code><var>c</var> = [10; 11]</code><br />
                <code><var>D</var> = <b>stack</b>(<var>A</var>; <var>B</var>; <var>c</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p><b>Структурни функции</b></p>
        <p>Структурните функции се отнасят само до матричната структура. За разлика от функциите за данни и математика, резултатът най-често не зависи от стойностите на елементите.</p>

        <p>&emsp;&emsp;<code><b>n_rows</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;броя на редовете в матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>n_rows</b>([1; 2|3; 4|5; 6])</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>n_cols</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;броя на стълбовете в матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<code><b>n_cols</b>([1|2; 3|4; 5; 6])</code>' = 3
        </p>

        <p>&emsp;&emsp;<code><b>mresize</b>(<var>M</var>; <var>m</var>; <var>n</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, която трябва да бъде преоразмерена;<br />
                <var>m</var> - новия брой на редовете;<br />
                <var>n</var> - новия брой на стълбовете.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрицата <var>M</var>, преоразмерена до <var>m</var> реда и <var>n</var> стълба.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако новите размери са по-големи, добавените елементи се инициализират с нули. Ако са по-малки, матрицата се подрязва. Ако новите размери са съвместими с типа на матрицата, тогава оригиналната матрица се преоразмерява на място и се връща референция към нея. В противен случай се връща нов правоъгълен тип матрица с посочените размери и оригиналната матрица остава непроменена.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span> - общ тип.<br />
                <code><var>B</var> = <b>mresize</b>(<var>A</var>; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                </span> - също от общ тип.<br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                </span> - оригиналната матрица е променена.<br />
                <code><var>A</var> = <b>diagonal</b>(3; 5)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">5</span><span class="td"></span></span>
                </span> - диагонален тип.<br />
                <code><var>B</var> = <b>mresize</b>(<var>A</var>; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span> - общ тип.<br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">5</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">5</span><span class="td"></span></span>
                </span> - оригиналната матрица остава непроменена.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mfill</b>(<var>M</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, която да бъде запълнена;<br />
                <var>x</var> - стойността, с която да се запълни матрицата.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрицата <var>M</var>, запълнена със стойност <var>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Матрицата <var>M</var> се редактира на място и се връща референция към нея. Тази функция е структурно съвместима. Специалните матрици се запълват само в предопределената област, като се запазва типа.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = <b>matrix</b>(2; 3)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>mfill</b>(<var>A</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>L</var> = <b>mfill</b>(<b>ltriang</b>(4); 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td">2</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fill_row</b>(<var>M</var>; <var>i</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, чийто ред трябва да бъде запълнен;<br />
                <var>i</var> - индексът на реда, който да се запълни;<br />
                <var>x</var> - стойността, с която да се запълни реда.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрицата <var>M</var>, чийто ред <var>i</var> е запълнен със стойност <var>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Матрицата <var>M</var> се редактира на място и се връща референция към нея. Тази функция е структурно съвместима. Специалните матрици се запълват само вътре в предопределената област, като се запазва типа.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = <b>matrix</b>(3; 4)</code>' - общ тип матрица<br />
                <code><b>fill_row</b>(<var>A</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>L</var> = <b>utriang</b>(4)</code>' - горна триъгълна матрица<br />
                <code>$Repeat{<b>fill_row</b>(<var>L</var>; k; k) @ k = 1 : <b>n_rows</b>(<var>L</var>)}</code><br />
                <code><var>L</var></code>' = <span class="eq matrix">
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl1">2</span><span class="td hl1">2</span><span class="td hl1">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td hl2">3</span><span class="td hl2">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td hl2">4</span><span class="td"></span></span>
                </span> - долният триъгълник остава непроменен.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fill_col</b>(<var>M</var>; <var>j</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, чийто стълб трябва да бъде запълнен;<br />
                <var>j</var> - индексът на стълба, който да се запълни;<br />
                <var>x</var> - стойността, с която да се запълни стълба.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрицата <var>M</var>, след като <var>j</var>-тия стълб е запълнен със стойност <var>x</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Матрицата <var>M</var> се редактира на място и се връща референция към нея. Тази функция е структурно съвместима. Специалните матрици се запълват само в предопределената област, като се запазва типа.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = <b>matrix</b>(3; 4)</code><br />
                <code><b>fill_col</b>(<var>A</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>symmetric</b>(4)</code>' - симетрична матрица.<br />
                <code><b>fill_col</b>(<var>B</var>; 2; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td hl">1</span><span class="td hl">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td hl">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                </span> - симетрията се запазва.
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>copy</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - изходна матрица;<br />
                <var>B</var> - отправна матрица, в която ще бъдат копирани елементите;<br />
                <var>i</var> - начален индекс на реда в матрицата <var>B</var>;<br />
                <var>j</var> - начален индекс на стълба в матрицата <var>B</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">матрицата <var>B</var>, след като елементите от <var>A</var> са копирани в нея, започвайки от индекси <var>i</var> и <var>j</var> в <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Копирането на елементите от <var>A</var> в <var>B</var> променя матрицата <var>B</var> на място. Съществуващите елементи на <var>B</var> се заменят със съответните нови елементи от <var>A</var>. Като резултат се връща референция към <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6]</code><br />
                <code><var>B</var> = <b>mfill</b>(<b>matrix</b>(3; 4); -1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>copy</b>(<var>A</var>; <var>B</var>; 1; 1)</code><br />
                <code><b>copy</b>(<var>A</var>; <var>B</var>; 2; 2)</code><br />
                <code><var>B</var></code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">1</span><span class="td hl">2</span><span class="td hl">3</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td hl">4</span><span class="td hl2">1</span><span class="td hl2">2</span><span class="td hl1">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td hl1">4</span><span class="td hl1">5</span><span class="td hl1">6</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>add</b>(<var>A</var>; <var>B</var>; <var>i</var>; <var>j</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - изходна матрица;<br />
                <var>B</var> - отправна матрица, към която ще бъдат добавени елементите;<br />
                <var>i</var> - начален индекс на реда в матрицата <var>B</var>;<br />
                <var>j</var> - начален индекс на стълба в матрицата <var>B</var>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">матрицата <var>B</var>, след добавянето на елементите от <var>A</var>, към съответните елементи на <var>B</var>, започвайки от индекси <var>i</var> и <var>j</var> в <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Добавянето на елементите от <var>A</var> към тези на <var>B</var> променя матрицата <var>B</var> на място. Като резултат се връща референция към <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6]</code><br />
                <code><var>B</var> = <b>mfill</b>(<b>matrix</b>(3; 4); -1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>add</b>(<var>A</var>; <var>B</var>; 1; 1)</code><br />
                <code><b>add</b>(<var>A</var>; <var>B</var>; 2; 2)</code><br />
                <code><var>B</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">0</span><span class="td hl">1</span><span class="td hl">2</span><span class="td">-1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td hl">3</span><span class="td hl2">5</span><span class="td hl2">7</span><span class="td hl1">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1</span><span class="td hl1">3</span><span class="td hl1">4</span><span class="td hl1">5</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>row</b>(<var>M</var>; <var>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>i</var> - индекса на реда, който да бъде извлечен.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<var>i</var>-тия ред на матрицата <var>M</var> като вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Редът се връща с пълната му дължина, дори и при специални матрици.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>row</b>(<var>A</var>; 3)</code>' = [7&ensp;8&ensp;9]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>col</b>(<var>M</var>; <var>j</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>j</var> - индекса на стълба, който да бъде извлечен.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<var>j</var>-тия стълб на матрицата <var>M</var> като вектор.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Стълбът се връща с пълната му височина, дори и при специални матрици.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td hl">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>col</b>(<var>A</var>; 2)</code>' = [2&ensp;5&ensp;8]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract_rows</b>(<var>M</var>; <var><span class="vec">⃗</span>i</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var><span class="vec">⃗</span>i</var> - вектор, съдържащ индексите на редовете, които да бъдат извлечени.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">нова матрица, съдържаща редовете на <var>M</var>, чиито индекси са дадени във вектора <var><span class="vec">⃗</span>i</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Редовете се извличат в реда, посочен във вектора <var><span class="vec">⃗</span>i</var>. Той може да е резултат от функцията <b>order_rows</b>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>extract_rows</b>(<var>A</var>; [1; 2; 1])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>extract_cols</b>(<var>M</var>; <var><span class="vec">⃗</span>j</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var><span class="vec">⃗</span>j</var> - вектор, съдържащ индексите на стълбовете, които да бъдат извлечени.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">нова матрица, съдържаща стълбовете на <var>M</var>, чиито индекси са дадени във вектора <var><span class="vec">⃗</span>j</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Стълбовете се извличат в реда, посочен във вектора <var><span class="vec">⃗</span>j</var>. Той може да е резултат от функцията <b>order_cols</b>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>extract_cols</b>(<var>A</var>; [3; 2; 1])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>diag2vec</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ диагоналните елементи на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Не се изисква матрицата <var>M</var> да е квадратна.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6; 7|8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td hl">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td hl">4</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td hl">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><b>diag2vec</b>(<var>A</var>)</code>' = [1&ensp;4&ensp;7]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>submatrix</b>(<var>M</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>i</var><sub>1</sub> - индекс на началния ред;<br />
                <var>i</var><sub>2</sub> - индекс на крайния ред;<br />
                <var>j</var><sub>1</sub> - индекс на началния стълб;<br />
                <var>j</var><sub>2</sub> - индекс на крайния стълб.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">нова матрица, съдържаща подматрицата на <var>M</var>, ограничена от редове от <var>i</var><sub>1</sub> до <var>i</var><sub>2</sub> и стълбове от <var>j</var><sub>1</sub> до <var>j</var><sub>2</sub>, включително.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Началните индекси могат да бъдат по-големи от крайните индекси. Връща се обаче същата част от матрицата. Резултатът винаги е общ (правоъгълен) тип матрица, дори ако изходната матрица е специална.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [ 1; &nbsp;2; &nbsp;3; &nbsp;4| _</code><br />
                &emsp;&emsp;&ensp; <code>&nbsp;5; &nbsp;6; &nbsp;7; &nbsp;8| _</code><br />
                &emsp;&emsp;&ensp; <code>&nbsp;9; 10; 11; 12| _</code><br />
                &emsp;&emsp;&ensp; <code>13; 14; 15; 16]</code><br />
                <code><b>submatrix</b>(<var>A</var>; 2; 3; 2; 4)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">11</span><span class="td">12</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p><b>Функции за данни</b></p>
        <p>Функциите за данни нямат отношение към структурата на матриците, а към стойностите на елементите в нея. Следните функции са налични за използване в Calcpad:</p>
        <p>
            &emsp;&emsp;<code><b>sort_cols</b>(<var>M</var>; <var>i</var>)</code><br />
            &emsp;&emsp;<code><b>rsort_cols</b>(<var>M</var>; <var>i</var>)</code>
        </p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, която да бъде сортирана;<br />
                <var>i</var> - индексът на реда, на който ще се базира сортирането.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;нова матрица, съдържаща стълбовете на <var>M</var>, сортирани по стойностите в ред <var>i</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang"><b>sort_cols</b> сортира във възходящ ред, а <b>rsort_cols</b> - в низходящ. Оригиналната матрица не се променя.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>sort_cols</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td">8</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>rsort_cols</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">9</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span> - оригиналната матрица е непроменена.
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>sort_rows</b>(<var>M</var>; <var>j</var>)</code><br />
            &emsp;&emsp;<code><b>rsort_rows</b>(<var>M</var>; <var>j</var>)</code>
        </p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, която да бъде сортирана;<br />
                <var>i</var> - индексът на стълба, на който ще се базира сортирането.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;Нова матрица, съдържаща редовете на <var>M</var>, сортирани по стойностите в стълб <var>j</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang"><b>sort_rows</b> сортира във възходящ ред, а <b>rsort_rows</b> - в низходящ. Оригиналната матрица не се променя.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>sort_rows</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>rsort_rows</b>(<var>A</var>; 2)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span> - оригиналната матрица е непроменена.
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>order_cols</b>(<var>M</var>; <var>i</var>)</code><br />
            &emsp;&emsp;<code><b>revorder_cols</b>(<var>M</var>; <var>i</var>)</code>
        </p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, чието подреждане да бъде получено;<br />
                <var>i</var> - индексът на реда, на който ще се базира подреждането.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор, съдържащ индексите на стълбовете на матрицата <var>M</var>, подредени по стойностите в ред <var>i</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang"><b>order_cols</b> връща индексите във възходящ ред, а <b>revorder_cols</b> - в низходящ. Самата матрица не се променя. Всеки индекс в получения вектор <var><span class="vec">⃗</span>j</var> показва кой стълб на <var>M</var> трябва да се постави на текущата позиция, за да се получи сортирана последователност на стойностите в ред <var>i</var>. Можете да конструирате сортираната матрица, като извикате функцията <b>extract_cols</b>&hairsp;(<var>M</var>&hairsp;; <var><span class="vec">⃗</span>j</var>&hairsp;).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>order_cols</b>(<var>A</var>; 2)</code>' = [3&ensp;1&ensp;2]<br />
                <code><var>B</var> = <b>extract_cols</b>(<var>A</var>; <var>b</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">5</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">9</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td">8</span><span class="td"></span></span>
                </span><br />
                <code><var>c</var> = <b>revorder_cols</b>(<var>A</var>; 2)</code>' = [2&ensp;1&ensp;3]<br />
                <code><var>C</var> = <b>extract_cols</b>(<var>A</var>; <var>c</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr hl"><span class="td"></span><span class="td">9</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>
            &emsp;&emsp;<code><b>order_rows</b>(<var>M</var>; <var>j</var>)</code><br />
            &emsp;&emsp;<code><b>revorder_rows</b>(<var>M</var>; <var>j</var>)</code>
        </p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, чието подреждане искаме да получим;<br />
                <var>i</var> - индексът на стълба, на който ще се базира подреждането.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор, съдържащ индексите на редовете на матрицата <var>M</var>, подредени по стойностите в стълб <var>j</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang"><b>order_rows</b> връща индексите във възходящ ред, а <b>revorder_rows</b> - в низходящ. Самата матрица не се променя. Всеки индекс в получения вектор <var><span class="vec">⃗</span>i</var> показва кой ред на <var>M</var> трябва да бъде поставен на текущата позиция, за да се получи сортирана последователност в стълб <var>j</var>. Можете да конструирате сортираната матрица, като извикате функцията <b>extract_rows</b>&hairsp;(<var>M</var>&hairsp;; <var><span class="vec">⃗</span>i</var>&hairsp;).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [5; 2; 3|4; 9; 1|6; 8; 7]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">8</span><span class="td">7</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>order_rows</b>(<var>A</var>; 2)</code>' = [1&ensp;3&ensp;2]<br />
                <code><var>B</var> = <b>extract_rows</b>(<var>A</var>; <var>b</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>c</var> = <b>revorder_rows</b>(<var>A</var>; 2)</code>' = [2&ensp;3&ensp;1]<br />
                <code><var>B</var> = <b>extract_rows</b>(<var>A</var>; <var>c</var>)</code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td hl">9</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td hl">8</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td hl">2</span><span class="td">3</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mcount</b>(<var>M</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>x</var> - стойността, чиито срещания да бъдат преброени.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;броя на срещанията на стойността <var>x</var> в матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 0; 1|2; 1; 2|1; 3; 1]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">3</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>n</var> = <b>mcount</b>(<var>A</var>; 1)</code>' = 5
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>msearch</b>(<var>M</var>; <var>x</var>; <var>i</var>; <var>j</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>x</var> - търсената стойност;<br />
                <var>i</var> - индекс на началния ред;<br />
                <var>j</var> - индекс на началния стълб.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор, съдържащ индексите на реда и стълба на първото срещане на <var>x</var> в матрицата <var>M</var> започвайки от индекси <var>i</var> и <var>j</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Търсенето се извършва по редове, последователно отляво надясно. Ако не бъде намерено нищо, като резултат се връща [0&ensp;0].</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|1; 5; 6|1; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>msearch</b>(<var>A</var>; 1; 1; 1)</code>' = [1&ensp;1]<br />
                <code><var>c</var> = <b>msearch</b>(<var>A</var>; 1; 2; 2)</code>' = [3&ensp;1]<br />
                <code><var>d</var> = <b>msearch</b>(<var>A</var>; 4; 1; 1)</code>' = [0&ensp;0]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mfind</b>(<var>M</var>; <var>x</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрица;<br />
                <var>x</var> - търсената стойност.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">двуредова матрица, съдържаща индексите на всички елементи в матрицата <var>M</var>, които са равни на <var>x</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Горният ред в резултата съдържа индексите на редовете, а долният - индексите на съответните стълбове на елементите в <var>M</var>, които са равни на <var>x</var>. Ако не бъде намерено нищо, се връща матрица 2×1 с нули.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 1; 6|1; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">1</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>mfind</b>(<var>A</var>; 1)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>mfind</b>(<var>A</var>; 5)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>hlookup</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, в която да се извършва справката;<br />
                <var>x</var> - стойността, която да се търси;<br />
                <var>i</var><sub>1</sub> - индексът на реда, където ще става търсенето;<br />
                <var>i</var><sub>2</sub> - индексът на реда, от който да се върнат съответните стойности.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор, съдържащ стойностите от ред <var>i</var><sub>2</sub> на матрицата <var>M</var>, за които съответните елементи в ред <var>i</var><sub>1</sub> са равни на <var>x</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Стойностите се сканират последователно отляво надясно. Ако не бъде намерено нищо, се връща празен вектор [].</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [0; 1; 0; 1|1; 2; 3; 4; 5|6; 7; 8; 9; 10]</code> ' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td">4</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>hlookup</b>(<var>A</var>; 0; 1; 3)</code>' = [6&ensp;8&ensp;10]<br />
                <code><var>c</var> = <b>hlookup</b>(<var>A</var>; 2; 1; 3)</code>' = []
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>vlookup</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>M</var> - матрицата, в която да се извършва справката;<br />
                <var>x</var> - стойността, която да се търси;<br />
                <var>i</var><sub>1</sub> - индексът на стълба, където ще става търсенето;<br />
                <var>i</var><sub>2</sub> - индексът на стълба, от който да се върнат съответните стойности.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектор, съдържащ стойностите от стълб <var>j</var><sub>2</sub> на матрицата <var>M</var>, за която съответните елементи в стълб <var>j</var><sub>1</sub> са равни на <var>x</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Стойностите се сканират последователно отгоре надолу. Ако не бъде намерено нищо, се връща празен вектор [].</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4; 1|5; 6|7; 8; 1|9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">10</span><span class="td">0</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = <b>vlookup</b>(<var>A</var>; 0; 3; 1)</code>' = [1&ensp;5&ensp;9]<br />
                <code><var>c</var> = <b>vlookup</b>(<var>A</var>; 1; 3; 2)</code>' = [4&ensp;8]<br />
                <code><var>d</var> = <b>vlookup</b>(<var>A</var>; 2; 3; 1)</code>' = []
            </span>
        </p>

        <p>Функциите <b>find</b>, <b>hlookup</b> и <b>vlookup</b> имат и варианти с наставки. Различните наставки се отнасят до различни оператори за сравнение. Те заместват равенството в оригиналните функции, докато останалата част от поведението остава непроменена. Възможните наставки са дадени в таблицата по-долу:</p>
        <table class="bordered small">
            <tr><th>наставка</th><th>mfind</th><th>hlookup</th><th>vlookup</th><th>оператор за сравнение</th></tr>
            <tr>
                <td><code>_eq</code></td>
                <td><code><b>mfind_eq</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_eq</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_eq</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>=</code> - равно</td>
            </tr>
            <tr>
                <td><code>_ne</code></td>
                <td><code><b>mfind_ne</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_ne</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_ne</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>≠</code> - неравно</td>
            </tr>
            <tr>
                <td><code>_lt</code></td>
                <td><code><b>mfind_lt</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_lt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_lt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&lt;</code> - по-малко</td>
            </tr>
            <tr>
                <td><code>_le</code></td>
                <td><code><b>mfind_le</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_le</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_le</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&le;</code> - по-малко или равно</td>
            </tr>
            <tr>
                <td><code>_gt</code></td>
                <td><code><b>mfind_gt</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_gt</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code></td>
                <td><code><b>vlookup_gt</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&gt;</code> - по-голямо</td>
            </tr>
            <tr>
                <td><code>_ge</code></td>
                <td><code><b>mfind_ge</b>(<var>M</var>; <var>x</var>)</code></td>
                <td><code><b>hlookup_ge</b>(<var>M</var>; <var>x</var>; <var>i</var><sub>1</sub>; <var>i</var><sub>2</sub>)</code>
                <td><code><b>vlookup_ge</b>(<var>M</var>; <var>x</var>; <var>j</var><sub>1</sub>; <var>j</var><sub>2</sub>)</code></td>
                <td><code>&ge;</code> - по-голямо или равно</td>
            </tr>
        </table>

        <p><b>Математически функции</b></p>
        <p>Всички стандартни скаларни математически функции приемат и матрични аргументи. Функцията се прилага отделно към всеки елемент от входната матрица, дори и когато е от специален тип. Резултатите се връщат в съответната изходна матрица. Тя винаги е от общ (правоъгълен) тип, така че структурата не се запазва. Например:</p>
        <p>
            &emsp;&emsp;<code>#rad</code><br />
            &emsp;&emsp;<code><var>M</var> = <b>diagonal</b>(3; <var>π</var>/2)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1.571</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1.571</span><span class="td">0</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1.571</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><b>cos</b>(<var>M</var>)</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
            </span>
        </p>
        <p>Calcpad също включва много математически функции, които са специфични за матрици, както следва:</p>

        <p>&emsp;&emsp;<code><b>hprod</b>(<var>A</var>; <var>B</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - първа матрица;<br />
                <var>B</var> - втора матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(матрица) произведение на Hadamard на матриците <var>A</var> и <var>B</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Двете матрици трябва да са с еднакъв размер. Произведението на Hadamard (или известно още като Schur) <var>C</var> = <var>A</var>⊙<var>B</var> е поелементно произведение на две матрици. Елементите на получената матрица се получават от следното уравнение:<br /><var>C</var><sub>ij</sub> = <var>A</var><sub>ij</sub> <var>B</var><sub>ij</sub>. Ако и двете матрици са от еднакъв тип, типът се запазва в изхода, в противен случай върнатата матрица е от общ тип.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [9; 8|7; 6|5; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>hprod</b>(<var>A</var>; <var>B</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">21</span><span class="td">24</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">25</span><span class="td">24</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>fprod</b>(<var>A</var>; <var>B</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - първа матрица;<br />
                <var>B</var> - втора матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) произведение на Frobenius на матриците <var>A</var> и <var>B</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Двете матрици трябва да са с еднакъв размер. Резултатът се получава като сума от произведенията на съответните двойки елементи на входните матрици:<br />
                <span class="eq"><var>p</var> = <span class="dvr"><small><var>m</var></small><span class="nary">∑</span><small><var>i</var>=&hairsp;1</small></span><span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>j</var>=&hairsp;1</small></span><var>A</var><sub>ij</sub> <var>B</var><sub>ij</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4|5; 6]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [9; 8|7; 6|5; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">9</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>fprod</b>(<var>A</var>; <var>B</var>)</code>' = 119
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>kprod</b>(<var>A</var>; <var>B</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - първа матрица;<br />
                <var>B</var> - втора матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(матрица) произведение на Kronecker на матриците <var>A</var> и <var>B</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Ако <var>A</var> е m×n, а <var>B</var> е p×q матрица, резултатът е mp×nq блокова матрица <var>C</var>, където всеки блок е получен от уравнението:<br />[<var>C</var>&hairsp;]<sub>ij</sub> = <var>A</var><sub>ij</sub> <var>B</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = [5; 6; 7|8; 9; 10]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td"></span></span>
                </span><br />
                <code><var>C</var> = <b>kprod</b>(<var>A</var>; <var>B</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">6</span><span class="td">7</span><span class="td">10</span><span class="td">12</span><span class="td">14</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">9</span><span class="td">10</span><span class="td">16</span><span class="td">18</span><span class="td">20</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">15</span><span class="td">18</span><span class="td">21</span><span class="td">20</span><span class="td">24</span><span class="td">28</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">24</span><span class="td">27</span><span class="td">30</span><span class="td">32</span><span class="td">36</span><span class="td">40</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_1</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>1</sub> (Манхатън или таксиметрова) норма на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Получава се като максималната от всички L<sub>1</sub> векторни норми на стълбовете от уравнението: <span class="eq">||<var>M</var>&hairsp;||<sub>1</sub> = <span class="dvr"><small></small><span style="display: block; position:relative; top:0.4em;">max</span><small>1 &le; <var>j</var> &le; <var>n</var>&ensp;</small></span><span class="dvr"><small><var>m</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>M</var><sub>ij</sub>&hairsp;<b class="b0">|</b></span></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_1</b>(<var>A</var>)</code>' = 18
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm</b>(<var>M</var>)</code> или <code><b>mnorm_2</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - m×n матрица, където m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>2</sub> (спектралната) норма на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Получава се като максималната от всички сингулярни стойности на матрицата <var>M</var>&hairsp;:
                <span class="eq">||<var>M</var>&hairsp;||<sub>2</sub> = <var>&sigma;</var><sub>max</sub>&hairsp;(<var>M</var>&hairsp;)</span>.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_2</b>(<var>A</var>)</code>' = 16.8481
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_e</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ нормата на Фробениус (Евклидова) на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Подобна е на векторната Евклидова норма, при условие, че матрицата е линеаризирана чрез конкатенация на редовете. Изчислява се като корен квадратен от сумата на квадратите на всички елементи на матрицата, както следва:<br />
                <span class="eq">||<var>M</var>&hairsp;||<sub>e</sub> = &emsp;<span class="o2"><span class="r2"></span><span class="dvr"><small><var>m</var></small><span class="nary">∑</span><small><var>i</var>&hairsp;=&hairsp;1</small></span><span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>j</var>&hairsp;=&hairsp;1</small></span><var>M</var><sub>ij</sub><sup>2</sup></span></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_e</b>(<var>A</var>)</code>' = 16.8819
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>mnorm_i</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;скалар, представляващ L<sub>∞</sub> (безкрайност) нормата на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Получава се като максималната от всички L<sub>1</sub> векторни норми на редовете чрез уравнението:<br /> <span class="eq">||<var>M</var>&hairsp;||<sub> ∞</sub> = <span class="dvr"><small></small><span style="display: block; position:relative; top:0.4em;">max</span><small>1 &le; <var>i</var> &le; <var>m</var></small>&ensp;</span><span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>j</var>&hairsp;=&hairsp;1</small></span><b class="b0">|</b>&hairsp;<var>M</var><sub>ij</sub>&hairsp;<b class="b0">|</b></span></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>mnorm_i</b>(<var>A</var>)</code>' = 24
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_1</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) числото на обусловеност на <var>M</var>, базирано на L<sub>1</sub> нормата.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Изчислява се от уравнението:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>1</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>1</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>1</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_1</b>(<var>A</var>)</code>' = 6.4852×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond</b>(<var>M</var>)</code> or <code><b>cond_2</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - m×n матрица, където m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) числото на обусловеност на <var>M</var>, базирано на L<sub>2</sub> нормата.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Числото на обусловеност показва колко чувствителна е матрицата <var>A</var> за решаване на уравнението <var>A</var><var><span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var> или за обръщане на матрицата. Колкото по-голямо е числото, толкова по-ниска е точността на полученото решение. На теория, сингулярните матрици имат безкрайни числа на обусловеност. В среда с плаваща запетая обаче може да се получи много голямо, но все пак крайно число поради грешки от закръгление. Числото на обусловеност се изчислява по следния израз:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>2</sub>(<var>M</var>&hairsp;) = <var>&sigma;</var><sub>max</sub>(<var>M</var>&hairsp;) / <var>&sigma;</var><sub>min</sub>(<var>M</var>&hairsp;)</span><br />
                Тъй като това е скъпа от изчислителна гледна точка операция, вместо нея може да изпозвате някоя от другите функции, които дават подобни стойности, но с по-малък изчислителен разход.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_2</b>(<var>A</var>)</code>' = 1.7159×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_e</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) числото на обусловеност на <var>M</var>, базирано на нормата на Frobenius.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Получава се от израза:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>e</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>e</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>e</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_e</b>(<var>A</var>)</code>' = 4.5618×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cond_i</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) числото на обусловеност на <var>M</var>, базирано на L<sub>∞</sub> нормата.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Получава се от уравнението:<br />
                <span class="eq"><var>&kappa;</var>&hairsp;<sub>∞</sub>(<var>M</var>&hairsp;) = ||<var>M</var>&hairsp;||<sub>∞</sub>&middot;&hairsp;||&hairsp;<var>M</var> <sup>-1</sup>&hairsp;||<sub>∞</sub></span>
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>cond_i</b>(<var>A</var>)</code>' = 8.6469×10<sup>17</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>det</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) детерминантата на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">За да се определи резултатът, матрицата първо се декомпозира на долна (<var>L</var>) и горна (<var>U</var>) триъгълни матрици чрез LU факторизация. След това, детерминантата се получава като произведение на елементите по главния диагонал на матрицата <var>U</var>. Теоретично, за сингулярни матрици детерминантата трябва да е точно нула. Въпреки това, не се препоръчва прилагането на този критерий в практиката, тъй като поради грешки от закръгляване при изчисления с плаваща запетая, той може да върне "малка", но различна от нула стойност. Вместо това е по-добре да използвате ранга или числото на обусловеност.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>det</b>(<var>A</var>)</code>' = 6.6613×10<sup>-16</sup>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>rank</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - m×n матрица, където m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) рангът на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Рангът представлява броя на линейно независимите редове на матрицата. Той се определя чрез извършване на SVD декомпозиция на матрицата и преброяване на ненулевите сингулярни стойности.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>rank</b>(<var>A</var>)</code>' = 2
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>trace</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) следата на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Следата се дефинира като сумата от елементите по главния диагонал на квадратната матрица.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>trace</b>(<var>A</var>)</code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>transp</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(матрица) транспонираната матрица на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Транспонирането се получава чрез размяна на местата на редовете и стълбовете на матрицата. Ако <var>M</var> е симетрична, транспонираната матрица е равна на самата матрица, така че се връща направо копие на <var>M</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 3|4; 5; 6|7; 8; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">7</span><span class="td">8</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><b>transp</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">4</span><span class="td">7</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">5</span><span class="td">8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">9</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>adj</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;адюнгираната матрица на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Адюнгираната на квадратна матрица представлява нейната транспонирана кофакторна матрица. Тя се получава, като се умножи обратната матрица на <var>M</var> по детерминантата на <var>M</var>:<br /> <b>adj</b>(<var>M</var>&hairsp;) = <var>M</var> <sup>-1</sup> &middot; |<var>M</var>&hairsp;|</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2|3; 4]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td"></span></span>
                </span><br />
                <code><b>adj</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">2</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
                <code><b>det</b>(<var>A</var>)</code>' = 2<br />
                <code><b>inverse</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-2</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1.5</span><span class="td">-0.5</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cofactor</b>(<var>A</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>A</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;кофакторната матрица на <var>A</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Кофакторът <var>C</var><sub>ij</sub> се определя като съответния минор <var>M</var><sub>ij</sub> се умножи по (-1)<sup><var>i</var> + <var>j</var></sup>. Минорът <var>M</var><sub>ij</sub> от своя страна е равен на детерминантата на матрицата, получена чрез премахване на <var>i</var>-тия ред и <var>j</var>-тия стълб. Също така, кофакторната матрица е равна на транспонираната адюнгирана матрица на <var>A</var>:<br /><var>C</var> = <b>adj</b>(<var>A</var>&hairsp;)<sup>T</sup></span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><b>cofactor</b>([1; 2|3; 4])</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">-1</span><span class="td"></span></span>
                </span><br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigenvals</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - симетрична матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектор, съдържащ собствените стойности на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Собствените стойности се връщат в нарастващ ред. Изчисленията се извършват с помощта на симетричен QL алгоритъм с неявни измествания.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigenvals</b>(<var>A</var>)</code>' = [0.0188&ensp;15.5&ensp;123.48]
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigenvecs</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - симетрична матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;матрица, чиито стълбове представляват собствените вектори на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Те се връщат в същия ред, като съответните собствени стойности, получени от функцията <b>eigenvals</b>(<var>M</var>&hairsp;).</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigenvecs</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0.963</span><span class="td">-0.213</span><span class="td">-0.163</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.265</span><span class="td">-0.849</span><span class="td">-0.457</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.0411</span><span class="td">-0.484</span><span class="td">0.874</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>eigen</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - симетрична матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">n×(n + 1) матрица, чийто първи стълб съдържа собствените стойности, а останалите - собствените вектори на матрицата <var>M</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">В случай, че са нужни и двете, тази функция е по-ефективна от извикването на <b>eigenvals</b>(<var>M</var>&hairsp;) и <b>eigenvecs</b>(<var>M</var>&hairsp;) поотделно.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><b>eigen</b>(<var>A</var>)</code>' =<span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0.0188</span><span class="td">0.963</span><span class="td">-0.213</span><span class="td">-0.163</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">15.5</span><span class="td">-0.265</span><span class="td">-0.849</span><span class="td">-0.457</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">123.48</span><span class="td">0.0411</span><span class="td">-0.484</span><span class="td">0.874</span><span class="td"></span></span>
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cholesky</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - симетрична, положително определена матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(горна триъгълна матрица) декомпозиция на Cholesky на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Този вид декомпозиция представя матрицата като произведение на две триъгълни матрици: <var>M</var> = <var>L</var>&middot;<var>L</var>&hairsp;<sup>T</sup>. Текущата функция връща само горната част - <var>L</var>&hairsp;<sup>T</sup>. Декомпозицията на Cholesky е по-бърза и по-стабилна от съответната LU факторизация на същата матрица.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>( _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4; 12; -16| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;12; 37; -43| _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;-16; -43; 98]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>LT</var> = <b>cholesky</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">6</span><span class="td">-8</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
                </span> - горната триъгълна матрица <var>L</var><sup>T</sup><br />
                <code><var>L</var> = <b>transp</b>(<var>LT</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-8</span><span class="td">0</span><span class="td">3</span><span class="td"></span></span>
                </span> - долната триъгълна матрица <var>L</var><br />
                <code><var>L</var>*<var>LT</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span> - проверка
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>lu</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(матрица) LU декомпозиция на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                LU декомпозицията представя матрицата като произведение на две матрици: долна триъгълна <var>L</var> и горна триъгълна <var>U</var> (<var>M</var> = <var>L</var>&middot;<var>U</var>&hairsp;). То не изисква матрицата да бъде симетрична. Тъй като LU разлагането не е уникално, съществуват безброй много решения. Обикновено се приема, че всички елементи по главния диагонал на <var>L</var> са равни на единица. Функцията връща двете матрици <var>L</var> и <var>U</var>, обединени в обща квадратна матрица. Елементите по главния диагонал принадлежат на <var>U</var>, тъй като е известно, че тези на <var>L</var> са единици. Решението се извършва чрез алгоритъма на Crout и преподреждане с частичен избор на водещ елемент. Вместо обаче да изгражда пермутационна матрица <var>P</var>, Calcpad вътрешно създава вектор <var><span class="vec">⃗</span>ind</var>, съдържащ индексите на редовете след преподреждането.<br />
                Ако са необходими двете матрици <var>L</var> и <var>U</var> поотделно, можете да ги извлечете чрез умножение на Hadamard на комбинираната матрица със съответната долна/горна триъгълна матрица. След това трябва да презапишете диагоналните елементи на <var>L</var> с единици.<br />
                Ако типът на <var>M</var> е симетрична матрица, вместо LU се връща LDL<sup>T</sup> декомпозицията. Тя е подобна на декомпозицията на Cholesky, но се избягва коренуването на диагоналните елементи. По тази причина, не е задължително матрицата да бъде положително определена. За сметка на това пък се налага да се съхраняват диагоналните елементи в отделна диагонална матрица <var>D</var>. Вследствие на това, матрицата <var>M</var> се представя като произведение на три матрици: <var>M</var> = <var>L</var>&middot;<var>D</var>&middot;<var>L</var>&hairsp;<sup>T</sup>. Те също се връщат обединени в една обща квадратна матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>LU</var> = <b>lu</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1.33</span><span class="td">6.33</span><span class="td">40.67</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.333</span><span class="td">-0.0526</span><span class="td">0.474</span><span class="td"></span></span>
                </span> - съставната матрица<br />
                <code><var>ind</var></code>' = [2&emsp;3&emsp;1]<br />
                <code><var>D</var> = <b>not</b>(<b>identity</b>(3))</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                </span> - векторът с индексите на пермутацията<br />
                <code><var>L</var> = <b>hprod</b>(<b>mfill</b>(<b>ltriang</b>(3); 1); <var>LU</var>)^<var>D</var></code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-1.333</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.3333</span><span class="td">-0.05263</span><span class="td">1</span><span class="td"></span></span>
                </span> - извлича долната триъгълна матрица<br />
                <code><var>U</var> = <b>hprod</b>(<b>mfill</b>(<b>utriang</b>(3); 1); <var>LU</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">6.333</span><span class="td">40.667</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.4737</span><span class="td"></span></span>
                </span> - извлича горната триъгълна матрица<br />
                <code><b>extract_rows</b>(<var>L</var>*<var>U</var>; <b>order</b>(<var>ind</var>))</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span> - проверка
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>qr</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(матрица) QR декомпозиция на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Както подсказва името, матрицата се представя като произведение (<var>M</var> = <var>Q</var>&middot;<var>R</var>&hairsp;) на ортонормална матрица <var>Q</var> и горна триъгълна матрица <var>R</var>. За тази цел се използва методът на Householder. Алгоритъмът е устойчив и не изисква преподреждане. Двете матрици се обединяват в една обща n×2n блокова правоъгълна матрица [Q,R], която се връща като резултат. Можете да извлечете всяка от двете матрици, използвайки функцията <b>submatrix</b>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>QR</var> = <b>qr</b>(<var>A</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.196</span><span class="td">-0.169</span><span class="td">0.966</span><span class="td">-20.4</span><span class="td">-57.85</span><span class="td">105.31</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.588</span><span class="td">-0.768</span><span class="td">-0.254</span><span class="td">0</span><span class="td">-3.86</span><span class="td">-24.85</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.784</span><span class="td">-0.618</span><span class="td">0.0508</span><span class="td">0</span><span class="td">0</span><span class="td">0.457</span><span class="td"></span></span>
                </span> - съставната QR матрица<br />
                <code><var>Q</var> = <b>submatrix</b>(<var>QR</var>; 1; 3; 1; 3)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.1961</span><span class="td">-0.1695</span><span class="td">0.9658</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.5883</span><span class="td">-0.7676</span><span class="td">-0.2542</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.7845</span><span class="td">-0.6181</span><span class="td">0.05083</span><span class="td"></span></span>
                </span> - извлича Q матрицата<br />
                <code><var>R</var> = <b>submatrix</b>(<var>QR</var>; 1; 3; 4; 6)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-20.396</span><span class="td">-57.854</span><span class="td">105.314</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">-3.858</span><span class="td">-24.853</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.4575</span><span class="td"></span></span>
                </span> - извлича R матрицата<br />
                <code><var>Q</var>*<var>R</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span> - проверка
                </span>
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>svd</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - m×n матрица, където m &ge; n.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;декомпозиция по сингулярни стойности (SVD) на матрицата <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">
                Матрицата се разлага като произведение на три матрици:<br /><var>M</var> = <var>U</var>&middot;<var>&Sigma;</var>&middot;<var>V</var>&hairsp;<sup>T</sup>,<br />където <var>&Sigma;</var> е диагонална матрица, съдържаща сингулярните стойности на <var>M</var>, а <var>U</var> и <var>V</var>&hairsp;<sup>T</sup> са ортонормални матрици, чиито стълбове представляват съответно левите и десните сингулярни вектори. Резултатът се връща като една обща m×(2n + 1) матрица [U, &Sigma;, V], където <var>&Sigma;</var> е единичен стълб, съдържащ всички сингулярни стойности. Те са сортирани в низходящ ред, а сингулярните вектори са дадени в реда на съответните им сингулярни стойности. Трябва да се има в предвид, че върнатата матрица <var>V</var>&hairsp;<sup>T</sup> вече е транспонирана, така че не е нужно да я транспонирате отново.<br />
                Понякога, определени сингулярни вектори може да сменят знаците си, така че произведението на получените матрици <var>U</var>&middot;<var>&Sigma;</var>&middot;<var>V</var>&hairsp;<sup>T</sup> да не дава <var>M</var>. Неопределеността на знаците е добре известен и често срещан проблем при повечето SVD алгоритми. За симетрични матрици сингулярните стойности са равни на абсолютните собствените стойности: <var>&sigma;</var><sub>i</sub> = |&hairsp;<var>&lambda;</var><sub>i</sub>|
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>SVD</var> = <b>svd</b>(<var>A</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">0.2127</span><span class="td">-0.9634</span><span class="td">123.477</span><span class="td">-0.163</span><span class="td">-0.4573</span><span class="td">0.8742</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.4573</span><span class="td">0.849</span><span class="td">0.2648</span><span class="td">15.504</span><span class="td">0.2127</span><span class="td">0.849</span><span class="td">0.4838</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.8742</span><span class="td">0.4838</span><span class="td">-0.0411</span><span class="td">0.0188</span><span class="td">-0.9634</span><span class="td">0.2648</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - съставната матрица<br />
                <code><var>U</var> = <b>submatrix</b>(<var>SVD</var>; 1; 3; 1; 3)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">0.2127</span><span class="td">-0.9634</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.4573</span><span class="td">0.849</span><span class="td">0.2648</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.8742</span><span class="td">0.4838</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - извлича U матрицата<br />
                <code><var>V</var> = <b>submatrix</b>(<var>SVD</var>; 1; 3; 5; 7)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">-0.163</span><span class="td">-0.4573</span><span class="td">0.8742</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0.2127</span><span class="td">0.849</span><span class="td">0.4838</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-0.9634</span><span class="td">0.2648</span><span class="td">-0.0411</span><span class="td"></span></span>
                </span> - извлича V матрицата<br />
                <code><var>σ</var> = <b>col</b>(<var>SVD</var>; 4)</code>' = <span class="eq">[123.477&nbsp;15.504&nbsp;0.0188]</span> - извлича сингулярните стойности<br />
                <code><var>Σ</var> = <b>vec2diag</b>(<var>σ</var>)</code>' = <br /><span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">123.477</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">15.504</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">0.0188</span><span class="td"></span></span>
                </span> - съставя матрицата на сингулярните стойности
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>inverse</b>(<var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<var>M</var> - квадратна матрица.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;обратната матрица на <var>M</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Обратната матрица се получава чрез LU декомпозиция за несиметрични матрици и LDL<sup>T</sup> декомпозиция за симетрични. Ако матрицата е сингулярна, обратната матрица не съществува. Ако е лошо обусловена, резултатът ще бъде изкривен от големи грешки. Това се открива по време на LU декомпозицията, като се следи за нулев или много малък водещ елемент. Ако такъв се открие, се връща подходящо съобщение за грешка, вместо грешен резултат.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [4; 12; -16|12; 37; -43|-16; -43; 98]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">12</span><span class="td">-16</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">12</span><span class="td">37</span><span class="td">-43</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-16</span><span class="td">-43</span><span class="td">98</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>inverse</b>(<var>A</var>)</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">49.361</span><span class="td">-13.556</span><span class="td">2.111</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-13.556</span><span class="td">3.778</span><span class="td">-0.5556</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">2.111</span><span class="td">-0.5556</span><span class="td">0.1111</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var>*<var>B</var></code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">0</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">0</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">0</span><span class="td">1</span><span class="td"></span></span>
                </span> - проверка
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>lsolve</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - квадратна матрица с коефициентите на уравнението;<br />
                <var><span class="vec">⃗</span>b</var> - вектора на дясната страна.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;вектора на решението <var><span class="vec">⃗</span>x</var> на системата от линейни уравнения <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Изчисленията се извършват чрез LU декомпозиция за несиметрични матрици и LDL<sup>T</sup> за симетрични. Поради това, матрицата не е задължително да бъде положително определена. Ако <var>A</var> е сингулярна или лошо обусловена, се връща съобщение за грешка.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [8; 6; -4|6; 12; -3|-4; -3; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = [10; 20; 30]</code>' = [10&ensp;20&ensp;30]<br />
                <code><var>x</var> = <b>xxxxxxx</b>(<var>A</var>; <var>b</var>)</code>' = [2.5&ensp;1.667&ensp;5] - векторът на решението<br />
                <code><var>A</var>*<var>x</var></code>' = [10&ensp;20&ensp;30] - проверка<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>clsolve</b>(<var>A</var>; <var><span class="vec">⃗</span>b</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>A</var> - симетрична, положително определена матрица на коефициентите;<br />
                <var><span class="vec">⃗</span>b</var> - вектора на дясната страна.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">вектора на решението <var><span class="vec">⃗</span>x</var> на системата линейни уравнения <var>A<span class="vec">⃗</span>x</var> = <var><span class="vec">⃗</span>b</var> с използване на декомпозиция на Cholesky.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;<span class="hang">Декомпозицията на Cholesky е по-бърза от LU и LDL<sup>T</sup>, така че тази функция е за предпочитане пред <b>lsolve</b>, винаги когато матрицата е симетрична и положително определена.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code>
                    <var>A</var> = <b>copy</b>([8; 6; -4|6; 12; -3|-4; -3; 9]; _<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1)
                </code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>b</var> = [10; 20; 30]</code>' = [10&ensp;20&ensp;30]<br />
                <code><var>x</var> = <b>clsolve</b>(<var>A</var>; <var>b</var>)</code>' = [2.5&ensp;1.667&ensp;5]<br />
                <code><var>A</var>*<var>x</var></code>' = [10&ensp;20&ensp;30] - проверка<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>msolve</b>(<var>A</var>; <var>B</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&emsp;<span class="hang">
                <var>A</var> - квадратна матрица с коефициентите на уравнението;<br />
                <var>B</var> - матрица на дясната страна.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>:&ensp;матрицата решение <var>X</var> на обобщеното матрично уравнение <var>AX</var> = <var>B</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Бележки</em>:&emsp;&emsp;&emsp;&nbsp; <span class="hang">Функцията е подобна на <b>lsolve</b>, при положение, че стълбовете на матрицата <var>B</var> съдържат множество десни вектори, а стълбовете на матрицата <var>X</var> представляват съответните резултантни вектори. По този начин функцията може да решава множество системи линейни уравнения паралелно. LU/LDLT декомпозицията на <var>A</var> се извършва само веднъж в началото и резултатът се преизползва многократно при обратния ход на решението.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>:&emsp;&emsp; <span class="hang">
                <code><var>A</var> = [8; 6; -4|6; 12; -3|-4; -3; 9]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span>
                </span><br />
                <code><var>B</var> = <b>join</b><sub>cols</sub>([10; 20; 30]; [40; 50; 60])</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span><br />
                <code><var>X</var> = <b>msolve</b>(<var>A</var>; <var>B</var>)</code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">2.5</span><span class="td">8.71</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">1.67</span><span class="td">2.67</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">11.43</span><span class="td"></span></span>
                </span><br />
                <code><var>A</var>*<var>X</var></code>' = <span class="matrix">
                    <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
                </span> - проверка<br />
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>cmsolve</b>(<var>A</var>; <var>B</var>)</code></p><p>   &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&emsp;<span class="hang">
            <var>A</var> - симетрична, положително определена матрица на коефициентите;<br />
            <var>B</var> - матрица на дясната страна на уравнението. </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>:&ensp;<span class="hang">матрицата решение <var>X</var> на обобщеното матрично уравнение <var>A</var><var>X</var> = <var>B</var> чрез декомпозиция на Холецки.</span><br /> &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;&emsp;&emsp;&nbsp; <span class="hang">Функцията е подобна на <b>clsolve</b>, при положение, че стълбовете на матрицата <var>B</var> съдържат множество десни вектори, а стълбовете на матрицата <var>X</var> представляват съответните резултантни вектори. По този начин, функцията може да решава няколко системи линейни уравнения паралелно. Декомпозицията на Холецки на матрицата <var>A</var> се извършва само веднъж в началото и резултатът се преизползва многократно при обратния ход на решението.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>:&emsp;&emsp; <span class="hang">
            <code> <var>A</var> = <b>copy</b>([8; 6; -4|6; 12; -3|-4; -3; 9]; _<br />
            &nbsp;&nbsp;&nbsp;&nbsp;<b>symmetric</b>(3); 1; 1) </code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">6</span><span class="td">-4</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">12</span><span class="td">-3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">-4</span><span class="td">-3</span><span class="td">9</span><span class="td"></span></span> 
                </span><br /> 
            <code><var>B</var> = <b>join</b><sub>cols</sub>([10; 20; 30]; [40; 50; 60])</code>' = <span class="matrix">
                <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span>
            </span><br />
            <code><var>X</var> = <b>msolve</b>(<var>A</var>; <var>B</var>)</code>' = <span class="matrix"> 
                <span class="tr"><span class="td"></span><span class="td">2.5</span><span class="td">8.71</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">1.67</span><span class="td">2.67</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">11.43</span><span class="td"></span></span>
            </span><br /> 
            <code><var>A</var>*<var>X</var></code>' = <span class="matrix">
                <span class="tr"><span class="td"></span><span class="td">10</span><span class="td">40</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">50</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">30</span><span class="td">60</span><span class="td"></span></span> 
                </span> - проверка<br /> 
            </span>
        </p>

        <p><b>Агрегатни и интерполационни функции</b></p>
        <p>Всички агрегатни функции могат да работят и с матрични аргументи. Тъй като те са многопараметрични, всяка от тях може да приема като аргумент както единична матрица, така и списък от скалари, вектори и матрици, смесени в произволен ред. Например:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [0; 2| 4; 8]</code><br />
            &emsp;&emsp;<code><var>b</var> = [5; 3; 1]</code><br />
            &emsp;&emsp;<code><b>sum</b>(10; <var>A</var>; <var>b</var>; 11)</code>' = 44
        </p>
        <p>Интерполационните функции имат подобно поведение, когато е извикват със смесен списък от аргументи. В този случай матриците се линеаризират по редове и елементите им се включват в общия масив от скалари на съответните места. След това интерполацията се изпълнява върху целия масив. Има също така и "матрична" версия на тези функции, която извършва двойна интерполация върху една матрица. За тази цел трябва да зададете точно три аргумента: първите два трябва да са скалари (параметрите на интерполацията), а третият трябва да бъде матрица, както следва:</p>

        <p>&emsp;&emsp;<code><b>take</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>x</var> - индекс на реда;<br />
                <var>y</var> - индекс на стълба; <br />
                <var>M</var> - матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;(скалар) елементът на матрицата <var>M</var> с индекси <var>x</var> и <var>y</var>.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Забележки</em>:&emsp;Ако <var>x</var> и <var>y</var> не са цели числа, те се закръглят до най-близките такива.<br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>take</b>(2; 3; <var>A</var>)</code>' = 15
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>line</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>x</var> - променлива за интерполиране през редовете;<br />
                <var>y</var> - променлива за интерполиране през стълбовете;<br />
                <var>M</var> - матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">(скалар) стойността, получена чрез двойна линейна интерполация от елементите на матрицата <var>M</var>, на базата на стойностите <var>x</var> и <var>y</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>line</b>(1.5; 2.5; <var>A</var>)</code>' = 7
            </span>
        </p>

        <p>&emsp;&emsp;<code><b>spline</b>(<var>x</var>; <var>y</var>; <var>M</var>)</code></p><p>
            &emsp;&emsp;&emsp;&emsp;<em>Параметри</em>:&ensp;<span class="hang">
                <var>x</var> - променлива за интерполиране през редовете;<br />
                <var>y</var> - променлива за интерполиране през стълбовете;<br />
                <var>M</var> - матрица.
            </span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Резултат</em>: &emsp;<span class="hang">(скалар) стойността, получена чрез двойна сплайн интерполация на Ермит от елементите на матрица <var>M</var> на базата на стойностите <var>x</var> и <var>y</var>.</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>Пример</em>: &emsp;&emsp;<span class="hang">
                <code><var>A</var> = [1; 2; 5|3; 6; 15|5; 10; 25]</code>' = <span class="eq matrix">
                    <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">5</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">6</span><span class="td">15</span><span class="td"></span></span>
                    <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td">25</span><span class="td"></span></span>
                </span><br />
                <code><b>spline</b>(1.5; 2.5; <var>A</var>)</code>' = 6.625
            </span>
        </p>

        <p>Може да използвате интерполационни функции, за да визуализирате матрични данни, както в примера по-долу:</p>
        <p>&emsp;&emsp;<code>$Map{<b>spline</b>(<var>x</var>; <var>y</var>; <var>A</var>) @ <var>x</var> = 1 : <b>n_rows</b>(<var>A</var>) &amp; <var>y</var> = 1 : <b>n_cols</b>(<var>A</var>)}</code></p>
        <p>Пълен списък на наличните агрегатни и интерполационни функции е даден по-горе в настоящото ръководство (виж "Изрази/Функции").</p>

        <p><b>Оператори</b></p>
        <p>Всички оператори могат да се използват и с матрични операнди. Двете матрици трябва да са с един и същ размер. Операциите се извършват елемент по елемент, а резултатите се връщат в изходна матрица. Например:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [0; 1; 2|3; 4; 5]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">0</span><span class="td">1</span><span class="td">2</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">3</span><span class="td">4</span><span class="td">5</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>B</var> = [11; 10; 9|8; 7; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">10</span><span class="td">9</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">8</span><span class="td">7</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>A</var> + <var>B</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">11</span><span class="td">11</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">11</span><span class="td">11</span><span class="td">11</span><span class="td"></span></span>
            </span>
        </p>
        <p>Единственото изключение е операторът за умножение "*", който представлява стандартно произведение на две матрици. Поелементното умножение (произведение на Hadamard или Schur) е реализирано в Calcpad като функция: <b>hprod</b>. Матричното умножение <var>C</var><sub>m×p</sub> = <var>A</var><sub>m×n</sub> <var>B</var><sub>n×p</sub> е дефинирано така, че всеки елемент <var>c</var><sub>i&hairsp;j</sub> се получава като скаларно произведение на <var>i</var>-ти ред на <var>A</var> и <var>j</var>-ти стълб на <var>B</var>:</p>
        <p>&emsp;&emsp;<span class="eq"><var>c</var><sub>ij</sub> = <span class="dvr"><small><var>n</var></small><span class="nary">∑</span><small><var>k</var>&hairsp;=&hairsp;1</small></span><var>a</var><sub>ik</sub>&hairsp;<var>b</var><sub>kj</sub></span></p>
        <p>Например:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1; 2; 3|4; 5; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>B</var> = [6; 5|4; 3|2; 1]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">6</span><span class="td">5</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">2</span><span class="td">1</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>C</var> = <var>A</var>*<var>B</var></code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">20</span><span class="td">14</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">56</span><span class="td">41</span><span class="td"></span></span>
            </span>
        </p>

        <p>Всички двоични оператори поддържат и смесени операнди: матрица-вектор и вектор-матрица. В този случай, векторът се третира като матрица-стълб. Например:</p>
        <p>
            &emsp;&emsp;<code><var>A</var> = [1; 2; 3|4; 5; 6]</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">1</span><span class="td">2</span><span class="td">3</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">4</span><span class="td">5</span><span class="td">6</span><span class="td"></span></span>
            </span><br />
            &emsp;&emsp;<code><var>b</var> = [6; 5; 4]</code><br />
            &emsp;&emsp;<code><var>A</var>*<var>b</var></code>' = [28&ensp;73]
        </p>
        <p>Операторите за матрица-скалар и скалар-матрица също са реализирани поелементно. Операцията с предоставения скалар се извършва за всеки елемент, а резултатът се връща като матрица. Например:</p>
        <p>
            &emsp;&emsp;<code>[1; 2|3; 4]*5</code>' = <span class="eq matrix">
                <span class="tr"><span class="td"></span><span class="td">5</span><span class="td">10</span><span class="td"></span></span>
                <span class="tr"><span class="td"></span><span class="td">15</span><span class="td">20</span><span class="td"></span></span>
            </span>
        </p>

        <h2 id="TOC_500">Записка</h2>
        <p>Резултатите от изчисленията се документират автоматично като изчислителна записка, която може да разпечатате или да отворите с Word. Освен аритметични изрази, в нея може да добавите заглавия, текстови коментари, изображения и таблици.</p>

        <h3 id="TOC_501">Заглавия</h3>
        <p>Заглавието е текст, заграден в двойни кавички (<b>"</b>). Той излиза удебелен и с по-големи букви от стандартния текст. Ако след заглавието няма нищо друго на реда, може да пропуснете затварящата кавичка.</p>

        <h3 id="TOC_502">Текст/коментари</h3>
        <p>Коментарите се заграждат в единични кавички (<b>'</b>). Те се изобразяват със стандартен шрифт с размер 12 pt. Може да пропуснете затварящата кавичка, ако тя е последния символ на реда. Както в заглавията, така и в коментарите, може да пишете свободен текст, без ограничения. Всичко извън кавичките се възприема от програмата като аритметични изрази. Ако сложите формули вътре в кавичките, те няма да бъдат изчислени, но ще се покажат в записката така, както са записани. Тъй като резултатите се оформят накрая в Html документ, може да добавите Html и CSS елементи в коментарите за да форматирате допълнително записката.</p>

        <h3 id="TOC_503">Мерни единици в коментари</h3>
        <p>Като алтернатива, може да въведете всички величини в изчисленията като бездименсионни, а мерните единици да добавите като текстови коментари след съответните изрази. В този случай обаче, трябва да направите преобразуването между отделните мерни единици във формулите ръчно, като добавите съответните коефициенти. По отношение на единиците за дължина(<b>m</b>, <b>cm</b> и <b>mm</b>), е добавена възможност за предварителен избор и автоматично попълване в записката. Трябва само да добавите <b>%u</b> навсякъде в коментарите, където желаете да се появи съответната единица за дължина. Ако има поне един символ <b>%u</b>, при генерирането на форма за вход на данни, програмата автоматично ще добави и падащо меню за избор на мерни единици в горния десен ъгъл. Когато изберете желаните единици от падащото меню, те ще се попълнят автоматично навсякъде, където се среща <b>%u</b>. Може да изпробвате примера по-долу, като кликнете падащото меню отдясно или копирате програмния код отляво, в прозореца на Calcpad:</p>
        <table border="1">
            <thead>
                <tr>
                    <th>
                        Програмен код
                    </th>
                    <th>
                        Резултат
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="line-height:200%;">
                        <code>"Мерни единици</code><br />
                        <code>'Дължина -'l = ?{1}'%u</code><br />
                        <code>'Площ -'A = ?{1}'%u&lt;sup&gt;2&lt;/sup&gt;</code><br />
                        <code>'Обем -'V = ?{1}'%u&lt;sup>3&lt;/sup&gt;</code><br />
                        <code>'Коефициент за мащабиране -'Units</code><br />
                    </td>
                    <td style="line-height:200%;">
                        <select id="Units" name="Units"><option value="m"> m </option><option value="cm"> cm </option><option value="mm"> mm </option></select>
                        <b>Мерни единици</b><br />
                        Дължина -  <var>l</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><br />
                        Площ -  <var>A</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><sup>2</sup><br />
                        Обем -  <var>V</var> = <input type="text" size="2" name="Variable" value="1"> <span class="Units">m</span><sup>3</sup><br />
                        Коефициент за мащабиране -  <var>Units</var>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Когато изчислите записката, падащото меню ще изчезне и ще останат само попълнените единици. Програмата ще създаде и служебна променлива <var>Units</var>, която съдържа коефициент за привеждане на избраните единици към метри. Стойността и ще бъде 1, 100 и 1000, съответно за m, mm и cm. Може да я използвате директно във формулите за да преобразувате избраните единици. С нейна помощ може да направите и условен блок, с който да добавите описание на избраните единици в записката:</p>
        <p>
            <span class="cond">#if</span> <var>Units</var> ≡ 1<br />
            &emsp;&emsp;&emsp;'Избрани са метри<br />
            <span class="cond">#else if</span> <var>Units</var> ≡ 100<br />
            &emsp;&emsp;&emsp;'Избрани са сантиметри<br />
            <span class="cond">#else if</span> <var>Units</var> ≡ 1000<br />
            &emsp;&emsp;&emsp;'Избрани са милиметри<br />
            <span class="cond">#end if</span>
        </p>

        <h3 id="TOC_504">Форматиране с Html и CSS</h3>
        <p>Calcpad е не само софтуер за математически изчисления, но и за автоматизирано генериране на изчислителна документация. С негова помощ може да създавате професионално изглеждащи записки за инженерни изчисления, които да добавите в официална проекто-сметна документация. Доброто и графично оформление е важно и ако имате намерение да ползвате Calcpad за тази цел, непременно прочетете следващата глава.</p>
        <p>За документиране на резултатите от изчисленията се използва Html формат (Hyper Text Markup Language). Това е маркиращ език, който първоначално е създаден за форматиране на уеб страници. Поради това, той се радва на широко разпространение и поддръжка. С негова помощ може да променяте вида на шрифта, размера и цвета на буквите, да направите текста удебелен или курсив, да вмъквате таблици, изображения и др. Това става чрез добавянето на специални елементи в текста наречени маркери (tags). Всеки маркер се загражда в триъгълни скоби: "&lt;tag&gt;". Повечето маркери се използват по двойки - отварящ "&lt;tag&gt;" и затварящ "&lt;/tag&gt;". Текстовото съдържание се поставя между двата. Например, ако искате да направите част от текста удебелен, трябва да го заградите със следните маркери: &lt;b&gt;<b>удебелен текст</b>&lt;/b&gt;. Дори и да не сте професионален програмист и да не владеете Html, може лесно да научите някои основни елементи, които да използвате в Calcpad:</p>
        <table border="1">
            <thead>
                <tr>
                    <th>
                        Html код
                    </th>
                    <th>
                        Резултат
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <code><b>&lt;b&gt;</b>Bold<b>&lt;/b&gt;</b> или <b>&lt;strong&gt;</b>Bold<b>&lt;/strong&gt;</b></code>
                    </td>
                    <td>
                        <b style="color:black;">Bold</b>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;i&gt;</b>Italic<b>&lt;/i&gt;</b> или <b>&lt;em&gt;</b>Italic<b>&lt;/em&gt;</b></code>
                    </td>
                    <td>
                        <i style="color:black;">Italic</var>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;u&gt;</b>Underline<b>&lt;/u&gt;</b></code>
                    </td>
                    <td>
                        <u style="background:none;">Underline</u>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;span style="color:red;"&gt;</b>Red<b>&lt;/span&gt;</b></code>
                    </td>
                    <td>
                        <span style="color:red;">Red</span>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>x<b>&lt;sup&gt;</b>superscript<b>&lt;/sup&gt;</b></code>
                    </td>
                    <td>
                        x<sup>superscript</sup>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>x<b>&lt;sub&gt;</b>subscript<b>&lt;/sub&gt;</b></code>
                    </td>
                    <td>
                        <var>x</var><sub>subscript</sub>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code><b>&lt;span style="font:16pt Times-New-Roman;"&gt;</b><br />&emsp;&emsp;Times New Roman, 16pt<br /><b>&lt;/span&gt;</b></code>
                    </td>
                    <td>
                        <span style="font:16pt Times-New-Roman;">Times New Roman, 16pt</span>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>За улеснение, може да използвате менюто "<b>Вмъкни/Html</b>". Преди това, изберете текста, който желаете да маркирате с Html код. Може да вмъквате Html единствено в коментари, но може да направите така, че действието му да се отразява и на изрази, например:</p>
        <p style="margin-left: 2em;">'&lt;span style="color:red;"&gt; просто като ' 2 + 2 '&lt;/span&gt;'</p>
        <p>ще даде следния резултат:</p>
        <p style="margin-left: 2em;"><span style="color:red;"> просто като 2 + 2 = 4 </span></p>
        <p>За тази цел, трябва да заградите израза с коментари, които да съдържат съответно, отварящия '&lt;span style="color:red;"&gt;' и затварящия '&lt;/span&gt; маркер. Всичко, което е вътре между тях ще се оцвети в червено. Не забравяйте да заградите коментарите в кавички. В противен случай, програмата ще се опита да прочете Html кода като математически израз и ще генерира грешка. Текстът: <b>style="color:red"</b> се нарича "Inline CSS" (Cascading Style Sheets) и се използва за допълнително форматиране на Html елементите. Ако желаете да научите повече за Html и CSS, може да използвате следните линкове:</p>
        <p><a href="http://www.w3schools.com/html/">http://www.w3schools.com/html/</a></p>
        <p><a href="http://www.w3schools.com/CSS/">http://www.w3schools.com/CSS/</a></p>
        <p>За редактиране на Html, може да използвате и някой от многото безплатни визуални редактори, които могат да се намерят в Интернет.</p>

        <h4>Сгъване на съдържанието</h4>
        <p>Ако имате прекалено дълги и подробни изчисления, може да "сгънете" част от съдържанието на записката, така че да не се вижда по подразбиране, освен първия ред. По желание, потребителят може да "разгъне" останалата част, чрез кликване върху видимия ред, както и да я "сгъне" обратно. За тези цел, трябва само да поставите съдържанието в Html "<b>div</b>" елемент, който да има клас "<b>fold</b>", както следва:</p>
        <p>
            &emsp;&emsp;<code>'&lt;div class="fold"&gt;</code><br />
            &emsp;&emsp;<code>'&lt;b&gt;Заглавие&lt;/b&gt; (кликнете за показване)</code><br />
            &emsp;&emsp;<code>'Скрито съдържание</code><br />
            &emsp;&emsp;<code>'&lt;/div&gt;</code>
        </p>
        <p>Резултатът ще изглежда по следния начин:</p>
        <div class="fold">
            <p style="margin-left: 2em;"><b>Заглавие</b> (кликнете за показване)</p>
            <p style="margin-left: 2em;">Скрито съдържание</p>
        </div>

        <h3 id="TOC_505">Изображения</h3>
        <p>За да добавите картинка в записката, трябва предварително да я начертаете на някоя графична програма и да я запишете като "*.png", "*.gif" или "*.jpg" файл. Може да използвате Paint, Gimp, InkScape, DraftSight или други безплатни програми. След това, може да я вмъкнете в записката с помощта на Html. Поставете следния текст на желаното място в записката:</p>
        <p style="margin-left:24px;"><code>'&lt;img style="float:right" src="c:/Users/Me/Pictures/Picture1.png" alt="Picture1.png"&gt;'</code></p>
        <p>Разбира се, вместо "<b>c:/Users/Me/Pictures/Picture1.png</b>" трябва да въведете действителния път към файла с картинката. Той може да бъде на локалния диск, в мрежата или в Интернет. Винаги използвайте "дясна" наклонена черта "<b>/</b>, дори и когато файлът е локален. Ако картинката се намира във същата папка, като текущия файл, може да посочите относителен път, като например: "<b>./Picture1.png</b>". Записът <b>style="float:right"</b> измества картинката вдясно, позволявайки текста да преминава свободно отляво. Иначе, по подразбиране картинката става част от текста и го прекъсва. В някои случаи това също е необходимо, например при по-големи картинки, където отляво няма достатъчно място за текста. В такъв случай, може да пропуснете записа <b>style="float:right"</b>. Алтернативно на <b>style="float:right"</b>, може да използвате и <b>class="side"</b> за същата цел.</p>
        <p>За улеснение, може да използвате бутона <img alt="Image" height="20" src="Images/Image.png">. След натискането му се появява диалог за избор на файл. Намерете и посочете картинката и натиснете "<b>Open</b>". Записът се вмъква в началото на страницата, а самата картинка ще видите след изчисленията, в прозореца с резултати.</p>

        <h2 id="TOC_600">Програмиране</h2>
        <h3 id="TOC_601">Формуляри за вход на данни</h3>
        <p>Ако имате дълга и сложна задача или искате да споделите програмата с други потребители, е добре да създадете форма за попълване на данните. Това ще разграничи ясно входните параметри, които трябва да се попълват и ще предпази останалия код от случайно повреждане. Създаването на форми с Calcpad става изключително лесно. Просто поставете символа "<b>?</b>" навсякъде, където трябва да се въвежда някаква стойност, например "<var>a</var> = ?". От този момент нататък, няма да може да изчислите резултата директно, с бутона <img alt="Play" height="20" src="Images/Play.png">, както досега. Преди това ще трябва да генерирате форма за попълване, като натиснете <b>F4</b> или бутона  <img alt="Form" height="20" src="Images/Form.png">.</p>
        <p>Програмният код ще се скрие, а готовата форма ще се покаже в прозореца "Входни данни". Тя ще се зареди като Html формуляр, на цялата ширина на екрана. На мястото на всеки от поставените символи "<b>?</b>" ще се генерира поле за попълване. Останалата част от кода, също ще се вижда, форматиран като Html, но няма да може да се редактира. Ако в коментарите има символ <b>?</b>, там разбира се няма да се генерира поле за попълване. Примерна форма е показана на изображението по-долу:</p>
        <p><img alt="Sample3" width="700" src="Images/Sample3.bg.png"></p>
        <p>След това, трябва да попълните необходимите стойности в полетата и да натиснете <img alt="Play" height="20" src="Images/Play.png"> за да изчислите резултатите. Те ще се покажат в прозореца "<b>Резултати</b>", на мястото на входните данни.</p>
        <p><img alt="Sample4" width="700" src="Images/Sample4.bg.png"></p>
        <p>За да се върнете обратно към формуляра, натиснете повторно бутона <img alt="Play" height="20" src="Images/Play.png"> за да го изключите. Данните в полетата ще останат такива, каквито са били при последното въвеждане. Ако искате да се върнете обратно към програмния код, натиснете бутона <img alt="Form" height="20" src="Images/Form.png"> за да го отключите. Прозорецът "<b>Код</b>" ще се зареди отново от лявата страна на екрана. При това, входните данни ще бъдат присвоени на съответните въпросителни знаци. При позициониране на мишката над някой от тях, може да видите съответната стойност. Може дори да я промените, като кликнете върху самия знак. След като приключите с редактирането на кода, може отново да генерирате формата за попълване и входните данни ще се заредят в съответните полета.</p>
        <p>Програмите на Calcpad, които съдържат формуляри, се записват като "<b>*.cpd</b>" файл. Той може да се отваря в Calcpad чрез двойно кликване върху самия файл. При това, директно се зарежда формуляра с входните данни. Този начин на работа е за предпочитане и има няколко съществени предимства пред текстовия формат:</p>
        <ul>
            <li>Входните данни се разграничават ясно. Може да се добавят и схеми, които ги изясняват допълнително. Това е много по-разбираемо за потребителя, особено ако записката не е разработена от него;</li>
            <li>Програмният код не е достъпен за редактиране, освен ако не го отключите. Това предотвратява възможността изчислителните формули да бъдат повредени случайно от неопитен потребител.</li>
        </ul>
        <p>Може да ограничите изцяло достъпа до програмния код, като запишете файла в "<b>*.cpdz</b>" формат. След това, вече няма да може да отключите програмния код, нито който и да е друг потребител. Освен това, за разлика от "<b>*.cpd</b>" файла, не може да използвате и външен текстов редактор, защото файлът е кодиран в двоичен формат. Така може да защитите програмния си код от копиране, преглеждане и редактиране.</p>
        <p>Освен в декларации на променливи, може да поставяте символа "<b>?</b>" навсякъде в програмния код. Например:
        <p style="margin-left: 2em;">2 + ?</p>
        <p>Когато го компилирате до формуляр, програмата ще постави поле за попълване на мястото на въпросителния знак:</p>
        <p style="margin-left: 2em;">2 + <input type="text" size="2"></p>
        <p>След това може да въведете стойност и да изчислите резултата. Този подход не е препоръчителен за сложни задачи, защото структурата на програмата става неясна и трудно разбираема за потребителя.</p>

        <h4>Потребителски интерфейс с Html и CSS</h4>
        <p>Освен текстови полета, може да използвате и по-сложни елементи за потребителски интерфейс като "<b>select</b>" (падащ списък), "<b>радио</b>" бутони и "<b>отметки</b>". Тъй като цялата записка се форматира като Html документ, може да използвате Html и CSS за тази цел. Calcpad обаче може да чете входни данни само от текстови полета. Затова, всеки друг вид елемент от интерфейса трябва да се привърже към текстово поле. Това става, като поставите текстовото поле във външен Html елемент (paragraph или div) с дадено <b>id</b>. Същото id трябва да зададете като атрибут от тип <b>name</b> или <b>data-target</b> на изходния елемент от интерфейса. След това, съдържанието на value атрибута на изходния елемент ще се попълва автоматично в отправното текстово поле. Може да използвате следния примерен код:</p>
        <p><b>Падащ списък:</b></p>
        <p>Код:</p>
<pre>
&emsp;&emsp;'Изберете опция: &lt;select name="<b class="err">target1</b>"&gt;
&emsp;&emsp;'&lt;option value="11;12"&gt;x1; y1&lt;/option&gt;
&emsp;&emsp;'&lt;option value="21;22"&gt;x2; y2&lt;/option&gt;
&emsp;&emsp;'&lt;option value="31;32"&gt;x3; y3&lt;/option&gt;
&emsp;&emsp;'&lt;/select&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target1</b>"&gt; Стойности:'x = ? {21}','y = ? {22}'&lt;/p&gt;
</pre>
        <p>Резултат:</p>
        <p>&emsp;&emsp;Изберете опция: <select name="target1"> </p>
        <option value="11;12" id="line-3">x1; y1</option>
        <option value="21;22" id="line-4">x2; y2</option>
        <option value="31;32" id="line-5">x3; y3</option>
        </select><br />&emsp;&emsp;... </p>
        <p id="target1">&emsp;&emsp;Стойности: <span class="eq"><var>x</var> = <input type="text" size="2" name="Var" value="21">&#8202;</span> , <span class="eq"><var>y</var> = <input type="text" size="2" name="Var" value="22">&#8202;</span> </p>
        <p><b>Радио бутони:</b></p>
        <p>Код:</p>
<pre>
&emsp;&emsp;'&lt;p&gt;Select: 
&emsp;&emsp;'&lt;input name="<b class="err">target2</b>" type="radio" id="opt1" value="1"/&gt;
&emsp;&emsp;'&lt;label for="opt1"&gt;option 1&lt;/label&gt;
&emsp;&emsp;'&lt;input name="<b class="err">target2</b>" type="radio" id="opt2" value="2"/&gt;
&emsp;&emsp;'&lt;label for="opt2"&gt;option 2&lt;/label&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target2</b>"&gt;Value -'opt = ? {2}'&lt;/p&gt;
</pre>
        <p>Резултат:</p>
        <p>
            &emsp;&emsp;Избери:
            <input name="target2" type="radio" id="opt1" value="1" />
            <label for="opt1">опция 1</label>
            <input name="target2" type="radio" id="opt2" value="2" />
            <label for="opt2">опция 2</label><br />&emsp;&emsp;...
        </p>
        <p id="target2">&emsp;&emsp;<span class="eq"><var>opt</var> = <input type="text" size="2" name="Var" value="2">&#8202;</span> </p>
        <p><b>Отметка:</b></p>
        <p>Код:</p>
<pre>
&emsp;&emsp;'&lt;p&gt;&lt;input name="<b class="err">target3</b>" type="checkbox" id="chk1" value="3"/&gt;
&emsp;&emsp;'&lt;label for="chk1"&gt;Отметка 1&lt;/label&gt;&lt;/p&gt;
&emsp;&emsp;'...
&emsp;&emsp;'&lt;p id="<b class="err">target3</b>"&gt;Стойност -'chk = ? {3}'&lt;/p&gt;
</pre>
        <p>Резултат:</p>
        <p>
            &emsp;&emsp;<input name="target3" type="checkbox" id="chk1" value="3" />
            <label for="chk1">Отметка 1</label><br />&emsp;&emsp;...
        </p>
        <p id="target3">&emsp;&emsp;<span class="eq"><var>chk</var> = <input type="text" size="2" name="Var" value="3">&#8202;</span> </p>
        <p>Както се вижда от първия пример, може да имате няколко стойности в един "value" атрибут, разделени с точка и запетая ";". В този случай, трябва да осигурите съответния брой текстови полета в отправния параграф, където стойностите да бъдат попълнени. Може да копирате горния код, да добавите колкото опции желаете и да въведете собствени надписи и стойности. Може да променяте имена и id-та, но трябва да внимавате да има точно съответствие между изходните имена и отправните id-та и да няма дублиране на id-та.</p>

        <h3 id="TOC_602">Контрол на видимостта</h3>
        <p>Calcpad ни дава възможност да определяме кои части от програмния код да останат видими при генериране на записката и кои да останат скрити. За разлика от условните разклонения, тук скритият код винаги се изпълнява, само където не се показва в записката. Може да използвате следните ключови думи:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Hide</span> - скрива съдържанието след текущия ред;</li>
            <li><span class="cond">#Pre</span> - показва съдържанието само при въвеждането на данни (виж "<a href="#TOC_601">Формуляри за вход на данни</a>" по-долу);</li>
            <li><span class="cond">#Post</span> - показва съдържанието само в резултатите;</li>
            <li><span class="cond">#Show</span> - винаги показва съдържанието (отменя действието на горните три);</li>
        </ul>
        <p>Всяка от ключовите думи по-горе се отразява на съдържанието след текущия ред и отменя действието на предишните. Самата ключова дума никога не се изписва. Може да ги използвате за да скривате дълги и повтаряеми изчисления, които не е необходимо да се виждат. С <span class="cond">#Pre</span> може да добавите указания за попълване на входните данни, а с <span class="cond">#Post</span> да скриете формулите за изчисление в момента на попълване.</p>
        <p>Може също да контролирате видимостта само на формулите, чрез следните ключови думи:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Val</span> - показва само крайния резултат като число;</li>
            <li><span class="cond">#Equ</span> - показва формулата заедно с крайния резултат (по подразбиране);</li>
            <li><span class="cond">#Noc</span> - показва формулата заедно с крайния резултат (no calculations).</li>
        </ul>
        <p>Всяка от горните ключови думи отменя действието на предишната. Може да използвате <span class="cond">#Val</span> когато създавате таблица със стойности, или когато чертаете векторно изображение със SVG.</p>

        <h3 id="TOC_603">Условни разклонения</h3>
        <p>Много често, решението на дадена задача трябва да продължи по различен начин, в зависимост от определени междинни резултати. Calcpad предлага мощно средство за управление на пътя на решението, аналогично на езиците за програмиране. Използва се блок за условно разклонение, който има следния общ вид:</p>
        <ul style="list-style-type:none;">
            <li style="margin-left:24px;"><span class="cond">#If</span> <b>условие1</b></li>
            <li style="margin-left:48px;">текст ако е изпълнено условие1</li>
            <li style="margin-left:24px;"><span class="cond">#Else If</span> <b>условие2</b></li>
            <li style="margin-left:48px;">текст ако е изпълнено условие2</li>
            <li style="margin-left:24px;"><span class="cond">#Else If</span> <b>условие3</b></li>
            <li style="margin-left:48px;">текст ако е изпълнено условие3</li>
            <li style="margin-left:24px;">. . .</li>
            <li style="margin-left:24px;"><span class="cond">#Else</span></li>
            <li style="margin-left:48px;">текст ако никое условие не е изпълнено</li>
            <li style="margin-left:24px;"><span class="cond">#end if</span></li>
        </ul>
        <p>Възможни са и съкратени варианти на този запис, като например:</p>
        <ul style="list-style-type:none;">
            <li style="margin-left:24px;"><span class="cond">#If</span> <b>условие</b></li>
            <li style="margin-left:48px;">текст ако е изпълнено условието</li>
            <li style="margin-left:24px;"><span class="cond">#Else</span></li>
            <li style="margin-left:48px;">текст ако условието не е изпълнено</li>
            <li style="margin-left:24px;"><span class="cond">#end if</span></li>
        </ul>
        <p>или като:</p>
        <ul style="list-style-type:none;">
            <li style="margin-left:24px;"><span class="cond">#If</span> <b>условие</b></li>
            <li style="margin-left:48px;">текст ако е изпълнено условието</li>
            <li style="margin-left:24px;"><span class="cond">#end if</span></li>
        </ul>
        <p>Условното разклонение влияе не само върху последователността на решение, но и върху съдържанието на записката като текст. Символът "#" трябва да е първият на реда. На мястото на <b>условие</b> трябва да стои валиден аритметичен израз. Обикновено се използва сравнение като "<span class="cond">#If</span> <var>a</var> &lt; 0", но не е задължително. Ако изразът върне ненулева стойност, условието се счита за изпълнено. Ако резултатът е нула, условието не е изпълнено. За нула се приема резултат, който е &le; 0.00000001.</p>
        <p>Нека да разгледаме отново примера за решаване на квадратно уравнение, даден по-горе. Ако въведем "<var>c</var> = 5", дискриминантата ще бъде по-малка от нула и ще се получи резултат <span class="err">NaN</span>. Това не е много интелигентен начин за завършване на една програма. Може обаче да направим така, че ако "<var>D</var> &lt; 0" да изписва разбираемо съобщение, а ако не е, тогава да изчислява корените. Това може да стане с условно разклонение, както е показано на схемата:</p>
        <p><img alt="Sample2" width="800" src="Images/Sample2.bg.png"></p>

        <h3 id="TOC_604">Блокове за цикли</h3>
        <p>Calcpad има възможност за циклично изпълнение на част от програмния код. За тази цел, трябва да го поставите в блок за цикъл ("<b>repeat-loop</b>"), както следва:</p>
        <ul style="list-style-type:none;">
            <li><span class="cond">#Repeat</span> <var>n</var></li>
            <li style="margin-left: 2em;">Код, който се изпълнява циклично</li>
            <li><span class="cond">#Loop</span></li>
        </ul>
        <p>Символът <var>n</var> по-горе показва броя на циклите. На мястото на <var>n</var>, може да поставите число, променлива или всякакъв валиден израз. Ако резултатът от изчисляването на израза не е цяло число, ще се закръгли до най-близкото. Може да излезете преждевременно от тялото на блока, като вмъкнете ред със съдържание <span class="cond">#Break</span>. Това ще има смисъл само, ако добавите и условие, което трябва бъде удовлетворено. В противен случай, програмата ще напуска цикъла още при първата итерация и на практика няма да има никакъв цикъл. Типичен блок с условно прекъсване "<b>repeat-break-loop</b>" изглежда както следва:</p>
        <ul style="list-style-type:none;">
            <li><code class="cond">#Repeat</code></li>
            <li style="margin-left: 2em;">Код, който се изпълнява циклично</li>
            <li style="margin-left: 2em;"><code class="cond">#If</code> условие</li>
            <li style="margin-left: 4em;"><code class="cond">#Break</code> или <code class="cond">#Continue</code></li>
            <li style="margin-left: 2em;"><code class="cond">#End if</code></li>
            <li style="margin-left: 2em;">Тук може да сложите още код.</li>
            <li><code class="cond">#Loop</code></li>
        </ul>
        <p>Moже да използвате <code class="cond">#Continue</code> вместо <code class="cond">#Break</code>. Програмата ще пропусне оставащите редове, ще се върне в началото на блока и ще продължи със следващата итерация. Ако сте сигурни, че условието ще се изпълни за разумен брой цикли, може да пропуснете <var>n</var>. За избягване на безкраен цикъл, броят вътрешно е ограничен до 100 000, когато не е посочен изрично.</p>
        <p>Освен за итерационни изчисления, може да използвате цикли и за генериране на повтарящи се текстове от записката (като редове от таблица). Ако искате да скриете повтарящите се изчисления в цикъла, може да използвате директивите за контрол на видимостта (виж предишната точка). Например, може да заградите цикъла с <span class="cond">#Hide</span> и <span class="cond">#Show</span>.</p>

        <h3 id="TOC_605">Интерактивно изпълнение (стъпка-по-стъпка)</h3>
        <p>Може да направите записка, която се изпълнява интерактивно (стъпка по стъпка), като дефинирате точки на прекъсване на определени редове. Това ще позволи на потребителя да прегледа междинните резултати и ако е не необходимо, да въведе допълнителни входни данни. За тази цел, може да използвате някоя от следните ключови думи за прекъсване:</p>
        <ul style="list-style-type:none;">
            <li><code class="cond">#Pause</code> - изчислява и показва записката до текущия ред, след което спира на пауза;</li>
            <li><code class="cond">#Input</code> - генерира формуляр за въвеждане до текущия ред, след което изчаква потребителя да въведе данни и да рестартира решението.</li>
        </ul>
        <p>След като спре на пауза програмата генерира следното съобщение на края на записката:</p>
        <p>&emsp;&emsp;<span class="err">Пауза!</span> Натиснете <b>F5</b> за да <a href="#0" data-text="continue">продължите</a> или <b>Esc</b> за <a href="#0" data-text="cancel">прекъсване</a>.</p>
        <p>Може да продължите изпълнението като натиснете <b>F5</b>, кликнете на линка или натиснете отново бутона <img alt="Play" height="20" src="Images/Play.png">. Може да имате няколко точки на прекъсване в дадена записка, които разделят записката на отделни секции. Когато използвате <code class="cond">#Input</code>, на всеки етап, програмата изчислява резултатите от предишната секция, преди да покаже формуляра за попълване от следващата. По този начин, отделните етапи на изчисление се застъпват, както е показано в следната таблица:</p>
        <p><img alt="Interactive" height="360" src="Images/Interactive.png"></p>
        <p>Освен това, по всяко време, потребителят може да натисне "<b>Pause/Break</b>" или "<b>Ctrl + Alt + P</b>" от клавиатурата и да прекъсне изпълнението. Действието е еквивалентно на срещането на ключова дума <code class="cond">#Pause</code>.</p>

        <h3 id="TOC_606">Модули (Include)</h3>
        <p>Calcpad дава възможност да използвате съдържание от външен файл в дадена записка. Ако имате части от кода, които се повтарят в отделните записки, може да ги организирате в модули и да ги преизползвате многократно. Също така, ако имате по-дълги записки, може да ги разделите на модули за по-лесна поддръжка и обновяване. След това, може да ги включите в основния файл, като използвате следния израз:</p>
        <p><span class="cond">#include</span> <em class="macro">име_на_файл</em></p>
        <p>Името на файла трябва да съдържа пълния път до локален за компютъра файл. По изключение, ако файлът се намира в същата директория, може да посочите само името (с разширението).</p>
        <p>По подразбиране, Calcpad ще включи цялото съдържание на външния модул. Може обаче да забраните включването на отделни части от съдържанието, като ги направите локални. За да започнете "локална" секция в модул, добавете нов ред с ключова дума <span class="cond">#local</span>. За край на "локална" секция (начало на "глобална"), добавете ред със съдържание <span class="cond">#global</span>. Calcpad поддържа множество нива на включване. Това означава, че включения файл може на свой ред да включва други и т.н.</p>

        <h3 id="TOC_607">Макроси и текстови променливи</h3>
        <p> Макросите и текстовите променливи представляват удобен начин за организация на съдържанието в самия файл и избягване на повтарящ се код. Те могат да бъдат едноредови и многоредови. За разлика от текстовите променливи, макросите имат и параметри. Може да ги дефинирате, като използвате следните изрази:
        <p>Едноредова текстова променлива:</p>
        <p>
            &emsp;&emsp;<span class="cond">#def</span>
            <em class="macro">variable_name$</em> <span class="o">=</span> <em>съдържание</em>
        </p>
        <p>Многоредова текстова променлива:</p>
        <p>
            &emsp;&emsp;<span class="cond">#def</span> <em class="macro">variable_name$</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>съдържание ред 1</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>съдържание ред 2</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>...</em><br />
            &emsp;&emsp;<span class="cond">#end def</span>
        </p>
        <p>Едноредов макрос:</p>
        <p>
            &emsp;&emsp;<span class="cond">#def</span>
            <em class="macro">macro_name$</em><span class="b">(</span><em class="macro">param1$</em><span class="o">;</span> <em class="macro">param2$</em><span class="o">;</span>...<span class="b">)</span> <span class="o">=</span> <em>съдържание</em>
        </p>
        <p>Многоредов макрос:</p>
        <p>
            &emsp;&emsp;<span class="cond">#def</span> <em class="macro">macro_name$</em><span class="b">(</span><em class="macro">param1$</em><span class="o">;</span> <em class="macro">param2$</em><span class="o">;</span>...<span class="b">)</span><br />
            &emsp;&emsp;&emsp;&emsp;<em>съдържание ред 1</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>съдържание ред 2</em><br />
            &emsp;&emsp;&emsp;&emsp;<em>...</em><br />
            &emsp;&emsp;<span class="cond">#end def</span>
        </p>
        <p>Имената на текстовите променливи, макросите и параметрите могат да съдържат малки и главни латински букви и долна черта "_". Те трябва задължително да завършват със символа "$". Съдържанието им на практика може да бъде всякакъв текстов низ. Не е задължително да представлява валиден израз на Calcpad, тъй като на този етап не се обработва от синтактичния анализатор. Единствено, не е разрешено да включва дефинициите на други макроси и текстови променливи. Ако те обаче са дефинирани предварително, може да вмъквате референции към тях. Също така, настоящата версия все още не поддържа полета за вход на данни "?" в макроси. Това ще бъде добавено в следващите версии. Може да използвате <span class="cond">#include</span> в макроси, но само ако реферираните файлове не съдържат дефиниции на други макроси.</p>
        <p>След като дадена текстова променлива е дефинирана, може да я използвате навсякъде в кода, като напишете  нейното име (с "$" накрая). Това важи и за макросите, като допълнително трябва да посочите и стойностите на параметрите. Макросите и текстовите променливи се обработват на предварителен етап. Тяхното съдържание се замества в кода, преди да започне действителната му изчисляване. Като резултат, се генерира междинен, "разгънат" код. Може да го прегледате като включите опцията "<b>Разгънат код</b>" под прозореца с резултати.</p>

        <p>Ако по време на обработката на макросите възникнат грешки, се показва разгънатия код, с информация за грешките. Номерата на редовете в съобщенията за грешка, реферират към първоначалния код. Ако предварителната обработка приключи успешно, разгънатия код се транслира и изпълнява както обикновено. Ако възникнат грешки на този етап, те се показват в съдържанието на изходната записка. Тук, номерата на редовете реферират към разгънатия код. Може да отидете на съответния ред, като кликнете линка върху номера на реда.</p>

        <h2 id="TOC_700">Резултати</h2>
        <p>За да видите резултатите, първо трябва да стартирате решението, като натиснете "<b>F5</b>" или бутона <img alt="Play" height="20" src="Images/Play.png">. Те се показват в прозореца "<b>Резултати</b>". В него не може да редактирате съдържанието, но може да го маркирате, копирате или отпечатвате. За целта, може да използвате лентата с бутони вдясно над прозореца. С натискане на десен бутон върху резултатите се отваря контекстно меню с допълнителни функции. Подробно описание е дадено по-нататък в настоящото ръководство.</p>
        <p>От версия 6.5.3 нататък, може да използвате и режим на автоматично преизчисляване "☑ <b>AutoRun</b>". Когато опцията е включена, резултатите се обновяват всеки път, когато промените текста и преминете на нов ред. Ако искате да синхронизирате резултатите с кода, може да натиснете "<b>Ctrl + Enter</b>". При това, прозорецът с резултати се превърта така, че да съвпадне с текущия ред в кода. Същото се получава и като кликнете два пъти с мишката в текстовия редактор.</p>

        <h3 id="TOC_701">Заместване</h3>
        <p>Calcpad може да замества стойностите на параметрите и да ги показва във формулите преди крайния резултат:</p>
        <p style="margin-left: 2em;"><var>x</var><sub>1</sub> = <span class="dvc"> -<var>b</var> – <span class="root">√</span><span class="ovr"><var>D</var></span><span class="dvl"></span>2·<var>a</var></span> = <span class="dvc"> -3 – <span class="root">√</span><span class="ovr">89</span><span class="dvl"></span>2·4</span> = -1.55</span></p>
        <p>За целта трябва да е включена опцията "<b>Заместване</b>" в долния край на екрана. Така решението става лесно за проследяване и проверка след разпечатване. Това понякога е необходимо, ако записката трябва да бъде преглеждана от контролен инженер, преподавател и др. Това е предимство спрямо електронните таблици, където реалните изчислителни формули са скрити в клетките на таблицата.</p>
        <p>Ако желаете да не се прави заместване, трябва да изключите опцията. Тогава резултатът се показва директно след формулата:</p>
        <p style="margin-left: 2em;"><var>x</var><sub>1</sub> = <span class="dvc"> -<var>b</var> – <span class="root">√</span><span class="ovr"><var>D</var></span><span class="dvl"></span>2·<var>a</var></span> = -1.55</span></p>
        <p>Ако поставите след това курсора на мишката над дадена променлива, ще се покаже нейната стойност като "балонче" горе вдясно от нея.</p>
        <p>
            Ако уравнението стане прекалено дълго за да се събере на един ред, може да контролирате начина, по който то да бъде форматирано, като използвате следните ключови думи:<br />
            &emsp;&emsp;<span class="cond">#split</span></a> - уравнението се пренася на нов ред след символа "=";<br />
            &emsp;&emsp;<span class="cond">#wrap</span></a> - уравнението се пренася на нов ред, в края на текущия (по подразбиране).<br />



            <h3 id="TOC_702">Закръгляване</h3>
        <p>Закръгляването на резултатите се дефинира чрез броя цифри след десетичната точка <var>k</var>. Въвежда се в полето "Закръглявай на […] цифри" в долната част на екрана. Стойността на <var>k</var> може да бъде между "0" и "15". Ако въведете "0", резултатите ще се закръгляват към цели числа. Ако въведете стойност, по-малка от "0" или по-голяма от "15", ще се възприеме съответната гранична стойност.</p>
        <p>При закръгляването има и някои допълнителни особености. Ако се получи число, което е по-малко от 10<sup>-<var>k</var></sup>, тогава в резултата ще има само нули. Поради това, в Calcpad се използва интелигентно закръгляване. Ако след закръгляването остават по-малко от <var>k</var> значещи цифри, се изписват <var>k</var> значещи цифри. Ако при това се получат повече от три нули след десетичната точка, то програмата преминава в представяне с плаваща запетая, като отново оставя <var>k</var> значещи цифри. Иначе, броенето на нулите след десетичната точка става трудно. Когато общия брой цифри стане по-голям от 2<var>k</var>, дробната част се отрязва. Така остават 2<var>k</var> значещи цифри като същевременно записката става по-прегледна. По-долу са дадени различни примери, получени при закръгляване до третия знак (<var>k</var> = 3).</p>
        <ul style="list-style-type:none;">
            <li>0.000001∙<var>π</var> = 3.14E-06</li>
            <li>0.001∙<var>π</var> = 0.00314</li>
            <li>0.1∙<var>π</var> = 0.314</li>
            <li>1∙<var>π</var> = 3.142</li>
            <li>1000∙<var>π</var> = 3141.59</li>
            <li>1000000∙<var>π</var> = 3141593</li>
        </ul>
        <p>Всичко това се отнася само за показването на числата в текста на записката. Вътрешно, всички стойности се съхраняват с максималния възможен брой значещи цифри. По този начин се извършват и самите изчисления. Затова, ако отпечатате записката и повторите изчисленията на ръка, може да получите малка разлика в резултата. Това е защото използвате закръглените стойности, вместо действителните.</p>
        <p>Може да предефинирате глобалните настройки за закръгляване за дадена част от записката чрез ключова дума <code class="cond">#Round</code> <var>n</var>, където <var>n</var> е желания брой цифри след десетичната точка (от "0" до "15").</p>

        <h3 id="TOC_703">Форматиране</h3>
        <p>Calcpad не само изчислява въведените формули. Той може да генерира автоматично и изчислителна записка, директно от програмния код. За целта се използва Html формат, който се поддържа от много софтуерни продукти и позволява да публикувате резултатите директно в Интернет. Използват се подходящи шрифтове и цветове, горен индекс за степенуване и символ за коренуване, което придава професионален изглед на формулите. Има два възможни режима за форматиране на изрази, което може да изберете от съответните настройки в долната част на екрана:</p>
        <ul>
            <li><b>фигурни</b> - операторът за деление се показва с хоризонтална дробна черта, като делителя и делимото ще бъдат разположени едно над друго;</li>
            <li><b>линейни</b> - операторът за деление се показва с наклонена черта, като всички символи във формулата са подредени на един ред.</li>
        </ul>
        <p>Относно останалите параметри, се прилагат следните общи правила:</p>
        <ul>
            <li>Интервалите между символите се управляват автоматично, независимо от въведените в програмния код.</li>
            <li>Променливите се форматират като <var>курсив</var>, както и <i>мерните единици</i>, но с различен цвят.</li>
            <li>Операторът за умножение"*" се замества със символа "∙".</li>
            <li>Операторът за степенуване "^" се форматира като горен индекс.</li>
            <li>Първата долна черта в име на функция или променлива "_" се форматира като долен индекс.</li>
            <li>Функцията <b>sqr</b> се замества със символа за коренуване "<span class="root">√</span><span class="ovr">&emsp;</span>".</li>
        </ul>
        <p>По-долу са показани различни примери за форматиране на изрази:</p>
        <table style="margin-left:24px; max-width: 300px;" border="1">
            <thead>
                <tr>
                    <th style="width:50%">Текст</th>
                    <th>Html</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>x&emsp;&emsp;+&emsp;&emsp;3</code></td>
                    <td><var>x</var> + 3</td>
                </tr>
                <tr>
                    <td><code>x-3</code></td>
                    <td><var>x</var> – 3</td>
                </tr>
                <tr>
                    <td><code>3*x</code></td>
                    <td>3∙<var>x</var></td>
                </tr>
                <tr>
                    <td><code>(x + 1)/3</code></td>
                    <td>(<var>x</var> + 1)/3 или <span class="dvc"><var>x</var> + 1<span class="dvl"></span>3</span></td>
                </tr>
                <tr>
                    <td><code>x+3 * y</code></td>
                    <td><var>x</var> + 3∙<var>y</var></td>
                </tr>
                <tr>
                    <td><code>sqr(x+3)</code></td>
                    <td><span class="root">√</span><span class="ovr"><var>x</var> + 3</span></td>
                </tr>
                <tr>
                    <td><code>x_1^3</code></td>
                    <td><var>x</var><sub>1</sub><sup>3</sup></td>
                </tr>
                <tr>
                    <td><code>sin(x)</code></td>
                    <td><b>sin</b>(<var>x</var>)</td>
                </tr>
            </tbody>
        </table>
        <p>Html форматирането не е само за красота. Това прави записката по-лесна за четене и проверка от обикновен текст. Може да вмъкнете и допълнителен Html код в коментарите което ще се отрази на окончателния и вид. Така може да вграждате Calcpad записки в уеб сайтове и да създавате професионални уеб приложения, които да се ползват само онлайн. За целта обаче ви трябва облачната версия на Calcpad, която да извършва необходимите изчисления.</p>

        <h3 id="TOC_704">Мащабиране</h3>
        <p>Може да увеличавате и намалявате размера на текста в прозореца с резултати, като задържите "<b>Ctrl</b>" и завъртите колелото на мишката. Завъртане напред увеличава, а завъртане назад - намалява височината на текста.</p>

        <h3 id="TOC_705">Запис на резултатите във файл</h3>
        <p>Често се налага да поддържате електронен архив на направените изчисления. За целта, може да запишете резултатите в <b>Html</b> файл. Този файл няма да може да се редактира с Calcpad, но може да се разглежда или отпечатва. Може да го пренесете навсякъде и да го отворите с всеки един уеб браузър или офис пакет. Записването става като натиснете бутона <img alt="Save" height="20" src="Images/Save.png"> вдясно над прозореца с резултати. Изберете име на файла и натиснете "<b>Save</b>".</p>
        <p>Добра алтернатива на <b>Html</b> файловете е отпечатването като <b>pdf</b> документ. Така също може да запазите архив на вече решени задачи. За целта, първо трябва да инсталирате pdf принтер на вашия компютър. Може да ползвате някой от многото безплатни pdf принтери, които се намират в Интернет. Самото отпечатване не е по-различно от всеки друг стандартен принтер. Описание на процедурата в Calcpad е дадено в следващата точка.</p>

        <h3 id="TOC_706">Отпечатване</h3>
        <p>Може да отпечатате резултатите на принтер, като натиснете бутона <img alt="PrintPreview" height="20" src="Images/PrintPreview.png"> над прозореца се резултати. Първоначално ще се покаже диалог за преглед на страниците:</p>
        <p><img alt="Sample5" Width="680" src="Images/Sample5.bg.png"></p>
        <p>Тук може допълнително да настроите ориентацията до границите, като натиснете бутона <img alt="Page Setup" height="20" src="Images/PageSetup.png">. След това натиснете <img alt="Print" height="20" src="Images/Print.png"> за да преминете към отпечатване. На екрана ще се появи стандартен диалог за избор на принтер. Изберете предпочитания принтер и натиснете "<b>Print</b>".</p>
        <p><img alt="PrintDialog" Width="550" src="Images/PrintDialog.png"></p>
        <p>Отпечатването в Calcpad използва вградената функционалност на Windows и Edge. В зависимост от версиите, които използвате, горните екрани може да изглеждат по различен начин на вашия компютър. Алтернативно, може да кликнете с десен бутон в прозореца с резултати и да изберете "<b>Print preview…</b>" от контекстното меню, което ще се покаже на екрана. Това ще Ви отведе отново до преглед на страниците, но ако искате да го пропуснете и направо да отидете към отпечатване, изберете "<b>Print</b>".</p>

        <h3 id="TOC_707">Копиране</h3>
        <p>Може да копирате всички резултати наведнъж, като натиснете бутона <img alt="Copy" height="20" src="Images/Copy.png"> над прозореца с резултати. Те ще се запазят временно в системния буфер (Clipboard), откъдето може да ги поставите в друга програма. Ако тя поддържа Html, като например Word, форматирането ще се запази. В противен случай, съдържанието ще се прехвърли само като текст.</p>

        <h3 id="TOC_708">Изход към Word</h3>
        <p>Може да отворите записката директно в <b>Word</b> като натиснете бутона <img alt="Word" height="20" src="Images/Word.png">. Той трябва да е инсталиран на Вашия компютър, но не е необходимо да бъде отворен предварително. Този начин е по-лесен от копирането и дава някои допълнителни възможности. Ако резултатите са получени с настройката за "Фигурни" формули, Calcpad ще генерира директно "<b>*.docx</b>" файл и ще Ви подкани да го запишете. След това, ще го отвори автоматично. Това е естествения файлов формат в последните версии на <b>Word</b>. Ако вместо <b>Word</b>, ползвате <b>Open Office</b> или <b>Libre office</b>, файлът ще се отвори със съответната програма. Ако няма инсталиран текстов редактор на компютъра, може да отидете в съответната папка и да го отворите ръчно в последствие. Формулите се записват във файла като <b>MathType</b> обекти и са достъпни за редактиране в среда на Word. Част от <b>Html</b> форматирането е възможно да се загуби. Ще се запазят обаче схеми, таблици и най-често срещаните елементи. Ако сте избрали настройката за "Линейни" формули, Calcpad ще използва <b>Html</b> формат, за пренасяне на данните в <b>Word</b>. При това, по-голяма част от форматирането ще се запази, но формулите ще бъдат вмъкнати като част от текста.</p>

        <h3 id="TOC_709">Изход към PDF</h3>
        <p>Може да запишете резултатите като <b>pdf</b> файл директно от Calcpad. Това става като като натиснете бутона <img alt="Pdf" height="20" src="Images/Pdf.png">. За да го отворите, трябва да имате инсталиран софтуер за визуализация на pdf файлове. Генерирането на pdf файла става винаги във формат A4.</p>

        <h2 id="TOC_800">Работа с файлове</h2>
        <p>Може да запишете входните данни във файл, след което да ги използвате  многократно. Програмата поддържа файлове с разширения "<b>*.txt</b>", "<b>*.cpd</b>" и "<b>*.cpdz</b>. Програми, съдържащи форми за входни данни трябва да се записват като "<b>*.cpd</b>" или "<b>*.cpdz</b>", а простите текстови скриптове могат да се записват и като "<b>*.txt</b>". Разширенията "<b>*.cpd</b>" и "<b>*.cpdz</b>" са асоциирани с Calcpad и могат да се отварят директно с двойно кликване върху самия файл. Основната разлика между двете е, че "<b>*.cpd</b>" файлът е в текстов формат, където програмния код е достъпен за разглеждане, редактиране и копиране, а "*<b>.cpdz</b>" е двоичен и може само да се стартира и изпълнява. Ако желаете да предоставите вашите записки за ползване от трети лица, без да имат достъп до изчислителния код, използвайте този формат. Винаги пазете обаче и копие в "<b>*.cpd</b>" формат с оглед на бъдещи промени и отстраняване на грешки.</p>

        <h3 id="TOC_801">Нов файл</h3>
        <p>Може да стартирате нов файл като кликнете бутона <img alt="New" height="20" src="Images/New.png">. Това изчиства името на файла и всички входни данни. Ако текущият файл не е записан, ще получите покана да го запишете.</p>
        <p><img alt="PromptSave" height="160" src="Images/PromptSave.bg.png"></p>
        <p>Ако отговорите с "<b>Yes</b>", ще се отвори диалогът за запис на файл. Изберете име и натиснете "<b>Save</b>". Така ще запазите текущите данни, преди да бъдат изчистени. Ако отговорите с "<b>Cancel</b>", ще се откажете от командата и няма да се отвори нов файл. Текущото състояние ще остане без промяна.</p>

        <h3 id="TOC_802">Отваряне на файл</h3>
        <p>Отварянето на съществуващ файл от диска става с бутона <img alt="Open" height="20" src="Images/Open.png">. Показва се диалог за избор на файл. По подразбиране се виждат файловете с разширение "*.cpd". Ако търсите "*.txt" файл, трябва да превключите типа на файла в долната част на диалога. След това намерете желания файл, кликнете два пъти върху него или го маркирайте и натиснете "<b>Open</b>". Данните от файла ще се заредят в прозореца на Calcpad, а името му ще се изпише заглавната лента най-горе.</p>

        <h3 id="TOC_803">Запис</h3>
        <p>За да запишете текущия файл, трябва да кликнете бутона <img alt="Save" height="20" src="Images/Save.png">. Ако файлът не е бил записван досега, на екрана ще се появи диалог за избор на файл. Изберете път и име на файла и натиснете "<b>Save</b>". В противен случай, ще бъде презаписан на текущото място.</p>

        <h3 id="TOC_804">Запис като…</h3>
        <p>Може да запишете файла и с ново име като изберете менюто "<b>Файл/Запис като…</b>". На екрана ще се появи диалог за избор на файл. Изберете път и име на файла и натиснете "<b>Save</b>".</p>
        <hr />
        <p>Автор: инж. Неделчо Ганчовски. Последна промяна на 23.10.2024 г.</p>
    </div>
    <script src="jquery-3.6.3.min.js"></script>
    <script>
        if (window.jQuery) {

            function getTargetId(element) {
                var id = $(element).attr("name");
                if (id != null && id.length > 0)
                    return id;

                return $(element).data("target");
            }

            function getValue(id, source) {
                var value = "";
                var target = $("#" + id + " input");
                var domObj = target.get(0);
                if (domObj == null || domObj.Length == 0) {
                    target = $("#" + id + " .eq u");
                    target.each(function () {
                        value += $(this).text() + ";";
                    });
                    $(source).prop('disabled', true);
                }
                else {
                    target.each(function () {
                        value += $(this).val() + ";";
                    });
                }
                if (value.length > 1) {
                    value = value.slice(0, -1);
                }
                return value;
            }

            function Toggle(button) {
                var list = $("#list" + button.attr("id").substring(6));
                if (list.css("display") == "none") {
                    list.css("display", "list-item");
                    button.html("&minus;");
                }
                else {
                    list.css("display", "none");
                    button.html("+");
                }
            }

            $(document).ready(function () {

                $("#Units").change(function () {
                    $(".Units").text($(this).val());
                });

                $(".exp").click(function () {
                    Toggle($(this));
                });

                $(".fold > :first-child").click(function () {
                    if ($(this).pсаnt().hasClass("fold")) {
                        $(this).pсаnt().removeClass("fold").addClass("unfold");
                    }
                    else {
                        $(this).pсаnt().removeClass("unfold").addClass("fold");
                    }
                });

                $("select").each(function (index) {
                    if ($(this).prop("id") != "Units") {
                        var id = getTargetId(this);
                        if (id != null && id.length > 0) {
                            var value = getValue(id, this);
                            $(this).val(value);
                        }
                    }

                });

                $("select").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            var values = $(this).val().split(";");
                            target.each(function (index) {
                                $(this).val(values[index]);
                            });
                        }
                    }
                });

                $("input:radio, input:checkbox").each(function (index) {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var value = getValue(id, this);
                        $(this).prop("checked", $(this).val() == value);
                    }
                });

                $("input:radio, input:checkbox").change(function () {
                    var id = getTargetId(this);
                    if (id != null && id.length > 0) {
                        var target = $("#" + id + " input");
                        if (target != null) {
                            if ($(this).prop("checked")) {
                                var values = $(this).val().split(";");
                                target.each(function (index) {
                                    $(this).val(values[index]);
                                });
                            }
                            else if ($(this).prop("type") == "checkbox") {
                                target.each(function () {
                                    $(this).val("0");
                                });
                            }
                        }
                    }
                });

                $(".money").each(function () { $(this).text(Number(($(this).text())).toFixed(2)); });

                $(window).scroll(function () {
                    if ($(".menu").is(":visible")) {
                        var scrollTop = $(window).scrollTop();
                        var id;
                        var min = 1e20;
                        $("h2, h3").each(function () {
                            var d = scrollTop - $(this).offset().top + 50;
                            if (d > 0 && Math.abs(d) < min) {
                                console.log(d);
                                min = d;
                                id = $(this).attr("id");
                            }
                        });
                        $(".active").removeClass("active");
                        var element = $("a[href$='#" + id + "']")
                        if (!element.is(":visible")) {
                            $(".exp").html("+");
                            $(".menu li ul").css("display", "none");
                            var b = "#button" + id.substring(4, id.length - 2);
                            Toggle($(b));
                        }
                        element.addClass("active");
                    }
                });
            });
        }
    </script>
</body>
</html>