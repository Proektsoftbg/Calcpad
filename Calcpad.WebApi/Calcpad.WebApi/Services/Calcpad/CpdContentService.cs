using System;
using System.Text;
using System.Text.RegularExpressions;
using Calcpad.Document;
using Calcpad.Document.Archive;
using Calcpad.Document.Core.Segments;
using Calcpad.WebApi.Configs;
using Calcpad.WebApi.Models;
using Calcpad.WebApi.Models.Base;
using Calcpad.WebApi.Utils.Calcpad;
using Calcpad.WebApi.Utils.Encrypt;
using Calcpad.WebApi.Utils.Web.Exceptions;
using Calcpad.WebApi.Utils.Web.Service;
using DocumentFormat.OpenXml.Drawing;
using HtmlAgilityPack;
using MongoDB.Driver.Linq;
using Path = System.IO.Path;

namespace Calcpad.WebApi.Services.Calcpad
{
    /// <summary>
    /// calcpad file content service
    /// </summary>
    /// <param name="db"></param>
    /// <param name="cycleDetector"></param>
    /// <param name="storageService"></param>
    public class CpdContentService(
        MongoDBContext db,
        CycleDetectorService cycleDetector,
        CpdStorageService storageService
    ) : IScopedService
    {
        /// <summary>
        /// operations:
        /// 1. set meta info to file head
        /// 2. resolve include path to server path
        /// 3. resolve read from path to server path
        /// resolve include path to server path
        /// </summary>
        /// <param name="fullPath"></param>
        /// <param name="cpdUid"></param>
        /// <returns></returns>
        public async Task<List<string>> SetMeataInfoAndResolvePath(string fullPath, string cpdUid)
        {
            var cpdReader = CpdReaderFactory.CreateCpdReader(fullPath);

            var replacingRows = new List<CpdLine>();
            // include lines
            var includes = cpdReader.GetIncludeLines();
            if (includes.Count > 0)
            {
                // replace include path to server path
                var uIds = includes.Select(x => x.Uid).ToList();

                // find all include files
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();

                // replace uid to service path
                foreach (var include in includes.OrderBy(x => x.RowIndex))
                {
                    var includeFile = cpdObjects.FirstOrDefault(x => x.UniqueId == include.Uid);
                    if (includeFile != null)
                    {
                        include.SetFilePath(includeFile.FullName);
                        replacingRows.Add(include);
                    }
                }
            }

            // read lines
            var readLines = cpdReader.GetReadLines();
            if (readLines.Count > 0)
            {
                var uIds = readLines.Select(x => x.Uid).ToList();
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();
                foreach (var readLine in readLines)
                {
                    // add data source from uid
                    var readFile = cpdObjects.FirstOrDefault(x => x.UniqueId == readLine.Uid);
                    if (readFile != null)
                    {
                        readLine.SetFilePath(readFile.FullName);
                        replacingRows.Add(readLine);
                    }
                }
            }

            // add header, example:
            // #local '<meta>
            // #hide
            // 'id:1
            // 'description: this is auto generated by calcpad web api, do not edit it
            // #show
            // #global '</meta>
            var header = new List<string>
            {
                "#local '<meta>",
                "#hide",
                "'uid:" + cpdUid,
                "'description: this is auto generated by calcpad web api, do not edit it",
                "#show",
                "#global '</meta>",
            };
            var headerInfo = string.Join(Environment.NewLine, header) + Environment.NewLine;

            var content = CpdWriter.BuildCpdContent(cpdReader.ReadStringLines(), replacingRows);

            // upsert meta info at head
            const string startMarker = "#local '<meta>";
            const string endMarker = "#global '</meta>";
            var startIndex = content.IndexOf(startMarker, StringComparison.OrdinalIgnoreCase);
            if (startIndex >= 0)
            {
                var endIndex = content.IndexOf(
                    endMarker,
                    startIndex,
                    StringComparison.OrdinalIgnoreCase
                );
                if (endIndex >= 0)
                {
                    // remove old meta info
                    content = content.Remove(startIndex, endIndex + endMarker.Length - startIndex);
                }
                else
                {
                    content = content.Remove(startIndex, 1);
                }
            }

            var fileWriter = CpdWriterFactory.CreateCpdWriter();
            fileWriter.WriteFile(fullPath, headerInfo + content);

            // check cycles
            var includeIds = includes
                .Select(x => x.Uid)
                .Where(x => !string.IsNullOrEmpty(x))
                .ToList();
            var hasCycle = await cycleDetector.HasCycleAsync(cpdUid, includeIds);
            if (hasCycle)
            {
                throw new KnownException("include cycle detected");
            }

            return includeIds;
        }

        /// <summary>
        /// get file access uri
        /// if public file, return public stream uri
        /// if private file, return service path with uid
        /// </summary>
        /// <param name="fileObject"></param>
        /// <returns></returns>
        public string GetFileAccessUri(CalcpadFileModel fileObject)
        {
            if (!fileObject.IsCpd)
            {
                return $"api/v1/calcpad-file/stream/public/ids/{fileObject.Id}?uid={fileObject.UniqueId}&name={Path.GetFileName(fileObject.ObjectName)}";
            }

            return $"{fileObject.FullName}'?uid={fileObject.UniqueId}";
        }

        /// <summary>
        /// simplify html, remain row or p element which contains input,select,h1-h6
        /// </summary>
        /// <param name="originHtml"></param>
        /// <returns></returns>
        public string SimplifyHtml(string originHtml)
        {
            if (string.IsNullOrEmpty(originHtml))
            {
                return string.Empty;
            }

            var doc = new HtmlDocument()
            {
                OptionFixNestedTags = true,
                OptionAutoCloseOnEnd = true
            };
            doc.LoadHtml(originHtml);

            // process conditional blocks (#if, #else, #else if, #end if)
            var conditionWrapper = new ConditionBlockWrapper(doc);
            conditionWrapper.ProcessConditionalBlocks();

            // Precompute subtree info once to avoid repeated recursive scans.
            var containsSupportTagMap = BuildContainsSupportTagMap(doc.DocumentNode);

            // Collect only top-level retained nodes in a single traversal.
            var topLevelNodes = new List<HtmlNode>();
            var stack = new Stack<(HtmlNode Node, bool HasRetainedAncestor)>();
            for (var i = doc.DocumentNode.ChildNodes.Count - 1; i >= 0; i--)
            {
                stack.Push((doc.DocumentNode.ChildNodes[i], false));
            }

            while (stack.Count > 0)
            {
                var (node, hasRetainedAncestor) = stack.Pop();
                if (node.NodeType != HtmlNodeType.Element)
                {
                    continue;
                }

                var isRetained = ShouldRetainNode(node, containsSupportTagMap);
                if (isRetained && !hasRetainedAncestor)
                {
                    topLevelNodes.Add(node);
                    // This node becomes the retained ancestor; no need to search deeper for top-level nodes.
                    continue;
                }

                if (hasRetainedAncestor)
                {
                    // Any descendants can't be top-level retained.
                    continue;
                }

                for (var i = node.ChildNodes.Count - 1; i >= 0; i--)
                {
                    stack.Push((node.ChildNodes[i], false));
                }
            }

            // create new document with only the top-level nodes to keep
            var newDoc = new HtmlDocument();
            foreach (var node in topLevelNodes)
            {
                var cloned = node.Clone();
                CleanPTagsRecursively(cloned);
                newDoc.DocumentNode.AppendChild(cloned);
            }

            // if empty, return origin
            if (newDoc.DocumentNode.ChildNodes.Count == 0)
            {
                return originHtml;
            }
            return newDoc.DocumentNode.OuterHtml;
        }

        private static void CleanPTagsRecursively(HtmlNode root)
        {
            if (root == null)
                return;

            // Compute subtree maps once, then prune <p> tags in O(n).
            var containsSupportTagMap = BuildContainsSupportTagMap(root);
            var subtreeHasRetainableMap = BuildSubtreeHasRetainableMap(root, containsSupportTagMap);

            var pNodes = root.Descendants()
                .Where(n =>
                    n.NodeType == HtmlNodeType.Element
                    && string.Equals(n.Name, "p", StringComparison.OrdinalIgnoreCase)
                )
                .ToList();

            foreach (var p in pNodes)
            {
                if (
                    containsSupportTagMap.TryGetValue(p, out var containsSupport) && containsSupport
                )
                    continue;

                if (subtreeHasRetainableMap.TryGetValue(p, out var hasRetainable) && hasRetainable)
                    continue;

                p.Remove();
            }
        }

        private static Dictionary<HtmlNode, bool> BuildContainsSupportTagMap(HtmlNode root)
        {
            var map = new Dictionary<HtmlNode, bool>();
            var stack = new Stack<(HtmlNode Node, bool Visited)>();
            stack.Push((root, false));

            while (stack.Count > 0)
            {
                var (node, visited) = stack.Pop();
                if (!visited)
                {
                    stack.Push((node, true));
                    for (var i = node.ChildNodes.Count - 1; i >= 0; i--)
                    {
                        stack.Push((node.ChildNodes[i], false));
                    }
                    continue;
                }

                if (node.NodeType != HtmlNodeType.Element)
                {
                    map[node] = false;
                    continue;
                }

                var containsSupport = _supportTags.Contains(node.Name);
                foreach (var child in node.ChildNodes)
                {
                    if (map.TryGetValue(child, out var childContains) && childContains)
                    {
                        containsSupport = true;
                        break;
                    }
                }
                map[node] = containsSupport;
            }

            return map;
        }

        private static Dictionary<HtmlNode, bool> BuildSubtreeHasRetainableMap(
            HtmlNode root,
            Dictionary<HtmlNode, bool> containsSupportTagMap
        )
        {
            var map = new Dictionary<HtmlNode, bool>();
            var stack = new Stack<(HtmlNode Node, bool Visited)>();
            stack.Push((root, false));

            while (stack.Count > 0)
            {
                var (node, visited) = stack.Pop();
                if (!visited)
                {
                    stack.Push((node, true));
                    for (var i = node.ChildNodes.Count - 1; i >= 0; i--)
                    {
                        stack.Push((node.ChildNodes[i], false));
                    }
                    continue;
                }

                if (node.NodeType != HtmlNodeType.Element)
                {
                    map[node] = false;
                    continue;
                }

                var hasRetainable = ShouldRetainNode(node, containsSupportTagMap);
                foreach (var child in node.ChildNodes)
                {
                    if (map.TryGetValue(child, out var childHas) && childHas)
                    {
                        hasRetainable = true;
                        break;
                    }
                }
                map[node] = hasRetainable;
            }

            return map;
        }

        /// <summary>
        /// check if node should be retained
        /// retain h1-h6, img, p contains input/select/button, class contains err
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool ShouldRetainNode(
            HtmlNode node,
            Dictionary<HtmlNode, bool> containsSupportTagMap
        )
        {
            if (node.NodeType != HtmlNodeType.Element)
                return false;

            var tag = node.Name;
            if (tag.Length > 0 && (tag[0] == 'h' || tag[0] == 'H'))
                return true;

            if (tag.StartsWith("img", StringComparison.OrdinalIgnoreCase))
                return true;

            // retain p element which contains input or select
            if (
                string.Equals(tag, "p", StringComparison.OrdinalIgnoreCase)
                && containsSupportTagMap.TryGetValue(node, out var containsSupport)
                && containsSupport
            )
                return true;

            // retain condition
            //if (tag == "p" && node.SelectSingleNode(".//span[contains(@class, 'cond')]") != null)
            //    return true;

            // if div, check v-if, v-else-if, v-else attributes
            if (
                string.Equals(tag, "div", StringComparison.OrdinalIgnoreCase)
                && (
                    node.Attributes.Contains("v-if")
                    || node.Attributes.Contains("v-else-if")
                    || node.Attributes.Contains("v-else")
                )
            )
                return true;

            var classAttr = node.GetAttributeValue("class", string.Empty);
            if (!string.IsNullOrEmpty(classAttr))
            {
                // retain conditional-block wrapper div
                if (
                    string.Equals(tag, "div", StringComparison.OrdinalIgnoreCase)
                    && classAttr.Contains("conditional-block", StringComparison.OrdinalIgnoreCase)
                )
                    return true;

                // has class="err"
                if (classAttr.Contains("err", StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        private static readonly HashSet<string> _supportTags =
            new(StringComparer.OrdinalIgnoreCase) { "input", "select", "button" };

        /// <summary>
        /// check if node or its children contains input 、slect、button element
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool IsContainsInputTag(HtmlNode node)
        {
            if (_supportTags.Contains(node.Name))
            {
                return true;
            }

            foreach (var child in node.ChildNodes)
            {
                if (IsContainsInputTag(child))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// format read macro result:
        /// 1. replace StorageRoot in a tag content to empty
        /// 2. replace a tag href to web url
        /// </summary>
        /// <param name="originHtml"></param>
        /// <param name="tagAToButton"></param>
        /// <returns></returns>
        public string FormatReadMacroResult(string originHtml, bool tagAToButton = true)
        {
            if (string.IsNullOrEmpty(originHtml))
            {
                return string.Empty;
            }

            var doc = new HtmlDocument();
            doc.LoadHtml(originHtml);

            // get all a tags and convert a tags to buttons
            // result exeample:
            // <p> Matrix < b class="eq"><var>M</var></b> was successfully read from
            //   <button data-from= "StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx"
            //     btn-type= "macroReadUpload" title= "click to upload new data" data-event-bound="true">设计内力.xlsx
            //   </button>@Sheet1!A2:E4 <small>TYPE</small>=R
            // </p>

            var aTags = doc.DocumentNode.SelectNodes("//a[@href]");
            if (aTags != null)
            {
                foreach (var aTag in aTags)
                {
                    // only file url
                    if (!File.Exists(aTag.InnerText))
                        continue;

                    if (tagAToButton)
                    {
                        var button = CreateReadFromButton(doc, aTag.InnerText);
                        // replace a tag with button
                        aTag.ParentNode.ReplaceChild(button, aTag);
                    }
                    else
                    {
                        aTag.InnerHtml = Path.GetFileName(aTag.InnerText);
                        var href = aTag.GetAttributeValue("href", string.Empty);
                        if (!string.IsNullOrEmpty(href))
                        {
                            var publicPath = storageService.GetRelativePathToStorageRoot(
                                href.Replace("file:///", string.Empty)
                            );
                            aTag.SetAttributeValue("href", storageService.GetWebUrl(publicPath));
                        }
                    }
                }
            }

            // adapt to original #read result
            // origin example:
            // <p><span class="cond">#read</span> M from StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx @Sheet1!A2:B4 type = R </p>
            // target example:
            // <p>
            //   <span class="cond">#read</span> M from <button
            //     data-from="StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx" btn-type="macroReadUpload"
            //     title="click to upload new data" data-event-bound="true">设计内力.xlsx
            //   </button>
            //   @Sheet1!A2:B4 type = R
            // </p>
            var pTags = doc.DocumentNode.SelectNodes("//span[contains(., '#read')]/parent::p");
            if (pTags != null)
            {
                foreach (var pTag in pTags)
                {
                    // tag example:
                    // "<span class=\"cond\">#read</span>  M from StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx@Sheet1!A2:B4 type=R"

                    var textNode = pTag.ChildNodes.FirstOrDefault(x =>
                        x.NodeType == HtmlNodeType.Text && x.InnerText.Contains("from")
                    );
                    if (textNode == null)
                        continue;

                    var fromText = textNode.InnerText;
                    var startIndex = fromText.IndexOf("from") + 4;
                    var endIndex = fromText.LastIndexOf('.');

                    var fileNameEndIndex = fromText.Length;

                    // check @
                    var lastAtIndex = fromText.IndexOf('@', endIndex + 1);
                    if (lastAtIndex > 0)
                    {
                        fileNameEndIndex = lastAtIndex;
                    }
                    else
                    {
                        // check space
                        var lastSpaceIndex = fromText.IndexOf(' ', endIndex + 1);
                        if (lastSpaceIndex > 0)
                        {
                            fileNameEndIndex = lastSpaceIndex;
                        }
                    }

                    if (startIndex < 0 || endIndex < 0 || fileNameEndIndex < 0)
                        continue;
                    if (endIndex <= startIndex)
                        continue;

                    var filePath = fromText[startIndex..fileNameEndIndex].Trim();
                    if (tagAToButton)
                    {
                        // create a new button element
                        var button = CreateReadFromButton(doc, filePath);
                        // replace file path text with button
                        var newInnerHtml = fromText.Replace(filePath, button.OuterHtml);
                        textNode.InnerHtml = newInnerHtml;
                    }
                    else
                    {
                        var aTag = doc.CreateElement("a");
                        aTag.InnerHtml = Path.GetFileName(filePath);
                        var publicPath = storageService.GetRelativePathToStorageRoot(
                            filePath.Replace("file:///", string.Empty)
                        );
                        aTag.SetAttributeValue("href", storageService.GetWebUrl(publicPath));

                        // replace file path text with a tag
                        var newInnerHtml = fromText.Replace(filePath, aTag.OuterHtml);
                        textNode.InnerHtml = newInnerHtml;
                    }
                }
            }

            return doc.DocumentNode.OuterHtml;
        }

        private static HtmlNode CreateReadFromButton(HtmlDocument doc, string filePath)
        {
            var button = doc.CreateElement("button");
            // copy inner HTML
            button.InnerHtml = Path.GetFileName(filePath);
            button.SetAttributeValue("data-from", filePath);
            button.SetAttributeValue("btn-type", "macroReadUpload");
            button.SetAttributeValue("title", "click to upload new data");
            return button;
        }
    }
}
