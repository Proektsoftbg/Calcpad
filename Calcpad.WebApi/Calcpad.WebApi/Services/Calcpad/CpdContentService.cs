using System.Text;
using Calcpad.Document;
using Calcpad.Document.Archive;
using Calcpad.Document.Core.Segments;
using Calcpad.WebApi.Configs;
using Calcpad.WebApi.Models;
using Calcpad.WebApi.Models.Base;
using Calcpad.WebApi.Utils.Encrypt;
using Calcpad.WebApi.Utils.Web.Exceptions;
using Calcpad.WebApi.Utils.Web.Service;
using HtmlAgilityPack;
using MongoDB.Driver.Linq;

namespace Calcpad.WebApi.Services.Calcpad
{
    /// <summary>
    /// calcpad file content service
    /// </summary>
    /// <param name="db"></param>
    /// <param name="cycleDetector"></param>
    /// <param name="storageService"></param>
    public class CpdContentService(
        MongoDBContext db,
        CycleDetectorService cycleDetector,
        CpdStorageService storageService
    ) : IScopedService
    {
        /// <summary>
        /// operations:
        /// 1. set meta info to file head
        /// 2. resolve include path to server path
        /// 3. resolve read from path to server path
        /// resolve include path to server path
        /// </summary>
        /// <param name="fullPath"></param>
        /// <param name="cpdUid"></param>
        /// <returns></returns>
        public async Task<List<string>> SetMeataInfoAndResolvePath(string fullPath, string cpdUid)
        {
            var cpdReader = CpdReaderFactory.CreateCpdReader(fullPath);

            var replacingRows = new List<CpdLine>();
            // include lines
            var includes = cpdReader.GetIncludeLines();
            if (includes.Count > 0)
            {
                // replace include path to server path
                var uIds = includes.Select(x => x.Uid).ToList();

                // find all include files
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();

                // replace uid to service path
                foreach (var include in includes.OrderBy(x => x.RowIndex))
                {
                    var includeFile = cpdObjects.FirstOrDefault(x => x.UniqueId == include.Uid);
                    if (includeFile != null)
                    {
                        include.SetFilePath(includeFile.FullName);
                        replacingRows.Add(include);
                    }
                }
            }

            // read lines
            var readLines = cpdReader.GetReadLines();
            if (readLines.Count > 0)
            {
                var uIds = readLines.Select(x => x.Uid).ToList();
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();
                foreach (var readLine in readLines)
                {
                    // add data source from uid
                    var readFile = cpdObjects.FirstOrDefault(x => x.UniqueId == readLine.Uid);
                    if (readFile != null)
                    {
                        readLine.SetFilePath(readFile.FullName);
                    }
                    else
                    {
                        // add default data source
                        var defaultDataPath = storageService.GetReadFromPath(
                            fullPath,
                            readLine.FilePath
                        );
                        readLine.SetFilePath(defaultDataPath);
                    }
                    replacingRows.Add(readLine);
                }
            }

            // add header, example:
            // #local '<meta>
            // #hide
            // 'id:1
            // 'description: this is auto generated by calcpad web api, do not edit it
            // #show
            // #global '</meta>
            var header = new List<string>
            {
                "#local '<meta>",
                "#hide",
                "'uid:" + cpdUid,
                "'description: this is auto generated by calcpad web api, do not edit it",
                "#show",
                "#global '</meta>",
            };
            var headerInfo = string.Join(Environment.NewLine, header) + Environment.NewLine;

            var content = CpdWriter.BuildCpdContent(cpdReader.ReadStringLines(), replacingRows);

            // upsert meta info at head
            const string startMarker = "#local '<meta>";
            const string endMarker = "#global '</meta>";
            var startIndex = content.IndexOf(startMarker, StringComparison.OrdinalIgnoreCase);
            if (startIndex >= 0)
            {
                var endIndex = content.IndexOf(
                    endMarker,
                    startIndex,
                    StringComparison.OrdinalIgnoreCase
                );
                if (endIndex >= 0)
                {
                    // remove old meta info
                    content = content.Remove(startIndex, endIndex + endMarker.Length - startIndex);
                }
                else
                {
                    content = content.Remove(startIndex, 1);
                }
            }

            var fileWriter = CpdWriterFactory.CreateCpdWriter();
            fileWriter.WriteFile(fullPath, headerInfo + content);

            // check cycles
            var includeIds = includes
                .Select(x => x.Uid)
                .Where(x => !string.IsNullOrEmpty(x))
                .ToList();
            var hasCycle = await cycleDetector.HasCycleAsync(cpdUid, includeIds);
            if (hasCycle)
            {
                throw new KnownException("include cycle detected");
            }

            return includeIds;
        }

        /// <summary>
        /// get file access uri
        /// if public file, return public stream uri
        /// if private file, return service path with uid
        /// </summary>
        /// <param name="fileObject"></param>
        /// <returns></returns>
        public string GetFileAccessUri(CalcpadFileModel fileObject)
        {
            if (!fileObject.IsCpd)
            {
                return $"api/v1/calcpad-file/stream/public/{fileObject.Id}?uid={fileObject.UniqueId}";
            }

            return $"{fileObject.FullName}'?uid={fileObject.UniqueId}";
        }

        /// <summary>
        /// simplify html, remain row or p element which contains input,select,h1-h6
        /// </summary>
        /// <param name="originHtml"></param>
        /// <returns></returns>
        public string SimplifyHtml(string originHtml)
        {
            if (string.IsNullOrEmpty(originHtml))
            {
                return string.Empty;
            }

            var doc = new HtmlDocument();
            doc.LoadHtml(originHtml);

            // retain only nodes that should be kept
            var nodesToKeep = new List<HtmlNode>();
            foreach (var node in doc.DocumentNode.ChildNodes)
            {
                if (ShouldRetainNode(node))
                    nodesToKeep.Add(node);
            }

            // create new document with only the nodes to keep
            var newDoc = new HtmlDocument();
            foreach (var node in nodesToKeep)
            {
                newDoc.DocumentNode.AppendChild(node.Clone());
            }

            if (newDoc.DocumentNode.ChildNodes.Count == 0)
            {
                return originHtml;
            }
            return newDoc.DocumentNode.OuterHtml;
        }

        /// <summary>
        /// check if node should be retained
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool ShouldRetainNode(HtmlNode node)
        {
            if (node.NodeType != HtmlNodeType.Element)
                return false;

            var tag = node.Name.ToLower();
            if (tag.StartsWith('h'))
                return true;

            if (tag.StartsWith("img"))
                return true;

            // retain p element which contains input or select
            if (tag == "p" && IsContainsInputTag(node))
                return true;

            return false;
        }

        private static HashSet<string> _supportTags = ["input", "select", "button"];

        /// <summary>
        /// check if node or its children contains input 、slect、button element
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool IsContainsInputTag(HtmlNode node)
        {
            if (_supportTags.Contains(node.Name.ToLower()))
            {
                return true;
            }

            foreach (var child in node.ChildNodes)
            {
                if (IsContainsInputTag(child))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// format read macro result:
        /// 1. replace StorageRoot in a tag content to empty
        /// 2. replace a tag href to web url
        /// </summary>
        /// <param name="originHtml"></param>
        /// <param name="tagAToButton"></param>
        /// <returns></returns>
        public string FormatReadMacroResult(string originHtml, bool tagAToButton = true)
        {
            var doc = new HtmlDocument();
            doc.LoadHtml(originHtml);

            // get all a tags
            var aTags = doc.DocumentNode.SelectNodes("//a[@href]");
            if (aTags != null)
            {
                foreach (var aTag in aTags)
                {
                    // only file url
                    if (!File.Exists(aTag.InnerText))
                        continue;

                    if (tagAToButton)
                    {
                        // create a new button element
                        var button = doc.CreateElement("button");
                        // copy inner HTML
                        button.InnerHtml = Path.GetFileName(aTag.InnerText);
                        button.SetAttributeValue("data-from", aTag.InnerText);
                        button.SetAttributeValue("btn-type", "macroReadUpload");
                        button.SetAttributeValue("title", "click to upload new data");
                        // replace a tag with button
                        aTag.ParentNode.ReplaceChild(button, aTag);
                    }
                    else
                    {
                        aTag.InnerHtml = Path.GetFileName(aTag.InnerText);
                        var href = aTag.GetAttributeValue("href", string.Empty);
                        if (!string.IsNullOrEmpty(href))
                        {
                            var publicPath = storageService.GetRelativePathToStorageRoot(
                                href.Replace("file:///", string.Empty)
                            );
                            aTag.SetAttributeValue("href", storageService.GetWebUrl(publicPath));
                        }
                    }
                }
            }

            return doc.DocumentNode.OuterHtml;
        }

        /// <summary>
        /// update all read from path in cpd file
        /// </summary>
        /// <param name="readFromPath"></param>
        /// <param name="newReadFromPath"></param>
        public async void UpdateCpdReadFrom(string readFromPath, string newReadFromPath)
        {
            if (readFromPath == newReadFromPath)
                return;

            // read files
        }
    }
}
