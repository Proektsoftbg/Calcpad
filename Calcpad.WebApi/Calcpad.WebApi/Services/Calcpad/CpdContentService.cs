using System;
using System.Text;
using System.Text.RegularExpressions;
using Calcpad.Document;
using Calcpad.Document.Archive;
using Calcpad.Document.Core.Segments;
using Calcpad.WebApi.Configs;
using Calcpad.WebApi.Models;
using Calcpad.WebApi.Models.Base;
using Calcpad.WebApi.Utils.Calcpad;
using Calcpad.WebApi.Utils.Encrypt;
using Calcpad.WebApi.Utils.Web.Exceptions;
using Calcpad.WebApi.Utils.Web.Service;
using DocumentFormat.OpenXml.Drawing;
using HtmlAgilityPack;
using MongoDB.Driver.Linq;
using Path = System.IO.Path;

namespace Calcpad.WebApi.Services.Calcpad
{
    /// <summary>
    /// calcpad file content service
    /// </summary>
    /// <param name="db"></param>
    /// <param name="cycleDetector"></param>
    /// <param name="storageService"></param>
    public class CpdContentService(
        MongoDBContext db,
        CycleDetectorService cycleDetector,
        CpdStorageService storageService
    ) : IScopedService
    {
        /// <summary>
        /// operations:
        /// 1. set meta info to file head
        /// 2. resolve include path to server path
        /// 3. resolve read from path to server path
        /// resolve include path to server path
        /// </summary>
        /// <param name="fullPath"></param>
        /// <param name="cpdUid"></param>
        /// <returns></returns>
        public async Task<List<string>> SetMeataInfoAndResolvePath(string fullPath, string cpdUid)
        {
            var cpdReader = CpdReaderFactory.CreateCpdReader(fullPath);

            var replacingRows = new List<CpdLine>();
            // include lines
            var includes = cpdReader.GetIncludeLines();
            if (includes.Count > 0)
            {
                // replace include path to server path
                var uIds = includes.Select(x => x.Uid).ToList();

                // find all include files
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();

                // replace uid to service path
                foreach (var include in includes.OrderBy(x => x.RowIndex))
                {
                    var includeFile = cpdObjects.FirstOrDefault(x => x.UniqueId == include.Uid);
                    if (includeFile != null)
                    {
                        include.SetFilePath(includeFile.FullName);
                        replacingRows.Add(include);
                    }
                }
            }

            // read lines
            var readLines = cpdReader.GetReadLines();
            if (readLines.Count > 0)
            {
                var uIds = readLines.Select(x => x.Uid).ToList();
                var cpdObjects = await db.AsQueryable<CalcpadFileModel>()
                    .Where(x => uIds.Contains(x.UniqueId))
                    .ToListAsync();
                foreach (var readLine in readLines)
                {
                    // add data source from uid
                    var readFile = cpdObjects.FirstOrDefault(x => x.UniqueId == readLine.Uid);
                    if (readFile != null)
                    {
                        readLine.SetFilePath(readFile.FullName);
                        replacingRows.Add(readLine);
                    }
                }
            }

            // add header, example:
            // #local '<meta>
            // #hide
            // 'id:1
            // 'description: this is auto generated by calcpad web api, do not edit it
            // #show
            // #global '</meta>
            var header = new List<string>
            {
                "#local '<meta>",
                "#hide",
                "'uid:" + cpdUid,
                "'description: this is auto generated by calcpad web api, do not edit it",
                "#show",
                "#global '</meta>",
            };
            var headerInfo = string.Join(Environment.NewLine, header) + Environment.NewLine;

            var content = CpdWriter.BuildCpdContent(cpdReader.ReadStringLines(), replacingRows);

            // upsert meta info at head
            const string startMarker = "#local '<meta>";
            const string endMarker = "#global '</meta>";
            var startIndex = content.IndexOf(startMarker, StringComparison.OrdinalIgnoreCase);
            if (startIndex >= 0)
            {
                var endIndex = content.IndexOf(
                    endMarker,
                    startIndex,
                    StringComparison.OrdinalIgnoreCase
                );
                if (endIndex >= 0)
                {
                    // remove old meta info
                    content = content.Remove(startIndex, endIndex + endMarker.Length - startIndex);
                }
                else
                {
                    content = content.Remove(startIndex, 1);
                }
            }

            var fileWriter = CpdWriterFactory.CreateCpdWriter();
            fileWriter.WriteFile(fullPath, headerInfo + content);

            // check cycles
            var includeIds = includes
                .Select(x => x.Uid)
                .Where(x => !string.IsNullOrEmpty(x))
                .ToList();
            var hasCycle = await cycleDetector.HasCycleAsync(cpdUid, includeIds);
            if (hasCycle)
            {
                throw new KnownException("include cycle detected");
            }

            return includeIds;
        }

        /// <summary>
        /// get file access uri
        /// if public file, return public stream uri
        /// if private file, return service path with uid
        /// </summary>
        /// <param name="fileObject"></param>
        /// <returns></returns>
        public string GetFileAccessUri(CalcpadFileModel fileObject)
        {
            if (!fileObject.IsCpd)
            {
                return $"api/v1/calcpad-file/stream/public/ids/{fileObject.Id}?uid={fileObject.UniqueId}&name={Path.GetFileName(fileObject.ObjectName)}";
            }

            return $"{fileObject.FullName}'?uid={fileObject.UniqueId}";
        }

        /// <summary>
        /// simplify html, remain row or p element which contains input,select,h1-h6
        /// </summary>
        /// <param name="originHtml"></param>
        /// <returns></returns>
        public string SimplifyHtml(string originHtml)
        {
            if (string.IsNullOrEmpty(originHtml))
            {
                return string.Empty;
            }

            var doc = new HtmlDocument()
            {
                OptionFixNestedTags = true,
                OptionAutoCloseOnEnd = true
            };
            doc.LoadHtml(originHtml);

            // process conditional blocks (#if, #else, #else if, #end if)
            var conditionWrapper = new ConditionBlockWrapper(doc);
            conditionWrapper.ProcessConditionalBlocks();

            // recursively clean nodes
            var newDoc = new HtmlDocument();
            foreach (var node in doc.DocumentNode.ChildNodes)
            {
                var cloned = node.Clone();
                var isRetain = CleanNodeRecursively(cloned);
                if (!isRetain)
                    continue;

                newDoc.DocumentNode.AppendChild(cloned);
            }

            // if empty, return origin
            if (newDoc.DocumentNode.ChildNodes.Count == 0)
            {
                return originHtml;
            }
            return newDoc.DocumentNode.OuterHtml;
        }

        // private static void CleanPTagsRecursively(HtmlNode root)
        // {
        //     if (root == null)
        //         return;

        //     // Compute subtree maps once, then prune <p> tags in O(n).
        //     var containsSupportTagMap = BuildContainsSupportTagMap(root);
        //     var subtreeHasRetainableMap = BuildSubtreeHasRetainableMap(root, containsSupportTagMap);

        //     var pNodes = root.Descendants()
        //         .Where(n =>
        //             n.NodeType == HtmlNodeType.Element
        //             && string.Equals(n.Name, "p", StringComparison.OrdinalIgnoreCase)
        //         )
        //         .ToList();

        //     foreach (var p in pNodes)
        //     {
        //         if (
        //             containsSupportTagMap.TryGetValue(p, out var containsSupport) && containsSupport
        //         )
        //             continue;

        //         if (subtreeHasRetainableMap.TryGetValue(p, out var hasRetainable) && hasRetainable)
        //             continue;

        //         p.Remove();
        //     }
        // }

        private readonly static string[] _containerClasses = ["conditional-block", "indent"];
        private static readonly string[] _containerAttr = ["v-if", "v-else-if", "v-else"];

        private static bool CleanNodeRecursively(HtmlNode node)
        {
            if (node == null)
                return true;

            if (IsRetainingNode(node))
                return true;

            var containerType = GetContainerType(node);
            if (containerType == 0)
                return false;

            if (containerType == 1)
            {
                // present tag p
                return IsContainsSupportedTag(node);
            }

            if (containerType == 2)
            {
                // div with class conditional-block、indent、v-if、v-else-if、v-else
                foreach (var child in node.ChildNodes.ToList())
                {
                    var isRetain = CleanNodeRecursively(child);
                    if (!isRetain)
                    {
                        node.RemoveChild(child);
                    }
                }

                return node.ChildNodes.Count > 0;
            }

            return false;
        }

        /// <summary>
        /// get container type
        /// zero -- not container
        /// 1 -- p tag
        /// 2 -- div tag with class conditional-block、indent、v-if、v-else-if、v-else
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static int GetContainerType(HtmlNode node)
        {
            if (node.NodeType != HtmlNodeType.Element)
                return 0;

            var tag = node.Name;
            if (string.Equals(tag, "p", StringComparison.OrdinalIgnoreCase))
                return 1;

            if (!string.Equals(tag, "div", StringComparison.OrdinalIgnoreCase))
                return 0;

            // check class attribute
            var classAttr = node.GetAttributeValue("class", string.Empty);
            if (classAttr != null)
            {
                var classList = classAttr
                    .Split(' ', StringSplitOptions.RemoveEmptyEntries)
                    .Select(x => x.Trim())
                    .ToList();
                if (classList.Any(x => _containerClasses.Contains(x)))
                    return 2;
            }

            // check v-if、v-else-if、v-else attribute
            foreach (var attr in _containerAttr)
            {
                if (node.Attributes.Contains(attr))
                    return 2;
            }

            return 0;
        }

        private static readonly HashSet<string> _supportTags =
            new(StringComparer.OrdinalIgnoreCase) { "input", "select", "button", "img" };

        /// <summary>
        /// check if node should be retained
        /// retain h1-h6, img, p contains input/select/button, class contains err
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool IsRetainingNode(HtmlNode node)
        {
            if (node.NodeType != HtmlNodeType.Element)
                return false;

            var tag = node.Name;
            if (tag.Length > 0 && (tag[0] == 'h' || tag[0] == 'H'))
                return true;

            if (_supportTags.Contains(tag.ToLower()))
                return true;

            var classAttr = node.GetAttributeValue("class", string.Empty);
            if (!string.IsNullOrEmpty(classAttr))
            {
                // has class="err"
                if (classAttr.Contains("err", StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// check if node or its children contains input 、slect、button element
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private static bool IsContainsSupportedTag(HtmlNode node)
        {
            if (_supportTags.Contains(node.Name))
            {
                return true;
            }

            foreach (var child in node.ChildNodes)
            {
                if (IsContainsSupportedTag(child))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// format read macro result:
        /// 1. replace StorageRoot in a tag content to empty
        /// 2. replace a tag href to web url
        /// </summary>
        /// <param name="originHtml"></param>
        /// <param name="tagAToButton"></param>
        /// <returns></returns>
        public string FormatReadMacroResult(string originHtml, bool tagAToButton = true)
        {
            if (string.IsNullOrEmpty(originHtml))
            {
                return string.Empty;
            }

            var doc = new HtmlDocument();
            doc.LoadHtml(originHtml);

            // get all a tags and convert a tags to buttons
            // result exeample:
            // <p> Matrix < b class="eq"><var>M</var></b> was successfully read from
            //   <button data-from= "StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx"
            //     btn-type= "macroReadUpload" title= "click to upload new data" data-event-bound="true">设计内力.xlsx
            //   </button>@Sheet1!A2:E4 <small>TYPE</small>=R
            // </p>

            var aTags = doc.DocumentNode.SelectNodes("//a[@href]");
            if (aTags != null)
            {
                foreach (var aTag in aTags)
                {
                    // only file url
                    if (!File.Exists(aTag.InnerText))
                        continue;

                    if (tagAToButton)
                    {
                        var button = CreateReadFromButton(doc, aTag.InnerText);
                        // replace a tag with button
                        aTag.ParentNode.ReplaceChild(button, aTag);
                    }
                    else
                    {
                        aTag.InnerHtml = Path.GetFileName(aTag.InnerText);
                        var href = aTag.GetAttributeValue("href", string.Empty);
                        if (!string.IsNullOrEmpty(href))
                        {
                            var publicPath = storageService.GetRelativePathToStorageRoot(
                                href.Replace("file:///", string.Empty)
                            );
                            aTag.SetAttributeValue("href", storageService.GetWebUrl(publicPath));
                        }
                    }
                }
            }

            // adapt to original #read result
            // origin example:
            // <p><span class="cond">#read</span> M from StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx @Sheet1!A2:B4 type = R </p>
            // target example:
            // <p>
            //   <span class="cond">#read</span> M from <button
            //     data-from="StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx" btn-type="macroReadUpload"
            //     title="click to upload new data" data-event-bound="true">设计内力.xlsx
            //   </button>
            //   @Sheet1!A2:B4 type = R
            // </p>
            var pTags = doc.DocumentNode.SelectNodes("//span[contains(., '#read')]/parent::p");
            if (pTags != null)
            {
                foreach (var pTag in pTags)
                {
                    // tag example:
                    // "<span class=\"cond\">#read</span>  M from StoragetRoot/public/2025/11/12/1f9ebf6eaccfd82bb81278a8d72b0730/设计内力.xlsx@Sheet1!A2:B4 type=R"

                    var textNode = pTag.ChildNodes.FirstOrDefault(x =>
                        x.NodeType == HtmlNodeType.Text && x.InnerText.Contains("from")
                    );
                    if (textNode == null)
                        continue;

                    var fromText = textNode.InnerText;
                    var startIndex = fromText.IndexOf("from") + 4;
                    var endIndex = fromText.LastIndexOf('.');

                    var fileNameEndIndex = fromText.Length;

                    // check @
                    var lastAtIndex = fromText.IndexOf('@', endIndex + 1);
                    if (lastAtIndex > 0)
                    {
                        fileNameEndIndex = lastAtIndex;
                    }
                    else
                    {
                        // check space
                        var lastSpaceIndex = fromText.IndexOf(' ', endIndex + 1);
                        if (lastSpaceIndex > 0)
                        {
                            fileNameEndIndex = lastSpaceIndex;
                        }
                    }

                    if (startIndex < 0 || endIndex < 0 || fileNameEndIndex < 0)
                        continue;
                    if (endIndex <= startIndex)
                        continue;

                    var filePath = fromText[startIndex..fileNameEndIndex].Trim();
                    if (tagAToButton)
                    {
                        // create a new button element
                        var button = CreateReadFromButton(doc, filePath);
                        // replace file path text with button
                        var newInnerHtml = fromText.Replace(filePath, button.OuterHtml);
                        textNode.InnerHtml = newInnerHtml;
                    }
                    else
                    {
                        var aTag = doc.CreateElement("a");
                        aTag.InnerHtml = Path.GetFileName(filePath);
                        var publicPath = storageService.GetRelativePathToStorageRoot(
                            filePath.Replace("file:///", string.Empty)
                        );
                        aTag.SetAttributeValue("href", storageService.GetWebUrl(publicPath));

                        // replace file path text with a tag
                        var newInnerHtml = fromText.Replace(filePath, aTag.OuterHtml);
                        textNode.InnerHtml = newInnerHtml;
                    }
                }
            }

            return doc.DocumentNode.OuterHtml;
        }

        private static HtmlNode CreateReadFromButton(HtmlDocument doc, string filePath)
        {
            var button = doc.CreateElement("button");
            // copy inner HTML
            button.InnerHtml = Path.GetFileName(filePath);
            button.SetAttributeValue("data-from", filePath);
            button.SetAttributeValue("btn-type", "macroReadUpload");
            button.SetAttributeValue("title", "click to upload new data");
            return button;
        }
    }
}
